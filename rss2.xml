<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>纸飞机的旅行</title>
    <link>https://jhcgnb.cn/</link>
    
    <atom:link href="https://jhcgnb.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>选择有时候比努力更重要</description>
    <pubDate>Sat, 22 Jul 2023 13:43:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>5.Ajax和网络</title>
      <link>https://jhcgnb.cn/posts/undefined/</link>
      <guid>https://jhcgnb.cn/posts/undefined/</guid>
      <pubDate>Sat, 22 Jul 2023 13:42:42 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Ajax和网络&quot;&gt;&lt;a href=&quot;#Ajax和网络&quot; class=&quot;headerlink&quot; title=&quot;Ajax和网络&quot;&gt;&lt;/a&gt;Ajax和网络&lt;/h1&gt;&lt;h2 id=&quot;1、Ajax-是什么-如何创建一个Ajax？&quot;&gt;&lt;a href=&quot;#1、Ajax-是什么-</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Ajax和网络"><a href="#Ajax和网络" class="headerlink" title="Ajax和网络"></a>Ajax和网络</h1><h2 id="1、Ajax-是什么-如何创建一个Ajax？"><a href="#1、Ajax-是什么-如何创建一个Ajax？" class="headerlink" title="1、Ajax 是什么? 如何创建一个Ajax？"></a>1、Ajax 是什么? 如何创建一个Ajax？</h2><p>Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合，主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持<br>使用ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果<br>基本步骤：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr =<span class="literal">null</span>;<span class="comment">//创建对象 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>)&#123;</span><br><span class="line">xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">     xhr.<span class="title function_">open</span>(“方式”,”地址”,”标志位”);<span class="comment">//初始化请求 </span></span><br><span class="line">     xhr.<span class="title function_">setRequestHeader</span>(“”,””);<span class="comment">//设置http头信息 </span></span><br><span class="line">     xhr.<span class="property">onreadystatechange</span> =<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;<span class="comment">//指定回调函数 </span></span><br><span class="line">     xhr.<span class="title function_">send</span>();<span class="comment">//发送请求 </span></span><br></pre></td></tr></table></figure><p>js框架（jQuery&#x2F;EXTJS等）提供的ajax  API对原生的ajax进行了封装，熟悉了基础理论，再学习别的框架就会得心应手，好多都是换汤不换药的内容</p><h2 id="2、同步和异步的区别"><a href="#2、同步和异步的区别" class="headerlink" title="2、同步和异步的区别?"></a>2、同步和异步的区别?</h2><p>同步：阻塞的<br>-张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭<br>&#x3D;浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面<br>异步：非阻塞的<br>-张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃<br>&#x3D;浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新</p><h2 id="3、如何解决跨域问题"><a href="#3、如何解决跨域问题" class="headerlink" title="3、如何解决跨域问题?"></a>3、如何解决跨域问题?</h2><p>理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域<br>出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容，所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案</p><h2 id="4、页面编码和被请求的资源编码如果不一致如何处理？"><a href="#4、页面编码和被请求的资源编码如果不一致如何处理？" class="headerlink" title="4、页面编码和被请求的资源编码如果不一致如何处理？"></a>4、页面编码和被请求的资源编码如果不一致如何处理？</h2><p>对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用 encodeURIComponent函数对参数进行编码处理，后台开发语言都有相应的解码api。对于post请求不需要进行编码</p><h2 id="5、简述ajax-的过程。"><a href="#5、简述ajax-的过程。" class="headerlink" title="5、简述ajax 的过程。"></a>5、简述ajax 的过程。</h2><ol><li>创建XMLHttpRequest对象,也就是创建一个异步调用对象</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li><li>设置响应HTTP请求状态变化的函数</li><li>发送HTTP请求</li><li>获取异步调用返回的数据</li><li>使用JavaScript和DOM实现局部刷新</li></ol><h2 id="6、阐述一下异步加载。"><a href="#6、阐述一下异步加载。" class="headerlink" title="6、阐述一下异步加载。"></a>6、阐述一下异步加载。</h2><ol><li>异步加载的方案： 动态插入 script 标签</li><li>通过 ajax 去获取 js 代码，然后通过 eval 执行</li><li>script 标签上添加 defer 或者 async 属性</li><li>创建并插入 iframe，让它异步执行 js</li></ol><h2 id="7、请解释一下-JavaScript-的同源策略。"><a href="#7、请解释一下-JavaScript-的同源策略。" class="headerlink" title="7、请解释一下 JavaScript 的同源策略。"></a>7、请解释一下 JavaScript 的同源策略。</h2><p>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><h2 id="8、GET和POST的区别，何时使用POST？"><a href="#8、GET和POST的区别，何时使用POST？" class="headerlink" title="8、GET和POST的区别，何时使用POST？"></a>8、GET和POST的区别，何时使用POST？</h2><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符<br>POST：一般用于修改服务器上的资源，对所发送的信息没有限制<br>在以下情况中，请使用 POST 请求：</p><ol><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ol><h2 id="9、ajax-是什么-ajax-的交互模型-同步和异步的区别-如何解决跨域问题"><a href="#9、ajax-是什么-ajax-的交互模型-同步和异步的区别-如何解决跨域问题" class="headerlink" title="9、ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?"></a>9、ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</h2><ol><li>通过异步模式，提升了用户体验</li><li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用</li><li>Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li></ol><h2 id="10、-Ajax的最大的特点是什么。"><a href="#10、-Ajax的最大的特点是什么。" class="headerlink" title="10、 Ajax的最大的特点是什么。"></a>10、 Ajax的最大的特点是什么。</h2><pre><code>Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据，节约带宽资源 </code></pre><h2 id="11、ajax的缺点"><a href="#11、ajax的缺点" class="headerlink" title="11、ajax的缺点"></a>11、ajax的缺点</h2><p>1、ajax不支持浏览器back按钮。<br>2、安全问题 AJAX暴露了与服务器交互的细节。<br>3、对搜索引擎的支持比较弱。<br>4、破坏了程序的异常机制。</p><h2 id="12、ajax请求的时候get-和post方式的区别"><a href="#12、ajax请求的时候get-和post方式的区别" class="headerlink" title="12、ajax请求的时候get 和post方式的区别"></a>12、ajax请求的时候get 和post方式的区别</h2><p>get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。<br>post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。</p><h2 id="13、解释jsonp的原理，以及为什么不是真正的ajax"><a href="#13、解释jsonp的原理，以及为什么不是真正的ajax" class="headerlink" title="13、解释jsonp的原理，以及为什么不是真正的ajax"></a>13、解释jsonp的原理，以及为什么不是真正的ajax</h2><p>Jsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术</p><h2 id="14、什么是Ajax和JSON，它们的优缺点。"><a href="#14、什么是Ajax和JSON，它们的优缺点。" class="headerlink" title="14、什么是Ajax和JSON，它们的优缺点。"></a>14、什么是Ajax和JSON，它们的优缺点。</h2><p>Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，用于在Web页面中实现异步数据交互，实现页面局部刷新。<br>优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验<br>缺点：对搜索引擎不友好；要实现ajax下的前后退功能成本较大；可能造成请求数的增加跨域问题限制；<br>JSON是一种轻量级的数据交换格式，ECMA的一个子集<br>优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）</p><h2 id="15、http常见的状态码有那些？分别代表是什么意思？"><a href="#15、http常见的状态码有那些？分别代表是什么意思？" class="headerlink" title="15、http常见的状态码有那些？分别代表是什么意思？"></a>15、http常见的状态码有那些？分别代表是什么意思？</h2><p>200 - 请求成功<br>301 - 资源（网页等）被永久转移到其它URL<br>404 - 请求的资源（网页等）不存在<br>500 - 内部服务器错误</p><h2 id="16、一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#16、一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="16、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>16、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><p>分为4个步骤：</p><ol><li>当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。</li><li>浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP&#x2F;IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</li><li>一旦 TCP&#x2F;IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。</li><li>此时，Web 服务器提供资源服务，客户端开始下载资源。</li></ol><h2 id="17、ajax请求的时候get-和post方式的区别"><a href="#17、ajax请求的时候get-和post方式的区别" class="headerlink" title="17、ajax请求的时候get 和post方式的区别"></a>17、ajax请求的时候get 和post方式的区别</h2><p>get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。<br>post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。</p><h2 id="18、ajax请求时，如何解释json数据"><a href="#18、ajax请求时，如何解释json数据" class="headerlink" title="18、ajax请求时，如何解释json数据"></a>18、ajax请求时，如何解释json数据</h2><p>使用eval() 或者JSON.parse() 鉴于安全性考虑，推荐使用JSON.parse()更靠谱，对数据的安全性更好。</p><h2 id="19、-javascript的本地对象，内置对象和宿主对象"><a href="#19、-javascript的本地对象，内置对象和宿主对象" class="headerlink" title="19、.javascript的本地对象，内置对象和宿主对象"></a>19、.javascript的本地对象，内置对象和宿主对象</h2><p>本地对象为独立于宿主环境的ECMAScript提供的对象，包括Array Object RegExp等可以new实例化的对象<br>内置对象为Gload，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)<br>宿主对象为所有的非本地对象，所有的BOM和DOM对象都是宿主对象，如浏览器自带的document,window 等对象</p><h2 id="20、为什么利用多个域名来存储网站资源会更有效？"><a href="#20、为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="20、为什么利用多个域名来存储网站资源会更有效？"></a>20、为什么利用多个域名来存储网站资源会更有效？</h2><p>确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站，并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。</p><h2 id="21、请说出三种减低页面加载时间的方法"><a href="#21、请说出三种减低页面加载时间的方法" class="headerlink" title="21、请说出三种减低页面加载时间的方法"></a>21、请说出三种减低页面加载时间的方法</h2><p>1、压缩css、js文件<br>2、合并js、css文件，减少http请求<br>3、外部js、css文件放在最底下<br>4、减少dom操作，尽可能用变量替代不必要的dom操作</p><h2 id="22、HTTP状态码都有那些。"><a href="#22、HTTP状态码都有那些。" class="headerlink" title="22、HTTP状态码都有那些。"></a>22、HTTP状态码都有那些。</h2><p>200 OK      &#x2F;&#x2F;客户端请求成功<br>400 Bad Request  &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解<br>403 Forbidden  &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务<br>404 Not Found  &#x2F;&#x2F;请求资源不存在，输入了错误的URL<br>500 Internal Server Error &#x2F;&#x2F;服务器发生不可预期的错误<br>503 Server Unavailable  &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/undefined/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>流形与非流行</title>
      <link>https://jhcgnb.cn/posts/467cee4/</link>
      <guid>https://jhcgnb.cn/posts/467cee4/</guid>
      <pubDate>Sat, 08 Jul 2023 13:45:31 GMT</pubDate>
      
        
        
      <description>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;流形三角形网格（Manifold-Triangle-Mesh）和非流形网格（Non-Manifold-Mesh）&quot;&gt;&lt;a href=&quot;#流形三角形网格（Manifold-</description>
        
      
      
      
      <content:encoded><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="流形三角形网格（Manifold-Triangle-Mesh）和非流形网格（Non-Manifold-Mesh）"><a href="#流形三角形网格（Manifold-Triangle-Mesh）和非流形网格（Non-Manifold-Mesh）" class="headerlink" title="流形三角形网格（Manifold Triangle Mesh）和非流形网格（Non-Manifold Mesh）"></a>流形三角形网格（Manifold Triangle Mesh）和非流形网格（Non-Manifold Mesh）</h3><p>流形三角形网格（Manifold Triangle Mesh）和非流形网格（Non-Manifold Mesh）是在计算机图形学和几何处理中常见的两种网格类型。它们具有不同的特征和限制，对于不同的应用领域和算法，选择合适的网格类型是非常重要的。</p><ol><li><p>流形三角形网格：<br>流形三角形网格是一种拓扑上具有连续性和封闭性的网格。它的特征包括：</p><ul><li>每个顶点最多与两个边和两个面相连。</li><li>每个边最多与两个面相连。</li><li>每个面最多与三条边和三个顶点相连。</li><li>网格中不存在孤立的顶点、边或面。</li></ul><p>流形三角形网格常用于表示光滑曲面和可变形物体，它具有良好的几何性质和拓扑特征，适用于各种几何处理算法，如渲染、形状分析和物理模拟等。</p></li><li><p>非流形网格：<br>非流形网格是一种拓扑上不具备连续性和封闭性的网格。它的特征包括：</p><ul><li>顶点、边或面可以具有任意数量的相邻元素。</li><li>存在孤立的顶点、边或面。</li><li>边和面之间的连接关系可以是多对多的。</li></ul><p>非流形网格常用于表示复杂的几何结构，如曲面上的孔洞、尖锐的边缘或非连续的形状。然而，由于其拓扑特性的复杂性，非流形网格在某些算法和应用中可能会导致问题，例如光滑、纹理映射和体积建模等。</p></li></ol><p>对于流形三角形网格和非流形网格，需要根据具体的应用场景和算法需求选择合适的网格类型。流形三角形网格适用于大多数常规几何处理任务，而非流形网格则更适用于具有复杂拓扑结构的特殊情况。在处理非流形网格时，需要特别注意处理拓扑上的不连续性和边界条件。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E5%AD%A6%E6%9C%AF/">学术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <comments>https://jhcgnb.cn/posts/467cee4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>详解@RequestParam</title>
      <link>https://jhcgnb.cn/posts/f43726f7/</link>
      <guid>https://jhcgnb.cn/posts/f43726f7/</guid>
      <pubDate>Tue, 04 Jul 2023 02:07:55 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;RequestParam&quot;&gt;&lt;a href=&quot;#RequestParam&quot; class=&quot;headerlink&quot; title=&quot;@RequestParam&quot;&gt;&lt;/a&gt;@RequestParam&lt;/h3&gt;&lt;p&gt;在Java中，&lt;code&gt;@RequestParam&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>在Java中，<code>@RequestParam</code> 是一个注解，用于从HTTP请求中获取参数值。它通常用于Spring MVC框架中的控制器方法中，以指定方法参数应该绑定到HTTP请求中的特定参数。</p><p><code>@RequestParam</code> 可以用于处理HTTP请求的查询参数、表单参数或路径参数。它可以应用于方法的参数或方法的参数上的注解。</p><p>下面是一些示例：</p><ol><li>使用默认参数名称：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将尝试从HTTP请求中获取名为 “param” 的查询参数，并将其绑定到方法参数 <code>param</code>。</p><ol start="2"><li>使用自定义参数名称：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam(&quot;customParam&quot;)</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，<code>@RequestParam</code> 注解指定了参数的自定义名称 “customParam”，它将从HTTP请求中获取该参数，并将其绑定到方法参数 <code>param</code>。</p><ol start="3"><li>设置默认值：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam(value = &quot;param&quot;, defaultValue = &quot;default&quot;)</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，如果请求中没有名为 “param” 的参数，或者参数的值为空，那么方法参数 <code>param</code> 将被设置为默认值 “default”。</p><ol start="4"><li>必需的参数：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam(required = true)</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>@RequestParam</code> 注解的 <code>required</code> 属性被设置为 <code>true</code>，表示参数是必需的。如果请求中没有提供该参数，将会返回错误。</p><p>总结一下，<code>@RequestParam</code> 注解用于从HTTP请求中获取参数值，并将其绑定到Java方法的参数。它提供了许多选项，可以根据需要配置参数的名称、默认值和是否必需。这样，开发者可以方便地处理HTTP请求中的参数。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/Java/">Java</category>
      
      
      <comments>https://jhcgnb.cn/posts/f43726f7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Cesium面试题</title>
      <link>https://jhcgnb.cn/posts/a98e3ede/</link>
      <guid>https://jhcgnb.cn/posts/a98e3ede/</guid>
      <pubDate>Mon, 03 Jul 2023 06:07:01 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e0239a75f96830e577eef736ebcad965.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;heade</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/e0239a75f96830e577eef736ebcad965.png" alt="img"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="Cesium开发面试题"><a href="#Cesium开发面试题" class="headerlink" title="Cesium开发面试题"></a>Cesium开发面试题</h1><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="1、请简要介绍一下Cesium的基本功能。"><a href="#1、请简要介绍一下Cesium的基本功能。" class="headerlink" title="1、请简要介绍一下Cesium的基本功能。"></a>1、请简要介绍一下Cesium的基本功能。</h2><p>答：Cesium是一款3D地球可视化引擎，可以在Web浏览器中显示高度真实感的3D地球场景，包括地形、地表纹理、3D建筑、水域等。它提供多种漫游和导航方式，支持多种地形和影像数据格式，以及3D Tiles、CZML等技术，可以用于实时位置追踪、天文数据显示、地下和空中场景等应用场景。</p><h2 id="2、请解释一下Cesium中的3D-Tiles技术是什么，以及它的作用是什么。"><a href="#2、请解释一下Cesium中的3D-Tiles技术是什么，以及它的作用是什么。" class="headerlink" title="2、请解释一下Cesium中的3D Tiles技术是什么，以及它的作用是什么。"></a>2、请解释一下Cesium中的3D Tiles技术是什么，以及它的作用是什么。</h2><p>  答：3D Tiles是一种用于高效地加载和显示大规模的3D地球数据的技术，可以将复杂的3D数据分层并进行高度优化。Cesium中的3D Tiles技术可以支持大规模的3D地球数据，包括城市、建筑、地形等，提高了数据的加载速度和显示效率。</p><h2 id="3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？"><a href="#3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？" class="headerlink" title="3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？"></a>3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？</h2><p>  答：CZML（Cesium Language）是一种描述和显示动态的地球场景的数据格式，它可以用于描述航班轨迹、气象数据、卫星运行轨迹等。CZML中可以包含实体的位置、速度、方向等信息，以及可视化效果的设置。</p><h2 id="4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。"><a href="#4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。" class="headerlink" title="4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。"></a>4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。</h2><p>  答：ImageryProvider是Cesium中的一个数据提供器，用于提供地图和影像数据。它可以从多种来源获取数据，比如Web Map Service（WMS）、Web Map Tile Service（WMTS）等，并在地球表面上显示出来。通过使用ImageryProvider，开发者可以轻松地获取并显示各种地图和影像数据。</p><h2 id="5、如何加载飞线"><a href="#5、如何加载飞线" class="headerlink" title="5、如何加载飞线"></a>5、如何加载飞线</h2><p>  答：1、创建polyLine实体</p><p>   2、计算带有弧度效果的点集数组作为polyline的positions属性参数</p><h2 id="6、如何设置飞线动效材质"><a href="#6、如何设置飞线动效材质" class="headerlink" title="6、如何设置飞线动效材质"></a>6、如何设置飞线动效材质</h2><p>答：1、创建cesium自定义材质类</p><p>2、创建shader，原理是通过贴图UV移动来实现流光效果</p><h2 id="7、如何在cesium地球上添加柱状图"><a href="#7、如何在cesium地球上添加柱状图" class="headerlink" title="7、如何在cesium地球上添加柱状图"></a>7、如何在cesium地球上添加柱状图</h2><p>答：1、创建entity实体，使用box属性；</p><p>2、dimensions设置长宽；</p><p>3、position设置中心点位置；</p><p>4、heightReference属性设置贴地属性；</p><h2 id="8、如何让柱状图跟随数据变化"><a href="#8、如何让柱状图跟随数据变化" class="headerlink" title="8、如何让柱状图跟随数据变化"></a>8、如何让柱状图跟随数据变化</h2><p>答：1、创建SampledPositionProperty对象</p><p>2、在不同的时间点绑定对应的值</p><p>  将填充好的SampledPositionProperty赋值给dimensions，实现位置随时间的偏移</p><h2 id="9、如何加载天气图的效果"><a href="#9、如何加载天气图的效果" class="headerlink" title="9、如何加载天气图的效果"></a>9、如何加载天气图的效果</h2><p>答：1、使用Wind3D类实现</p><p>实现原理是将nc格式的数据解析之后运用primitive绘制</p><p>​    2、Cesium官网有github的分享案例，需要修改鼠标事件影响该类绘制时的显示隐藏</p><h2 id="10、如何给cesium地球替换表面图层"><a href="#10、如何给cesium地球替换表面图层" class="headerlink" title="10、如何给cesium地球替换表面图层"></a>10、如何给cesium地球替换表面图层</h2><p>答：1、主要是在viewer的imageryLayers地图层级内对单独的layer图层的显示隐藏或者添加与移除，imageryLayers有add与remove方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、viewer.imageryLayers.addImageryProvider(layer, num);</span><br><span class="line">viewer.imageryLayers.remove(viewer.imageryLayers.get(num), true);</span><br></pre></td></tr></table></figure><p>主要是这两个API<br>    3、注意不同的地图图层加载会有对应的投影方式，比如web墨卡托投影和wgs84</p><h2 id="11、cesium如何进行坐标转换"><a href="#11、cesium如何进行坐标转换" class="headerlink" title="11、cesium如何进行坐标转换"></a>11、cesium如何进行坐标转换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">答：1、//经纬度转屏幕坐标</span><br><span class="line"></span><br><span class="line">LngLatToSceenCoordinates(lng, lat) &#123;</span><br><span class="line"></span><br><span class="line">let cartesian3 = Cesium.Cartesian3.fromDegrees(lng, lat);</span><br><span class="line"></span><br><span class="line">let cartesian2 = Cesium.SceneTransforms.wgs84ToWindowCoordinates(</span><br><span class="line"></span><br><span class="line">viewer.scene,</span><br><span class="line"></span><br><span class="line">cartesian3</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">return cartesian2;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">2、 //笛卡尔坐标转经纬度坐标</span><br><span class="line"></span><br><span class="line">Cartesian3ToLngLat(cartesian) &#123;</span><br><span class="line"></span><br><span class="line">let cartographic =</span><br><span class="line"></span><br><span class="line">viewer.scene.globe.ellipsoid.cartesianToCartographic(cartesian);</span><br><span class="line"></span><br><span class="line">let c_height = viewer.camera.positionCartographic.height;</span><br><span class="line"></span><br><span class="line">//将地图坐标（弧度）转为十进制的度数</span><br><span class="line"></span><br><span class="line">let lat_String = Cesium.Math.toDegrees(cartographic.latitude).toFixed(6);</span><br><span class="line"></span><br><span class="line">let log_String = Cesium.Math.toDegrees(cartographic.longitude).toFixed(6);</span><br><span class="line"></span><br><span class="line">return [</span><br><span class="line"></span><br><span class="line">parseFloat(log_String),</span><br><span class="line"></span><br><span class="line">parseFloat(lat_String),</span><br><span class="line"></span><br><span class="line">parseFloat(c_height),</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="12、cesium如何实现标记的添加"><a href="#12、cesium如何实现标记的添加" class="headerlink" title="12、cesium如何实现标记的添加"></a>12、cesium如何实现标记的添加</h2><p>  答：1、创建entity实体对象使用billboard对象场景图标挥着使用billboard collection使用primitive创建</p><h2 id="13、cesium如何实现鼠标拾取弹窗功能"><a href="#13、cesium如何实现鼠标拾取弹窗功能" class="headerlink" title="13、cesium如何实现鼠标拾取弹窗功能"></a>13、cesium如何实现鼠标拾取弹窗功能</h2><p>   答：1、创建new Cesium.ScreenSpaceEventHandler(canvas)对象</p><p> 2、注册鼠标点击事件<br>   3、使用let pick &#x3D; viewer.scene.pick(movement.position); 选取当前的entity</p><h2 id="14、如何设置cesium中的抗锯齿方法"><a href="#14、如何设置cesium中的抗锯齿方法" class="headerlink" title="14、如何设置cesium中的抗锯齿方法"></a>14、如何设置cesium中的抗锯齿方法</h2><p>  答：1、使用fxaa方法，效果较差</p><p>  2、使用msaa方法，但需要浏览器支持webGL2的api方法</p><p><img src="https://bcn.135editor.com/files/images/editor_styles/2b4dad3b5ce0324eb63cde4380e4cdfb.gif" alt="img"></p><p><img src="https://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9wbmcvdm5UNGhiYUxvWDZIWkQxZXFvRmljVXdwR3RPSklNamNzaWNNVVVZWDRvNHNNMGhQQ2RQRUtTV0pIYkdQb2MyVWJQaWNGVlNTM2ljU3hZRDdoOTdNUHYwSW9BLzA/d3hfZm10PXBuZw==" alt="img"></p><p><img src="https://bcn.135editor.com/files/images/editor_styles/8a370d08cb8dee16148088fd86f39e16.png" alt="img"></p><p><img src="https://bexp.135editor.com/files/users/498/4980660/202302/k5PHuh8T_I5qb.jpg?auth_key=1677427199-0-0-d90c72020ea7995dbf533d91bb976f8c" alt="qrcode_for_gh_e879ec750214_258.jpg"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/Cesium/">Cesium</category>
      
      
      <comments>https://jhcgnb.cn/posts/a98e3ede/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux项目部署详细步骤</title>
      <link>https://jhcgnb.cn/posts/d594835b/</link>
      <guid>https://jhcgnb.cn/posts/d594835b/</guid>
      <pubDate>Tue, 09 May 2023 11:08:33 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;安装部署&quot;&gt;&lt;a href=&quot;#安装部署&quot; class=&quot;headerlink&quot; title=&quot;安装部署&quot;&gt;&lt;/a&gt;安装部署&lt;/h1&gt;&lt;h2 id=&quot;一、环境准备&quot;&gt;&lt;a href=&quot;#一、环境准备&quot; class=&quot;headerlink&quot; title=&quot;一、环境准</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><p>说明：如果已经安装过相关工具就忽略</p><h3 id="1安装JAVA-运行环境"><a href="#1安装JAVA-运行环境" class="headerlink" title="1安装JAVA 运行环境"></a>1安装JAVA 运行环境</h3><p>第一步：上传或下载安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /usr/local</span><br></pre></td></tr></table></figure><p>jdk-8u152-linux-x64.tar.gz</p><p>第二步：解压安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u152-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>第三步：建立软连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/jdk1.8.0_152/  /usr/local/jdk </span><br></pre></td></tr></table></figure><p>第四步：修改环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/jdk</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过命令source /etc/profile让profile文件立即生效</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>第五步、测试是否安装成功</p><p>使用java -version，出现版本为java version “1.8.0_152”</p><h3 id="2安装maven"><a href="#2安装maven" class="headerlink" title="2安装maven"></a>2安装maven</h3><p>第一步：上传或下载安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /usr/local</span><br></pre></td></tr></table></figure><p>apache-maven-3.6.1-bin.tar.gz</p><p>第二步：解压安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar  -zxvf  apache-maven-3.6.1-bin.tar.gz</span><br></pre></td></tr></table></figure><p>第三步：建立软连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln  -s  /usr/local/apache-maven-3.6.1/  /usr/local/maven</span><br></pre></td></tr></table></figure><p>第四步：修改环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export MAVEN_HOME=/usr/local/maven</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过命令source /etc/profile让profile文件立即生效</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>第五步、测试是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn –v</span><br></pre></td></tr></table></figure><h3 id="3安装docker"><a href="#3安装docker" class="headerlink" title="3安装docker"></a>3安装docker</h3><p>环境安装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p>第一步：安装必要的一些系统工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2 </span><br></pre></td></tr></table></figure><p>第二步：添加软件源信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>第三步：更新并安装Docker-CE</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><p>第四步：开启Docker服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>第五步：测试是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -v </span><br></pre></td></tr></table></figure><p>第六步：配置镜像加速器</p><p>您可以通过修改daemon配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json来使用加速器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> &quot;registry-mirrors&quot;: [&quot;https://ldu6wrsf.mirror.aliyuncs.com&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="4安装mysql"><a href="#4安装mysql" class="headerlink" title="4安装mysql"></a>4安装mysql</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name mysql --restart=always -v /home/ljaer/mysql:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 </span><br></pre></td></tr></table></figure><p>第三步：测试mysql</p><p>进入容器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p>登录mysql：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>如果顺利进入，安装成功</p><h3 id="5安装rabbitmq"><a href="#5安装rabbitmq" class="headerlink" title="5安装rabbitmq"></a>5安装rabbitmq</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5672:5672 -p 15672:15672 --restart=always --name rabbitmq rabbitmq:management</span><br></pre></td></tr></table></figure><p>第三步：安装延迟队列插件</p><ol><li><p>首先下载rabbitmq_delayed_message_exchange-3.9.0.ez文件上传到RabbitMQ所在服务器，下载地址：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p></li><li><p>切换到插件所在目录，执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp rabbitmq_delayed_message_exchange-3.9.0.ez rabbitmq:/plugins </span><br></pre></td></tr></table></figure><p>命令，将刚插件拷贝到容器内plugins目录下</p></li><li><p>执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it rabbitmq /bin/bash </span><br></pre></td></tr></table></figure><p>命令进入到容器内部，并 cd plugins 进入plugins目录</p></li><li><p>执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l|grep delay</span><br></pre></td></tr></table></figure><p>  命令查看插件是否copy成功</p></li><li><p>在容器内plugins目录下，执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>  命令启用插件</p></li><li><p>exit命令退出RabbitMQ容器内部，然后执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart rabbitmq </span><br></pre></td></tr></table></figure><p>命令重启RabbitMQ容器</p></li></ol><h3 id="6安装redis"><a href="#6安装redis" class="headerlink" title="6安装redis"></a>6安装redis</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379  --restart=always redis:latest redis-server</span><br></pre></td></tr></table></figure><h3 id="7安装nacos"><a href="#7安装nacos" class="headerlink" title="7安装nacos"></a>7安装nacos</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nacos/nacos-server:1.4.1</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --env MODE=standalone --name nacos --restart=always -d -p 8848:8848 -e JVM_XMS=512m -e JVM_XMX=512m nacos/nacos-server:1.4.1</span><br></pre></td></tr></table></figure><h3 id="8安装sentinel"><a href="#8安装sentinel" class="headerlink" title="8安装sentinel"></a>8安装sentinel</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull bladex/sentinel-dashboard</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name sentinel-dashboard --restart=always -p 8858:8858 -d bladex/sentinel-dashboard:latest  </span><br></pre></td></tr></table></figure><h3 id="9安装elasticsearch"><a href="#9安装elasticsearch" class="headerlink" title="9安装elasticsearch"></a>9安装elasticsearch</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:7.8.0</span><br></pre></td></tr></table></figure><p>第二步：启动</p><p>需要建立：两个文件夹</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /mydata/elasticsearch/plugins</span><br><span class="line"></span><br><span class="line">mkdir -p /mydata/elasticsearch/data</span><br></pre></td></tr></table></figure><p>授予权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /mydata/elasticsearch/data</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 --name elasticsearch --restart=always \-e &quot;discovery.type=single-node&quot; \-e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; \-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \-d elasticsearch:7.8.0</span><br></pre></td></tr></table></figure><p>第三步：安装中文分词器</p><ol><li><p>下载elasticsearch-analysis-ik-7.8.0.zip</p></li><li><p>上传解压：unzip elasticsearch-analysis-ik-7.8.0.zip -d ik-analyzer</p></li><li><p>上传到es容器：docker cp .&#x2F;ik-analyzer a24eb9941759:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</p></li><li><p>重启es：docker restart a24eb9941759</p></li></ol><p>a24eb9941759：表示容器ID 运行时，需要改成自己的容器ID</p><h3 id="10-安装kibana"><a href="#10-安装kibana" class="headerlink" title="10 安装kibana"></a>10 安装kibana</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull kibana:7.8.0</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name kibana --restart=always -e ELASTICSEARCH_URL=http://192.168.112.165:9200 -p 5601:5601 -d kibana:7.8.0</span><br></pre></td></tr></table></figure><p>进入容器修改：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 1e12f8dd3efd /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd config</span><br><span class="line"></span><br><span class="line">vi kibana.yml</span><br><span class="line"></span><br><span class="line">elasticsearch.hosts: [ &quot;http://192.168.200.129:9200&quot; ]</span><br><span class="line"></span><br><span class="line">docker restart 1dc0f78d78ad 重启kibana ！</span><br></pre></td></tr></table></figure><p>测试：安装分词词库是否可以使用！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /.kibana/_analyze</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> &quot;text&quot;: &quot;我是中国人&quot;,</span><br><span class="line"></span><br><span class="line"> &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11安装zipkin"><a href="#11安装zipkin" class="headerlink" title="11安装zipkin"></a>11安装zipkin</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull openzipkin/zipkin</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name zipkin --restart=always -d -p 9411:9411 openzipkin/zipkin </span><br></pre></td></tr></table></figure><h3 id="12安装minio"><a href="#12安装minio" class="headerlink" title="12安装minio"></a>12安装minio</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run \ -p 9000:9000 \ -p 9001:9001 \ --name minio \ -d --restart=always \ -e &quot;MINIO_ROOT_USER=admin&quot; \ -e &quot;MINIO_ROOT_PASSWORD=admin123456&quot; \ -v /home/data:/data \ -v /home/config:/root/.minio \ minio/minio server /data --console-address &quot;:9001&quot;</span><br></pre></td></tr></table></figure><p>浏览器访问：<a href="http://ip:9000/minio/login%EF%BC%8C">http://IP:9000/minio/login，</a></p><h3 id="13-安装logstash"><a href="#13-安装logstash" class="headerlink" title="13 安装logstash"></a>13 安装logstash</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull logstash:7.8.0</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name logstash -p 5044:5044 --restart=always --link elasticsearch:es -v /mydata/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf -d logstash:7.8.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--net root_default \</span><br></pre></td></tr></table></figure><table><thead><tr><th># 需要提前在linux服务器上环境 &#x2F;mydata&#x2F;logstash&#x2F;logstash.conflogstash.confinput { tcp {mode &#x3D;&gt; “server”host &#x3D;&gt; “0.0.0.0”port &#x3D;&gt; 5044codec &#x3D;&gt; json_lines }}filter{ }output { elasticsearch {hosts &#x3D;&gt; “192.168.112.165:9200”index &#x3D;&gt; “gmall-%{+YYYY.MM.dd}” }}</th></tr></thead><tbody><tr><td></td></tr></tbody></table><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>停止所有的容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有的容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>#删除所有的镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p>问题：</p><p>Docker容器做端口映射报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint lamp3 (46b7917c940f7358948e55ec2df69a4dec2c6c7071b002bd374e8dbf0d40022c): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 86 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name.</span><br></pre></td></tr></table></figure><p>解决方法</p><p>docker服务启动时定义的自定义链DOCKER被清除</p><p>重启即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/Java/">Java</category>
      
      
      <comments>https://jhcgnb.cn/posts/d594835b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>多边形</title>
      <link>https://jhcgnb.cn/posts/undefined/</link>
      <guid>https://jhcgnb.cn/posts/undefined/</guid>
      <pubDate>Mon, 08 May 2023 13:28:12 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Voronoi-多边形&quot;&gt;&lt;a href=&quot;#Voronoi-多边形&quot; class=&quot;headerlink&quot; title=&quot;Voronoi 多边形&quot;&gt;&lt;/a&gt;Voronoi 多边形&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://rx6zk4j2b.hn-bkt.</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Voronoi-多边形"><a href="#Voronoi-多边形" class="headerlink" title="Voronoi 多边形"></a>Voronoi 多边形</h3><p><img src="http://rx6zk4j2b.hn-bkt.clouddn.com/blogs/image-20230708212920053.png" alt="image-20230708212920053"></p><p>Voronoi 多边形，也称为 Voronoi 图或 Voronoi 分割，是一种空间分析和几何计算方法，用于将平面或空间划分为不同区域，每个区域都与给定一组点最近邻。这些区域被称为 Voronoi 多边形或 Voronoi 区域，每个多边形由与其对应的点作为最近邻点。</p><p>Voronoi 多边形的生成过程基于以下原则：给定一组点，每个点的 Voronoi 区域包含所有离该点最近的点，并且这些点之间的边界形成多边形。Voronoi 多边形的边界由平分相邻点之间的直线或曲线段组成，这些直线或曲线段是两个点之间的等距离线，也称为 Voronoi 边。因此，Voronoi 多边形的边界是相邻点之间的中垂线。</p><p>Voronoi 多边形在各种领域中有广泛应用，包括计算机图形学、计算机视觉、地理信息系统（GIS）、模式识别等。以下是一些应用 Voronoi 多边形的示例：</p><ol><li><p>空间分析：Voronoi 多边形可用于将地理空间划分为不同的区域，每个区域都由最近邻点决定。这在地理学、城市规划和环境分析中具有重要作用，可以用于确定服务设施的服务范围、确定地理区域的边界等。</p></li><li><p>面积计算：通过计算 Voronoi 多边形的面积，可以了解每个点的影响范围或区域的大小。这在生态学、资源管理和人口统计学中很有用。</p></li><li><p>最近邻搜索：Voronoi 多边形可用于确定给定点的最近邻点。这在图像处理、模式识别和计算机视觉中经常使用，例如图像中的特征匹配、对象识别等。</p></li><li><p>网格生成：Voronoi 多边形可以用作生成网格的方法之一。通过将点集表示为 Voronoi 图，可以生成规则且适应性良好的网格，这在数值计算和有限元分析中很有用。</p></li></ol><p>总之，Voronoi 多边形是一种强大的几何计算工具，可用于空间分析、最近邻搜索、面积计算和网格生成等应用领域。它提供了一种有效的方法来划分空间并了解点之间的关系，为许多问题的解决提供了有力支持。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E5%AD%A6%E6%9C%AF/">学术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <comments>https://jhcgnb.cn/posts/undefined/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSS3</title>
      <link>https://jhcgnb.cn/posts/undefined/</link>
      <guid>https://jhcgnb.cn/posts/undefined/</guid>
      <pubDate>Thu, 27 Apr 2023 13:39:41 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;HTML5-CSS3&quot;&gt;&lt;a href=&quot;#HTML5-CSS3&quot; class=&quot;headerlink&quot; title=&quot;HTML5 CSS3&quot;&gt;&lt;/a&gt;HTML5 CSS3&lt;/h1&gt;&lt;h2 id=&quot;1-CSS3有哪些新特性？&quot;&gt;&lt;a href=&quot;#1-CSS3有哪</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="HTML5-CSS3"><a href="#HTML5-CSS3" class="headerlink" title="HTML5 CSS3"></a>HTML5 CSS3</h1><h2 id="1-CSS3有哪些新特性？"><a href="#1-CSS3有哪些新特性？" class="headerlink" title="1.CSS3有哪些新特性？"></a>1.CSS3有哪些新特性？</h2><ol><li>CSS3实现圆角（border-radius），阴影（box-shadow），</li><li>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</li><li>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);&#x2F;&#x2F; 旋转,缩放,定位,倾斜</li><li>增加了更多的CSS选择器  多背景 rgba</li><li>在CSS3中唯一引入的伪元素是 ::selection.</li><li>媒体查询，多栏布局</li><li>border-image</li></ol><h2 id="2-html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#2-html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="2.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>2.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><p>新特性：</p><ol><li>拖拽释放(Drag and drop) API</li><li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li><li>音频、视频API(audio,video)</li><li>画布(Canvas) API</li><li>地理(Geolocation) API</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>表单控件，calendar、date、time、email、url、search</li><li>新的技术webworker, websocket, Geolocation<br>移除的元素：</li><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；<br>支持HTML5新标签：</li><li>IE8&#x2F;IE7&#x2F;IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架）：<!--[if lt IE 9]></li></ol><script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script><p>&lt;![endif]–&gt;<br>如何区分：<br>DOCTYPE声明新增的结构元素、功能元素</p><h2 id="3-本地存储（Local-Storage-）和cookies（储存在用户本地终端上的数据）之间的区别是什么？"><a href="#3-本地存储（Local-Storage-）和cookies（储存在用户本地终端上的数据）之间的区别是什么？" class="headerlink" title="3.本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？"></a>3.本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？</h2><p>Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；<br>本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除</p><h2 id="4-如何实现浏览器内多个标签页之间的通信"><a href="#4-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="4.如何实现浏览器内多个标签页之间的通信?"></a>4.如何实现浏览器内多个标签页之间的通信?</h2><p>调用 localstorge、cookies 等本地存储方式</p><h2 id="5-你如何对网站的文件和资源进行优化？"><a href="#5-你如何对网站的文件和资源进行优化？" class="headerlink" title="5.你如何对网站的文件和资源进行优化？"></a>5.你如何对网站的文件和资源进行优化？</h2><p>文件合并<br>文件最小化&#x2F;文件压缩<br>使用CDN托管<br>缓存的使用</p><h2 id="6-什么是响应式设计？"><a href="#6-什么是响应式设计？" class="headerlink" title="6.什么是响应式设计？"></a>6.什么是响应式设计？</h2><p>它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常</p><h2 id="7-新的-HTML5-文档类型和字符集是？"><a href="#7-新的-HTML5-文档类型和字符集是？" class="headerlink" title="7.新的 HTML5 文档类型和字符集是？"></a>7.新的 HTML5 文档类型和字符集是？</h2><p>答：HTML5文档类型：<!doctype html><br>HTML5使用的编码<meta charset="UTF-8"></p><h2 id="8-HTML5-Canvas-元素有什么用？"><a href="#8-HTML5-Canvas-元素有什么用？" class="headerlink" title="8.HTML5 Canvas 元素有什么用？"></a>8.HTML5 Canvas 元素有什么用？</h2><p>答：Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。</p><h2 id="9-HTML5-存储类型有什么区别？"><a href="#9-HTML5-存储类型有什么区别？" class="headerlink" title="9.HTML5 存储类型有什么区别？"></a>9.HTML5 存储类型有什么区别？</h2><p>答：Media API、Text Track API、Application Cache API、User Interaction、Data Transfer API、Command API、Constraint Validation API、History API</p><h2 id="10用H5-CSS3解决下导航栏最后一项掉下来的问题"><a href="#10用H5-CSS3解决下导航栏最后一项掉下来的问题" class="headerlink" title="10用H5+CSS3解决下导航栏最后一项掉下来的问题"></a>10用H5+CSS3解决下导航栏最后一项掉下来的问题</h2><h2 id="11-CSS3新增伪类有那些？"><a href="#11-CSS3新增伪类有那些？" class="headerlink" title="11.CSS3新增伪类有那些？"></a>11.CSS3新增伪类有那些？</h2><pre><code>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:enabled、:disabled 控制表单控件的禁用状态。</code></pre><p>:checked，单选框或复选框被选中。</p><h2 id="12-请用CSS实现：一个矩形内容，有投影，有圆角，hover状态慢慢变透明。"><a href="#12-请用CSS实现：一个矩形内容，有投影，有圆角，hover状态慢慢变透明。" class="headerlink" title="12.请用CSS实现：一个矩形内容，有投影，有圆角，hover状态慢慢变透明。"></a>12.请用CSS实现：一个矩形内容，有投影，有圆角，hover状态慢慢变透明。</h2><p>css属性的熟练程度和实践经验</p><h2 id="13-描述下CSS3里实现元素动画的方法"><a href="#13-描述下CSS3里实现元素动画的方法" class="headerlink" title="13.描述下CSS3里实现元素动画的方法"></a>13.描述下CSS3里实现元素动画的方法</h2><p>动画相关属性的熟悉程度</p><h2 id="14-html5-CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#14-html5-CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="14.html5\CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>14.html5\CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，地理定位等功能的增加。</p><ul><li>绘画 canvas 元素<br>用于媒介回放的 video 和 audio 元素<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除<br>语意化更好的内容元素，比如 article、footer、header、nav、section<br>表单控件，calendar、date、time、email、url、search<br>CSS3实现圆角，阴影，对文字加特效，增加了更多的CSS选择器  多背景 rgba<br>新的技术webworker, websockt, Geolocation<br>移除的元素<br>纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>对可用性产生负面影响的元素：frame，frameset，noframes；</li><li>是IE8&#x2F;IE7&#x2F;IE6支持通过document.createElement方法产生的标签，<br>可以利用这一特性让这些浏览器支持HTML5新标签，<br>浏览器支持新标签后，还需要添加标签默认的样式：</li><li>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架<!--[if lt IE 9]></li></ul><script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script><p>&lt;![endif]–&gt;</p><h2 id="15-你怎么来实现页面设计图，你认为前端应该如何高质量完成工作-一个满屏-品-字布局-如何设计"><a href="#15-你怎么来实现页面设计图，你认为前端应该如何高质量完成工作-一个满屏-品-字布局-如何设计" class="headerlink" title="15.你怎么来实现页面设计图，你认为前端应该如何高质量完成工作? 一个满屏 品 字布局 如何设计?"></a>15.你怎么来实现页面设计图，你认为前端应该如何高质量完成工作? 一个满屏 品 字布局 如何设计?</h2><ul><li>首先划分成头部、body、脚部；。。。。。</li><li>实现效果图是最基本的工作，精确到2px；<br>与设计师，产品经理的沟通和项目的参与<br>做好的页面结构，页面重构和用户体验<br>处理hack，兼容、写出优美的代码格式<br>针对服务器的优化、拥抱 HTML5。</li></ul><h2 id="16-你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#16-你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="16.你能描述一下渐进增强和优雅降级之间的不同吗?"></a>16.你能描述一下渐进增强和优雅降级之间的不同吗?</h2><p>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。<br>优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。<br>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。<br>“优雅降级”观点<br>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。<br>在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。<br>“渐进增强”观点<br>“渐进增强”观点则认为应关注于内容本身。<br>内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p><p>那么问题了。现在产品经理看到IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），你会如何说服他？</p><h2 id="17-为什么利用多个域名来存储网站资源会更有效？"><a href="#17-为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="17.为什么利用多个域名来存储网站资源会更有效？"></a>17.为什么利用多个域名来存储网站资源会更有效？</h2><p>CDN缓存更方便<br>突破浏览器并发限制<br>节约cookie带宽<br>节约主域名的连接数，优化页面响应速度<br>防止不必要的安全问题</p><h2 id="18-请谈一下你对网页标准和标准制定机构重要性的理解。"><a href="#18-请谈一下你对网页标准和标准制定机构重要性的理解。" class="headerlink" title="18.请谈一下你对网页标准和标准制定机构重要性的理解。"></a>18.请谈一下你对网页标准和标准制定机构重要性的理解。</h2><p>（无标准答案）网页标准和标准制定机构都是为了能让web发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。</p><h2 id="19-请描述一下cookies，sessionStorage和localStorage的区别？"><a href="#19-请描述一下cookies，sessionStorage和localStorage的区别？" class="headerlink" title="19.请描述一下cookies，sessionStorage和localStorage的区别？"></a>19.请描述一下cookies，sessionStorage和localStorage的区别？</h2><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。<br>web storage和cookie的区别<br>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。<br>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p><h2 id="20-知道css有个content属性吗？有什么作用？有什么应用？"><a href="#20-知道css有个content属性吗？有什么作用？有什么应用？" class="headerlink" title="20.知道css有个content属性吗？有什么作用？有什么应用？"></a>20.知道css有个content属性吗？有什么作用？有什么应用？</h2><p>知道。css的content属性专门应用在 before&#x2F;after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。<br>&#x2F;&#x2F;一种常见利用伪类清除浮动的代码</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;.&quot;</span>; //这里利用到了<span class="attribute">content</span>属性</span><br><span class="line">    <span class="attribute">display</span>:block; </span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden; </span><br><span class="line">    <span class="attribute">clear</span>:both; &#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123; </span><br><span class="line">    *zoom:<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>after伪元素通过 content 在元素的后面生成了内容为一个点的块级素，再利用clear:both清除浮动。<br>那么问题继续还有，知道css计数器（序列数字字符自动递增）吗？如何通过css content属性实现css计数器？<br>答案：css计数器是通过设置counter-reset 、counter-increment 两个属性 、及 counter()&#x2F;counters()一个方法配合after &#x2F; before 伪类实现。</p><h2 id="21-如何在-HTML5-页面中嵌入音频"><a href="#21-如何在-HTML5-页面中嵌入音频" class="headerlink" title="21.如何在 HTML5 页面中嵌入音频?"></a>21.如何在 HTML5 页面中嵌入音频?</h2><p>HTML 5 包含嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg：</p><audio controls>   <source src="jamshed.mp3" type="audio/mpeg">    Your browser does'nt support audio embedding feature. </audio><h2 id="22-如何在-HTML5-页面中嵌入视频？"><a href="#22-如何在-HTML5-页面中嵌入视频？" class="headerlink" title="22.如何在 HTML5 页面中嵌入视频？"></a>22.如何在 HTML5 页面中嵌入视频？</h2><p>和音频一样，HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg：</p><video width="450" height="340" controls>   <source src="jamshed.mp4" type="video/mp4">    Your browser does'nt support video embedding feature. </video> <h2 id="23HTML5-引入什么新的表单属性？"><a href="#23HTML5-引入什么新的表单属性？" class="headerlink" title="23HTML5 引入什么新的表单属性？"></a>23HTML5 引入什么新的表单属性？</h2><p>Datalist   datetime   output   keygen  date  month  week  time  number   range   emailurl</p><h2 id="24-CSS3新增伪类有那些？"><a href="#24-CSS3新增伪类有那些？" class="headerlink" title="24.CSS3新增伪类有那些？"></a>24.CSS3新增伪类有那些？</h2><p>p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。<br>p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。<br>p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。<br>p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。<br>p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。<br>:enabled、:disabled 控制表单控件的禁用状态。<br>:checked，单选框或复选框被选中。</p><h2 id="25-写-描述一段语义的html代码吧。"><a href="#25-写-描述一段语义的html代码吧。" class="headerlink" title="25.(写)描述一段语义的html代码吧。"></a>25.(写)描述一段语义的html代码吧。</h2><p>（HTML5中新增加的很多标签（如：<article>、<nav>、<header>和<footer>等）<br>就是基于语义化设计原则）<br>&lt; div id&#x3D;”header”&gt;<br>&lt; h1&gt;标题&lt; &#x2F;h1&gt;<br>&lt; h2&gt;专注Web前端技术&lt; &#x2F;h2&gt;<br>&lt; &#x2F;div&gt;<br>语义 HTML 具有以下特性：</p><p>文字包裹在元素中，用以反映内容。例如：<br>段落包含在 <p> 元素中。<br>顺序表包含在<ol>元素中。<br>从其他来源引用的大型文字块包含在<blockquote>元素中。<br>HTML 元素不能用作语义用途以外的其他目的。例如：</p><h1>包含标题，但并非用于放大文本。<blockquote>包含大段引述，但并非用于文本缩进。空白段落元素 ( <p></p> ) 并非用于跳行。文本并不直接包含任何样式信息。例如：不使用 <font> 或 <center> 等格式标记。类或 ID 中不引用颜色或位置。<h2 id="26-cookie在浏览器和服务器间来回传递。-sessionStorage和localStorage区别"><a href="#26-cookie在浏览器和服务器间来回传递。-sessionStorage和localStorage区别" class="headerlink" title="26.cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage区别"></a>26.cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage区别</h2><p>sessionStorage和localStorage的存储空间更大；<br>sessionStorage和localStorage有更多丰富易用的接口；<br>sessionStorage和localStorage各自独立的存储空间；</p><h2 id="27-html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#27-html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="27.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>27.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><ul><li>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</li><li>绘画 canvas<br>用于媒介回放的 video 和 audio 元素<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除<br>语意化更好的内容元素，比如 article、footer、header、nav、section<br>表单控件，calendar、date、time、email、url、search<br>新的技术webworker, websockt, Geolocation</li><li>移除的元素<br>纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>对可用性产生负面影响的元素：frame，frameset，noframes；<br>支持HTML5新标签：</li><li>IE8&#x2F;IE7&#x2F;IE6支持通过document.createElement方法产生的标签，<br>可以利用这一特性让这些浏览器支持HTML5新标签，<br>浏览器支持新标签后，还需要添加标签默认的样式：</li><li>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架<!--[if lt IE 9]></li></ul><script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script><p>&lt;![endif]–&gt;</p><h2 id="28-如何区分：-DOCTYPE声明-新增的结构元素-功能元素"><a href="#28-如何区分：-DOCTYPE声明-新增的结构元素-功能元素" class="headerlink" title="28.如何区分： DOCTYPE声明\新增的结构元素\功能元素"></a>28.如何区分： DOCTYPE声明\新增的结构元素\功能元素</h2><h2 id="29-语义化的理解？"><a href="#29-语义化的理解？" class="headerlink" title="29.语义化的理解？"></a>29.语义化的理解？</h2><p>用正确的标签做正确的事情！<br>html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；<br>在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。<br>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p><h2 id="30-HTML5的离线储存？"><a href="#30-HTML5的离线储存？" class="headerlink" title="30.HTML5的离线储存？"></a>30.HTML5的离线储存？</h2><p>localStorage    长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage  数据在浏览器关闭后自动删除。</p><h2 id="31-写出HTML5的文档声明方式"><a href="#31-写出HTML5的文档声明方式" class="headerlink" title="31.写出HTML5的文档声明方式"></a>31.写出HTML5的文档声明方式</h2><pre><code> &lt;DOCYPE html&gt;</code></pre><h2 id="32-HTML5和CSS3的新标签"><a href="#32-HTML5和CSS3的新标签" class="headerlink" title="32.HTML5和CSS3的新标签"></a>32.HTML5和CSS3的新标签</h2><pre><code>HTML5： nav, footer, header, section, hgroup, video, time, canvas, audio...</code></pre><p>CSS3: RGBA, opacity, text-shadow, box-shadow, border-radius, border-image,<br>border-color, transform…;</p><h2 id="33-自己对标签语义化的理解"><a href="#33-自己对标签语义化的理解" class="headerlink" title="33.自己对标签语义化的理解"></a>33.自己对标签语义化的理解</h2><pre><code>在我看来，语义化就是比如说一个段落， 那么我们就应该用 &lt;p&gt;标签来修饰，标题就应该用 &lt;h?&gt;标签等。符合文档语义的标签。</code></pre>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/undefined/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2.JS基础</title>
      <link>https://jhcgnb.cn/posts/fec612ee/</link>
      <guid>https://jhcgnb.cn/posts/fec612ee/</guid>
      <pubDate>Wed, 26 Apr 2023 13:36:48 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;JS基础知识&quot;&gt;&lt;a href=&quot;#JS基础知识&quot; class=&quot;headerlink&quot; title=&quot;JS基础知识&quot;&gt;&lt;/a&gt;JS基础知识&lt;/h1&gt;&lt;h2 id=&quot;1-javascript的typeof返回哪些数据类型&quot;&gt;&lt;a href=&quot;#1-javascri</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="JS基础知识"><a href="#JS基础知识" class="headerlink" title="JS基础知识"></a>JS基础知识</h1><h2 id="1-javascript的typeof返回哪些数据类型"><a href="#1-javascript的typeof返回哪些数据类型" class="headerlink" title="1.javascript的typeof返回哪些数据类型"></a>1.javascript的typeof返回哪些数据类型</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="title function_">alert</span>(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">//object</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="string">&#x27;leipeng&#x27;</span>); <span class="comment">//string</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="literal">true</span>; </span><br><span class="line">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> i); <span class="comment">//boolean</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="number">1</span>); <span class="comment">//number</span></span><br><span class="line">    <span class="keyword">var</span> a; </span><br><span class="line">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> a); <span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;;&#125;;</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> a) <span class="comment">//function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">isNaN</span>  <span class="keyword">function</span></span><br><span class="line">检测数组的几种方式：</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr);   es5</span><br><span class="line"><span class="title class_">Object</span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) === ‘object <span class="title class_">Array</span>’</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br><span class="line">arr.<span class="property">constructor</span> === <span class="title class_">Array</span></span><br></pre></td></tr></table></figure><h2 id="2-例举3种强制类型转换和2种隐式类型转换"><a href="#2-例举3种强制类型转换和2种隐式类型转换" class="headerlink" title="2.例举3种强制类型转换和2种隐式类型转换?"></a>2.例举3种强制类型转换和2种隐式类型转换?</h2><p>强制（parseInt(),parseFloat(),Number()）<br>隐式（&#x3D;&#x3D; ,!!）</p><h2 id="3-split-、join-的区别"><a href="#3-split-、join-的区别" class="headerlink" title="3.split() 、join() 的区别"></a>3.split() 、join() 的区别</h2><p>前者是切割成数组的形式，后者是将数组转换成字符串</p><h2 id="4-数组方法pop-push-unshift-shift"><a href="#4-数组方法pop-push-unshift-shift" class="headerlink" title="4.数组方法pop() push() unshift() shift()"></a>4.数组方法pop() push() unshift() shift()</h2><p>Push()尾部添加 pop()尾部删除<br>Unshift()头部添加 shift()头部删除</p><h2 id="5-事件绑定和普通事件有什么区别"><a href="#5-事件绑定和普通事件有什么区别" class="headerlink" title="5.事件绑定和普通事件有什么区别"></a>5.事件绑定和普通事件有什么区别</h2><p>普通添加事件的方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">执行上面的代码只会alert <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">事件绑定方式添加事件：</span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">执行上面的代码会先alert <span class="number">1</span> 再 alert <span class="number">2</span></span><br><span class="line"><span class="number">1.</span>普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，而事件绑定（addEventListener）方式添加事件可以添加多个。</span><br><span class="line"><span class="number">2.</span>普通事件绑定不支持<span class="variable constant_">DOM</span>事件流，事件捕获-目标元素-事件冒泡（可以把事件绑定在不同的阶段去执行）</span><br><span class="line"><span class="number">3.</span>addEventListener不兼容低版本<span class="variable constant_">IE</span>，第三个参数默认为<span class="literal">false</span>，表示在事件冒泡阶段执行</span><br><span class="line">普通事件无法取消；第三个参数为<span class="literal">true</span>的时候表示在事件捕获的阶段执行；不需要on前缀；</span><br><span class="line">addEventLisntener还支持事件冒泡+事件捕获；</span><br><span class="line"><span class="number">4.</span>addEventLisntener同一个元素绑定完全相同的事件并不会覆盖掉前面的事件</span><br><span class="line"><span class="number">5.</span>attachEvent只支持事件冒泡，不支持事件捕获。</span><br></pre></td></tr></table></figure><h2 id="6-IE和DOM事件流的区别"><a href="#6-IE和DOM事件流的区别" class="headerlink" title="6.IE和DOM事件流的区别"></a>6.IE和DOM事件流的区别</h2><p>1.执行顺序不一样、<br>2.参数不一样<br>3.事件加不加on<br>4.this指向问题</p><h2 id="7-IE和标准下有哪些兼容性的写法"><a href="#7-IE和标准下有哪些兼容性的写法" class="headerlink" title="7.IE和标准下有哪些兼容性的写法"></a>7.IE和标准下有哪些兼容性的写法</h2><p>Var ev &#x3D; ev || window.event；   &#x2F;&#x2F; 获取触发事件对象<br>Var target &#x3D; ev.srcElement||ev.target  &#x2F;&#x2F; 获取触发事件的源对象<br>document.documentElement.clientWidth || document.body.clientWidth</p><h2 id="8-call和apply的区别"><a href="#8-call和apply的区别" class="headerlink" title="8.call和apply的区别"></a>8.call和apply的区别</h2><p>call方法:<br>语法：call(thisObj，Object1,Object2…)<br>定义：调用一个对象的一个方法，以另一个对象替换当前对象。<br>说明：<br>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。<br>如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</p><p>apply方法：<br>语法：apply(thisObj，[argArray])<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象。<br>说明：<br>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p><h2 id="9-b继承a的方法"><a href="#9-b继承a的方法" class="headerlink" title="9.b继承a的方法"></a>9.b继承a的方法</h2><p>原型链继承<br>借用构造函数继承<br>原型+构造函数组合继承<br>寄生式继承</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"> age, name </span>)&#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;父级方法&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params">age,name,job</span>)&#123; </span><br><span class="line">  A.<span class="title function_">apply</span>( <span class="variable language_">this</span>, <span class="variable language_">arguments</span> ); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">A</span>(<span class="number">14</span>,<span class="string">&#x27;侠客行&#x27;</span>); </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">B</span>(<span class="number">15</span>,<span class="string">&#x27;狼侠&#x27;</span>,<span class="string">&#x27;侠客&#x27;</span>); </span><br></pre></td></tr></table></figure><h2 id="10-如何阻止事件冒泡和默认事件"><a href="#10-如何阻止事件冒泡和默认事件" class="headerlink" title="10.如何阻止事件冒泡和默认事件"></a>10.如何阻止事件冒泡和默认事件</h2><p>canceBubble()只支持IE,return false,stopPropagation()</p><h2 id="11-JS创建对象的几种方式？"><a href="#11-JS创建对象的几种方式？" class="headerlink" title="11.JS创建对象的几种方式？"></a>11.JS创建对象的几种方式？</h2><p>对象字面量 &#x2F; Object构造函数<br>构造函数<br>纯构造函数<br>空构造函数 + 原型<br>混合构造函数 + 原型<br>动态原型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态原型的使用</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, work</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JS中通过if条件动态给一个对象添加属性或者方法的过程就是动态原型</span></span><br><span class="line">        <span class="keyword">if</span> (work) &#123;</span><br><span class="line">            <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">working</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我的工作是：&#x27;</span>, work);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">寄生构造函数</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>()</span><br></pre></td></tr></table></figure><h2 id="12-this指针，闭包，作用域"><a href="#12-this指针，闭包，作用域" class="headerlink" title="12.this指针，闭包，作用域"></a>12.this指针，闭包，作用域</h2><p>闭包： 收敛权限，避免变量全局污染；可以实现模块化（jQuery）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立即执行函数</span></span><br><span class="line">    <span class="keyword">var</span> common = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&#x27;common module&#x27;</span>;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">initPage</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向外暴露一个对象</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            initpage : initPage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    common.<span class="title function_">initpage</span>();</span><br><span class="line"><span class="comment">// 使用闭包函数实现点击弹出真实索引</span></span><br><span class="line">    <span class="keyword">var</span> lis = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">            lis[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(i);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="13-添加-删除-替换-插入到某个接点的方法"><a href="#13-添加-删除-替换-插入到某个接点的方法" class="headerlink" title="13.添加 删除 替换 插入到某个接点的方法"></a>13.添加 删除 替换 插入到某个接点的方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.<span class="title function_">appendChid</span>()</span><br><span class="line">obj.<span class="title function_">insertBefore</span>()</span><br><span class="line">obj.<span class="title function_">replaceChild</span>()</span><br><span class="line">obj.<span class="title function_">removeChild</span>()</span><br></pre></td></tr></table></figure><h2 id="14-javascript的本地对象，内置对象和宿主对象"><a href="#14-javascript的本地对象，内置对象和宿主对象" class="headerlink" title="14.javascript的本地对象，内置对象和宿主对象"></a>14.javascript的本地对象，内置对象和宿主对象</h2><p>本地对象为array obj regexp等可以new实例化<br>内置对象为gload Math 等不可以实例化的<br>宿主对象为浏览器自带的document,window 等</p><h2 id="15-window-onload-和document-ready的区别"><a href="#15-window-onload-和document-ready的区别" class="headerlink" title="15.window.onload 和document ready的区别"></a>15.window.onload 和document ready的区别</h2><p>window.onload 是在dom文档树加载完和所有文件加载完之后执行一个函数Document.ready原生种没有这个方法，jquery中有 $().ready(function),在dom文档树加载完之后执行一个函数（注意，这里面的文档树加载完不代表全部文件加载完）。<br>$(document).ready要比window.onload先执行<br>window.onload只能出来一次，$(document).ready可以出现多次</p><h2 id="16-”-”和“-”的不同"><a href="#16-”-”和“-”的不同" class="headerlink" title="16.”&#x3D;&#x3D;”和“&#x3D;&#x3D;&#x3D;”的不同"></a>16.”&#x3D;&#x3D;”和“&#x3D;&#x3D;&#x3D;”的不同</h2><p>前者会自动转换类型<br>后者不会</p><h2 id="17-javascript的同源策略"><a href="#17-javascript的同源策略" class="headerlink" title="17.javascript的同源策略"></a>17.javascript的同源策略</h2><p>一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、议和端口号的组合。<br>Ajax跨域的实现，JSONP的底层实现原理，如何解决跨域请求</p><h2 id="18-JavaScript是一门什么样的语言，它有哪些特点？"><a href="#18-JavaScript是一门什么样的语言，它有哪些特点？" class="headerlink" title="18.JavaScript是一门什么样的语言，它有哪些特点？"></a>18.JavaScript是一门什么样的语言，它有哪些特点？</h2><p>没有标准答案。<br>javaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。JavaScript兼容于ECMA标准，因此也称为ECMAScript。<br>基本特点<br>1．是一种解释性脚本语言（代码不进行预编译）。<br>2．主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。<br>3．可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。<br>4．跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行（如Windows、Linux、Mac、Android、iOS等）。</p><h2 id="19-JavaScript的数据类型都有什么？"><a href="#19-JavaScript的数据类型都有什么？" class="headerlink" title="19.JavaScript的数据类型都有什么？"></a>19.JavaScript的数据类型都有什么？</h2><p>基本数据类型：String,boolean,Number,Undefined, Null<br>引用数据类型：Object(Array,Date,RegExp,Function)<br>那么问题来了，如何判断某变量是否为数组数据类型？<br>方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效<br>方法二.obj instanceof Array 在某些IE版本中不正确<br>方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="title class_">Array</span>.<span class="property">isArray</span>===<span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="property">isArray</span> = <span class="keyword">function</span>(<span class="params">arg</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arg)===<span class="string">&quot;[object Array]&quot;</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？-不使用第三方框架"><a href="#20-已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？-不使用第三方框架" class="headerlink" title="20.已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)"></a>20.已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)</h2><pre><code>document.getElementById(“ID”).value</code></pre><h2 id="21-希望获取到页面中所有的checkbox怎么做？-不使用第三方框架"><a href="#21-希望获取到页面中所有的checkbox怎么做？-不使用第三方框架" class="headerlink" title="21.希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)"></a>21.希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> domList = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(‘input’)</span><br><span class="line"><span class="keyword">var</span> checkBoxList = [];</span><br><span class="line"><span class="keyword">var</span> len = domList.<span class="property">length</span>;　　<span class="comment">//缓存到局部变量</span></span><br><span class="line"><span class="keyword">while</span> (len--) &#123;　　<span class="comment">//使用while的效率会比for循环更高</span></span><br><span class="line">　　<span class="keyword">if</span> (domList[len].<span class="property">type</span> == ‘checkbox’) &#123;</span><br><span class="line">    　　checkBoxList.<span class="title function_">push</span>(domList[len]);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色-不使用第三方框架"><a href="#22-设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色-不使用第三方框架" class="headerlink" title="22.设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)"></a>22.设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(“<span class="variable constant_">ID</span>”);</span><br><span class="line">dom.<span class="property">innerHTML</span> = “xxxx”</span><br><span class="line">dom.<span class="property">style</span>.<span class="property">color</span> = “#<span class="number">000</span>”</span><br></pre></td></tr></table></figure><h2 id="23-当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？"><a href="#23-当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？" class="headerlink" title="23.当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？"></a>23.当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？</h2><p>直接在DOM里绑定事件：<div onclick="test()"></div><br>在JS里通过onclick绑定：xxx.onclick &#x3D; test<br>通过事件添加进行绑定：addEventListener(xxx, ‘click’, test)<br>那么问题来了，Javascript的事件流模型都有什么？<br>“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播<br>“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的<br>“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡</p><h2 id="24-看下列代码输出为何？解释原因。"><a href="#24-看下列代码输出为何？解释原因。" class="headerlink" title="24.看下列代码输出为何？解释原因。"></a>24.看下列代码输出为何？解释原因。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> a); <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">alert</span>(b); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>解释：Undefined是一个只有一个值的数据类型，这个值就是“undefined”，在使用var声明变量但并未对其赋值进行初始化时，这个变量的值就是undefined。而b由于未声明将报错。注意未申明的变量和声明了未赋值的是不一样的。</p><h2 id="25-看下列代码-输出什么？解释原因。"><a href="#25-看下列代码-输出什么？解释原因。" class="headerlink" title="25.看下列代码,输出什么？解释原因。"></a>25.看下列代码,输出什么？解释原因。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> a); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><p>解释：null是一个只有一个值的数据类型，这个值就是null。表示一个空指针对象，所以用typeof检测会返回”object”。</p><h2 id="26-看下列代码-输出什么？解释原因。"><a href="#26-看下列代码-输出什么？解释原因。" class="headerlink" title="26.看下列代码,输出什么？解释原因。"></a>26.看下列代码,输出什么？解释原因。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>;   <span class="comment">// true</span></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>;  <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span>;     <span class="comment">// true</span></span><br><span class="line"><span class="title class_">NaN</span> == <span class="title class_">NaN</span>;  <span class="comment">// false</span></span><br><span class="line">[] == <span class="literal">false</span>; <span class="comment">// true</span></span><br><span class="line">[] == ![];   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>•undefined与null相等，但不恒等（&#x3D;&#x3D;&#x3D;）<br>一个是number一个是string时，会尝试将string转换为number<br>尝试将boolean转换为number，0或1<br>尝试将Object转换成number或string，取决于另外一个对比量的类型<br>所以，对于0、空字符串的判断，建议使用 “&#x3D;&#x3D;&#x3D;” 。“&#x3D;&#x3D;&#x3D;”会先判断两边的值类型，类型不匹配时为false。<br>那么问题来了，看下面的代码，输出什么，foo的值为什么？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;11&quot;</span>+<span class="number">2</span>-<span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo);   <span class="comment">// number</span></span><br></pre></td></tr></table></figure><p>执行完后foo的值为111，foo的类型为number。</p><h2 id="27-看代码给答案。"><a href="#27-看代码给答案。" class="headerlink" title="27.看代码给答案。"></a>27.看代码给答案。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">a.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line">b = a;</span><br><span class="line">b.<span class="property">value</span> = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">alert</span>(a.<span class="property">value</span>);</span><br></pre></td></tr></table></figure><p>答案：2（考察引用数据类型细节）</p><h2 id="28-已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”。"><a href="#28-已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”。" class="headerlink" title="28. 已知数组var stringArray &#x3D; [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”。"></a>28. 已知数组var stringArray &#x3D; [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”。</h2><p>答案：alert(stringArray.join(“ ”))&#x2F;&#x2F; 注意中间的空格</p><h2 id="29-已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”。"><a href="#29-已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”。" class="headerlink" title="29.已知有字符串foo&#x3D;”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。"></a>29.已知有字符串foo&#x3D;”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">combo</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> arr=msg.<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        arr[i]=arr[i].<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>()+arr[i].<span class="title function_">substr</span>(<span class="number">1</span>,arr[i].<span class="property">length</span>-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg=arr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-var-numberArray-3-6-2-4-1-5-（考察基础API）"><a href="#30-var-numberArray-3-6-2-4-1-5-（考察基础API）" class="headerlink" title="30.var numberArray &#x3D; [3,6,2,4,1,5]; （考察基础API）"></a>30.var numberArray &#x3D; [3,6,2,4,1,5]; （考察基础API）</h2><ol><li>实现对该数组的倒排，输出[5,1,4,2,6,3]<br>numberArray.reverse()</li><li>实现对该数组的降序排列，输出[6,5,4,3,2,1]<br>numberArray.sort(function(a,b){return b-a})</li></ol><h2 id="31-输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26"><a href="#31-输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26" class="headerlink" title="31.输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26"></a>31.输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 获取年，getFullYear()返回4位的数字</span></span><br><span class="line"><span class="keyword">var</span> year = d.<span class="title function_">getFullYear</span>();</span><br><span class="line"><span class="comment">// 获取月，月份比较特殊，0是1月，11是12月</span></span><br><span class="line"><span class="keyword">var</span> month = d.<span class="title function_">getMonth</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 变成两位</span></span><br><span class="line">month = month &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + month : month;</span><br><span class="line"><span class="comment">// 获取日</span></span><br><span class="line"><span class="keyword">var</span> day = d.<span class="title function_">getDate</span>();</span><br><span class="line">day = day &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + day : day;</span><br><span class="line"><span class="title function_">alert</span>(year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + day);</span><br></pre></td></tr></table></figure><h2 id="32-将字符串”-id-name-”中的-id-替换成10，-name-替换成Tony-（使用正则表达式）"><a href="#32-将字符串”-id-name-”中的-id-替换成10，-name-替换成Tony-（使用正则表达式）" class="headerlink" title="32.将字符串”{$id}{$name}”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）"></a>32.将字符串”<tr><td>{$id}</td><td>{$name}</td></tr>”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）</h2><p>答案：”<tr><td>{$id}</td><td>{$id}_{$name}</td></tr>“.replace(&#x2F;{$id}&#x2F;g, ‘10’).replace(&#x2F;{$name}&#x2F;g, ‘Tony’);</p><h2 id="33-为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将-“进行转义"><a href="#33-为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将-“进行转义" class="headerlink" title="33.为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义"></a>33.为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">escapeHtml</span>(<span class="params">str</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/[&lt;&gt;”&amp;]/g</span>, <span class="keyword">function</span>(<span class="params">match</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">                   <span class="keyword">case</span> “&lt;”:</span><br><span class="line">                      <span class="keyword">return</span> “&amp;lt;”;</span><br><span class="line">                   <span class="keyword">case</span> “&gt;”:</span><br><span class="line">                      <span class="keyword">return</span> “&amp;gt;”;</span><br><span class="line">                   <span class="keyword">case</span> “&amp;”:</span><br><span class="line">                      <span class="keyword">return</span> “&amp;amp;”;</span><br><span class="line">                   <span class="keyword">case</span> “\””:</span><br><span class="line">                      <span class="keyword">return</span> “&amp;quot;”;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="34-foo-foo-bar-，这行代码是什么意思？为什么要这样写？"><a href="#34-foo-foo-bar-，这行代码是什么意思？为什么要这样写？" class="headerlink" title="34.foo &#x3D; foo||bar ，这行代码是什么意思？为什么要这样写？"></a>34.foo &#x3D; foo||bar ，这行代码是什么意思？为什么要这样写？</h2><p>答案：if(!foo) foo &#x3D; bar; &#x2F;&#x2F;如果foo存在，值不变，否则把bar的值赋给foo。<br>短路表达式：作为”&amp;&amp;”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。</p><h2 id="35-看下列代码，将会输出什么-变量声明提升"><a href="#35-看下列代码，将会输出什么-变量声明提升" class="headerlink" title="35.看下列代码，将会输出什么?(变量声明提升)"></a>35.看下列代码，将会输出什么?(变量声明提升)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>答案：输出undefined 和 2。上面代码相当于：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">//undefined</span></span><br><span class="line">    foo = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 2;   </span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>函数声明与变量声明会被JavaScript引擎隐式地提升到当前作用域的顶部，但是只提升名称不会提升赋值部分。</p><h2 id="36-用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。"><a href="#36-用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。" class="headerlink" title="36.用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。"></a>36.用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randomNub</span>(<span class="params">aArray, len, min, max</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (len &gt;= (max - min)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">&#x27;超过&#x27;</span> + min + <span class="string">&#x27;-&#x27;</span> + max + <span class="string">&#x27;之间的个数范围&#x27;</span> + (max - min - <span class="number">1</span>) + <span class="string">&#x27;个的总数&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (aArray.<span class="property">length</span> &gt;= len) &#123;</span><br><span class="line">                   aArray.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span> a - b</span><br><span class="line">                   &#125;);</span><br><span class="line">                   <span class="keyword">return</span> aArray;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">var</span> nowNub = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min - <span class="number">1</span>)) + (min + <span class="number">1</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; aArray.<span class="property">length</span>; j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (nowNub == aArray[j]) &#123;</span><br><span class="line">                       <span class="title function_">randomNub</span>(aArray, len, min, max);</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               aArray.<span class="title function_">push</span>(nowNub);</span><br><span class="line">               <span class="title function_">randomNub</span>(aArray, len, min, max);</span><br><span class="line">               <span class="keyword">return</span> aArray;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="keyword">var</span> arr=[];</span><br><span class="line"><span class="title function_">randomNub</span>(arr,<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="37-把两个数组合并，并删除第二个元素。"><a href="#37-把两个数组合并，并删除第二个元素。" class="headerlink" title="37.把两个数组合并，并删除第二个元素。"></a>37.把两个数组合并，并删除第二个元素。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> bArray = [<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> cArray = array1.<span class="title function_">concat</span>(bArray);</span><br><span class="line">cArray.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="38-怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）"><a href="#38-怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）" class="headerlink" title="38.怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）"></a>38.怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）</h2><p>1）创建新节点<br>createDocumentFragment()    &#x2F;&#x2F;创建一个DOM片段<br>createElement()   &#x2F;&#x2F;创建一个具体的元素<br>createTextNode()   &#x2F;&#x2F;创建一个文本节点<br>2）添加、移除、替换、插入<br>appendChild()      &#x2F;&#x2F;添加<br>removeChild()      &#x2F;&#x2F;移除<br>replaceChild()      &#x2F;&#x2F;替换<br>insertBefore()      &#x2F;&#x2F;插入<br>3）查找<br>getElementsByTagName()    &#x2F;&#x2F;通过标签名称<br>getElementsByName()     &#x2F;&#x2F;通过元素的Name属性的值<br>getElementById()        &#x2F;&#x2F;通过元素Id，唯一性</p><h2 id="39-有这样一个URL：http-item-taobao-com-item-htm-a-1-b-2-c-d-xxx-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-a-’1′-b-’2′-c-”-d-’xxx’-e-undefined-。"><a href="#39-有这样一个URL：http-item-taobao-com-item-htm-a-1-b-2-c-d-xxx-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-a-’1′-b-’2′-c-”-d-’xxx’-e-undefined-。" class="headerlink" title="39.有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}。"></a>39.有这样一个URL：<a href="http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e%EF%BC%8C%E8%AF%B7%E5%86%99%E4%B8%80%E6%AE%B5JS%E7%A8%8B%E5%BA%8F%E6%8F%90%E5%8F%96URL%E4%B8%AD%E7%9A%84%E5%90%84%E4%B8%AAGET%E5%8F%82%E6%95%B0(%E5%8F%82%E6%95%B0%E5%90%8D%E5%92%8C%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8D%E7%A1%AE%E5%AE%9A)%EF%BC%8C%E5%B0%86%E5%85%B6%E6%8C%89key-value%E5%BD%A2%E5%BC%8F%E8%BF%94%E5%9B%9E%E5%88%B0%E4%B8%80%E4%B8%AAjson%E7%BB%93%E6%9E%84%E4%B8%AD%EF%BC%8C%E5%A6%82%7Ba:%E2%80%991%E2%80%B2">http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′</a>, b:’2′, c:”, d:’xxx’, e:undefined}。</h2><p>答案：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">serilizeUrl</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> urlObject = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\?/</span>.<span class="title function_">test</span>(url)) &#123;</span><br><span class="line">        <span class="keyword">var</span> urlString = url.<span class="title function_">substring</span>(url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> urlArray = urlString.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = urlArray.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> urlItem = urlArray[i];</span><br><span class="line">            <span class="keyword">var</span> item = urlItem.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">            urlObject[item[<span class="number">0</span>]] = item[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> urlObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40-正则表达式构造函数var-reg-new-RegExp-“xxx”-与正则表达字面量var-reg-有什么不同？匹配邮箱的正则表达式？"><a href="#40-正则表达式构造函数var-reg-new-RegExp-“xxx”-与正则表达字面量var-reg-有什么不同？匹配邮箱的正则表达式？" class="headerlink" title="40.正则表达式构造函数var reg&#x3D;new RegExp(“xxx”)与正则表达字面量var reg&#x3D;&#x2F;&#x2F;有什么不同？匹配邮箱的正则表达式？"></a>40.正则表达式构造函数var reg&#x3D;new RegExp(“xxx”)与正则表达字面量var reg&#x3D;&#x2F;&#x2F;有什么不同？匹配邮箱的正则表达式？</h2><p>答案：当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。<br>邮箱的正则匹配：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regMail = <span class="regexp">/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/</span>;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/fec612ee/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>convex</title>
      <link>https://jhcgnb.cn/posts/e911cef5/</link>
      <guid>https://jhcgnb.cn/posts/e911cef5/</guid>
      <pubDate>Sat, 08 Apr 2023 13:26:15 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;http://rx6zk4j2b.hn-bkt.clouddn.com/blogs/image-20230708212656757.png&quot; alt=&quot;image-20230708212656757&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;平面地图综合中的conve</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="http://rx6zk4j2b.hn-bkt.clouddn.com/blogs/image-20230708212656757.png" alt="image-20230708212656757"></p><h3 id="平面地图综合中的convex-hull-差分组合"><a href="#平面地图综合中的convex-hull-差分组合" class="headerlink" title="平面地图综合中的convex hull+差分组合"></a>平面地图综合中的convex hull+差分组合</h3><p>平面地图综合中的 “convex hull + 差分组合” 是一种常用的地理信息处理方法，用于合并多个重叠的平面地图数据集，以生成一个较大范围的一致地图。</p><p>首先，让我们解释一下 “convex hull” 和 “差分组合” 的含义：</p><ol><li><p>Convex Hull（凸包）：凸包是一个几何概念，用于描述一个点集的最小凸多边形。对于给定的点集，凸包是包围这些点的最小凸形状，即没有凹陷的形状。在地图综合中，凸包可以用于找到每个地图数据集的边界。</p></li><li><p>差分组合：差分组合是指将两个或多个数据集进行差分操作，以便将它们合并成一个单一的数据集。在地图综合中，差分组合用于合并多个地图数据集，消除重叠和冗余部分。</p></li></ol><p>现在我们来详细介绍 “convex hull + 差分组合” 的过程：</p><ol><li><p>Convex Hull（凸包）：对于每个地图数据集，首先计算该数据集中所有点的凸包。这可以使用凸包算法，例如Graham扫描算法或Jarvis步进算法。凸包的边界定义了该数据集的外围形状。</p></li><li><p>差分操作：通过对每个地图数据集的凸包进行差分操作，可以消除重叠和冗余的部分。差分操作可以通过将边界相交的部分进行裁剪来实现，从而确保每个数据集的边界只包含在该数据集内的部分。</p></li><li><p>组合数据集：将经过差分操作后的每个数据集的边界进行组合，以生成一个新的、一致的地图数据集。这可以通过将每个数据集的边界多边形进行合并或拼接来实现。最终的合并结果将是一个不重叠且连续的边界，代表了整个地图范围。</p></li></ol><p>这种 “convex hull + 差分组合” 的方法在平面地图综合中很有用，因为它能够合并多个重叠的地图数据集，同时消除重叠和冗余的部分。通过计算凸包和执行差分操作，可以获得一个一致且完整的地图，而不会丢失任何细节或引入不一致的边界。</p><p>需要注意的是，实际的实现可能会涉及更复杂的步骤和算法，具体取决于地图数据的类型和处理需求。此外，该方法还可能需要处理边界相交的情况，以确保生成的地图数据集</p><p>是连续且完整的。因此，在实际应用中，可能需要考虑处理重叠、边界修复和边界连接等问题，以获得高质量的地图综合结果。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E5%AD%A6%E6%9C%AF/">学术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <comments>https://jhcgnb.cn/posts/e911cef5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>八叉树结构</title>
      <link>https://jhcgnb.cn/posts/f4dabd3f/</link>
      <guid>https://jhcgnb.cn/posts/f4dabd3f/</guid>
      <pubDate>Sat, 08 Apr 2023 13:12:55 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;八叉树结构&quot;&gt;&lt;a href=&quot;#八叉树结构&quot; class=&quot;headerlink&quot; title=&quot;八叉树结构&quot;&gt;&lt;/a&gt;八叉树结构&lt;/h3&gt;&lt;p&gt;八叉树（Octree）是一种常用的树型数据结构，它是二叉树在三维空间中的扩展。八叉树被广泛应用于计算机图形学、空间分</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="八叉树结构"><a href="#八叉树结构" class="headerlink" title="八叉树结构"></a>八叉树结构</h3><p>八叉树（Octree）是一种常用的树型数据结构，它是二叉树在三维空间中的扩展。八叉树被广泛应用于计算机图形学、空间分区和体积渲染等领域，用于高效地表示和处理三维空间的数据。</p><p>八叉树的基本思想是将三维空间递归地划分为八个等大小的子空间，每个子空间称为一个八叉树节点（Octant）。这种划分方式类似于将立方体分成八个等大小的小立方体。每个节点可以有三种可能的状态：</p><ol><li>叶节点（Leaf Node）：表示当前空间内存在数据或对象，不再继续划分。</li><li>空节点（Empty Node）：表示当前空间内不存在数据或对象，不再继续划分。</li><li>分支节点（Branch Node）：表示当前空间内可能存在数据或对象，需要进一步划分。</li></ol><p>八叉树的构建过程从一个包含所有数据的根节点开始，根据数据的分布情况，逐层划分空间直到满足停止条件。停止条件可以是树的深度达到预定的最大深度，或者节点内的数据数量达到某个阈值。</p><p>八叉树的用法主要有以下几个方面：</p><ol><li><p>空间分区：八叉树可以将三维空间划分为多个小空间，用于高效地管理和查询空间中的数据。在计算机图形学中，八叉树常被用来表示场景中的物体，以便进行快速的碰撞检测和可视化剔除。</p></li><li><p>数据压缩：八叉树可以用来压缩表示稀疏的三维数据。对于只在部分空间中存在数据的情况，八叉树可以有效地存储和表示这些数据，减少存储空间和访问成本。</p></li><li><p>体积渲染：在体积渲染（Volume Rendering）中，八叉树被广泛应用于表示和处理体数据。通过将体数据划分为八叉树节点，可以高效地实现体积数据的可视化和交互式浏览。</p></li><li><p>点云处理：对于三维点云数据，八叉树可以用于加速点云的搜索和查询操作。通过将点云数据划分为八叉树节点，可以快速地找到与给定查询点最近的点或区域。</p></li></ol><p>总的来说，八叉树是一种灵活且高效的数据结构，适用于处理和</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E5%AD%A6%E6%9C%AF/">学术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <comments>https://jhcgnb.cn/posts/f4dabd3f/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
