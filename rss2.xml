<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>纸飞机的旅行</title>
    <link>https://jhcgnb.cn/</link>
    
    <atom:link href="https://jhcgnb.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>选择有时候比努力更重要</description>
    <pubDate>Sat, 27 Jul 2024 16:04:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>（windows系统环境下）ollama + fastgpt搭建本地私有大模型</title>
      <link>https://jhcgnb.cn/posts/f8ffd5a4/</link>
      <guid>https://jhcgnb.cn/posts/f8ffd5a4/</guid>
      <pubDate>Sat, 27 Jul 2024 15:55:47 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;（windows系统环境下）ollama-fastgpt搭建本地私有大模型&quot;&gt;&lt;a href=&quot;#（windows系统环境下）ollama-fastgpt搭建本地私有大模型&quot; class=&quot;headerlink&quot; title=&quot;（windows系统环境下）olla</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="（windows系统环境下）ollama-fastgpt搭建本地私有大模型"><a href="#（windows系统环境下）ollama-fastgpt搭建本地私有大模型" class="headerlink" title="（windows系统环境下）ollama + fastgpt搭建本地私有大模型"></a>（windows系统环境下）ollama + fastgpt搭建本地私有大模型</h2><p>[TOC]</p><h3 id="一、安装ollama"><a href="#一、安装ollama" class="headerlink" title="一、安装ollama"></a>一、安装ollama</h3><h4 id="1、安装ollama"><a href="#1、安装ollama" class="headerlink" title="1、安装ollama"></a>1、安装ollama</h4><p>下载ollama官方windows安装程序，下载后直接双击应用程序安装。</p><p>地址：Ollama.com</p><p><img src="https://telegraph-image-a7r.pages.dev/file/95791eeaca4c584a3fa12.png"></p><p>安装完成后进行更换ollama的存储位置</p><p>（设置环境变量）：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/2c482d652c8bf28d8817d.png"></p><p>设置完成后重启电脑。</p><h4 id="2、下载模型"><a href="#2、下载模型" class="headerlink" title="2、下载模型"></a>2、下载模型</h4><p>ollama官网顶部Models，进入模型列表界面。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/34030191822632ccec634.png"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/a4b93b765e4b9cd65d8a7.png"></p><p>复制完成后进入cmd，并开始下载模型，将复制的模型 粘贴并回车。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/6867a5d6c0f298b65d2e8.png"></p><p>等待就行</p><p><img src="https://telegraph-image-a7r.pages.dev/file/08ad8a52551e37ebbc123.png"></p><p>上图为拉取进度，完成后会自动进行编译，然后本地cmd方式即可进行对话。</p><p>经过以上步骤本地大模型llama3以安装完成，接下来我们通过docker desktop进行搭建fastgpt。</p><h3 id="二、安装部署Fastgpt"><a href="#二、安装部署Fastgpt" class="headerlink" title="二、安装部署Fastgpt"></a>二、安装部署Fastgpt</h3><h4 id="1、部署fastgpt到dockerdesktop"><a href="#1、部署fastgpt到dockerdesktop" class="headerlink" title="1、部署fastgpt到dockerdesktop"></a>1、部署fastgpt到dockerdesktop</h4><p>Fastgpt开源项目地址：<a href="https://github.com/labring/FastGPT">https://github.com/labring/FastGPT</a></p><p>Fastgpt官方docker模式部署地址：<a href="https://doc.fastgpt.in/docs/development/docker/">https://doc.fastgpt.in/docs/development/docker/</a></p><p>方法如下：</p><p>下载 docker desktop。</p><p>安装 docker desktop</p><p>（百度，非常简单）</p><p>依次执行下面命令，创建 FastGPT 文件夹并下载docker-compose.yml和config.json文件，完成后目录下会有 2 个文件。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/865c3ff67d02fc1a11604.png"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/f1d431750dc49be1658af.png" alt="8"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/3ad7f66a837e77d2052c4.png" alt="9"></p><p>文件创建好并拷贝出git上对应的两个文件内容，并cmd进入当前文件夹执行代码：docker-compose up -d</p><p><img src="https://telegraph-image-a7r.pages.dev/file/a1f9e46a65221afe4b4d3.png"></p><h5 id="注意：执行前修改docker-compose-yml中的内容-取消阿里云的注释，将dockerc-hub的源注释。（“自从2023年5月中旬，著名Docker-容器平台：-http-hub-docker-com-“不知”-何种原因国内均无法正常访问了。”）"><a href="#注意：执行前修改docker-compose-yml中的内容-取消阿里云的注释，将dockerc-hub的源注释。（“自从2023年5月中旬，著名Docker-容器平台：-http-hub-docker-com-“不知”-何种原因国内均无法正常访问了。”）" class="headerlink" title="注意：执行前修改docker-compose.yml中的内容,取消阿里云的注释，将dockerc hub的源注释。（“自从2023年5月中旬，著名Docker 容器平台： http://hub.docker.com “不知” 何种原因国内均无法正常访问了。”）"></a><strong>注意</strong>：<em><strong>执行前修改docker-compose.yml中的内容,取消阿里云的注释，将dockerc hub的源注释。（“自从2023年5月中旬，著名Docker 容器平台： <a href="https://link.zhihu.com/?target=http://hub.docker.com">http://hub.docker.com</a> “不知” 何种原因国内均无法正常访问了。”）</strong></em></h5><p>本人修改如下：可直接复制</p><h5 id="注意如果mysql端口冲突请修改端口"><a href="#注意如果mysql端口冲突请修改端口" class="headerlink" title="注意如果mysql端口冲突请修改端口"></a><strong>注意如果mysql端口冲突请修改端口</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据库的默认账号和密码仅首次运行时设置有效</span><br><span class="line"># 如果修改了账号密码，记得改数据库和项目连接参数，别只改一处~</span><br><span class="line"># 该配置文件只是给快速启动，测试使用。正式使用，记得务必修改账号密码，以及调整合适的知识库参数，共享内存等。</span><br><span class="line"># 如何无法访问 dockerhub 和 git，可以用阿里云（阿里云没有arm包）</span><br><span class="line"></span><br><span class="line">version: &#x27;3.3&#x27;</span><br><span class="line">services:</span><br><span class="line">  # db</span><br><span class="line">  pg:</span><br><span class="line">    # image: pgvector/pgvector:0.7.0-pg15 # docker hub</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/pgvector:v0.7.0 # 阿里云</span><br><span class="line">    container_name: pg</span><br><span class="line">    restart: always</span><br><span class="line">    ports: # 生产环境建议不要暴露</span><br><span class="line">      - 5432:5432</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    environment:</span><br><span class="line">      # 这里的配置只有首次运行生效。修改后，重启镜像是不会生效的。需要把持久化数据删除再重启，才有效果</span><br><span class="line">      - POSTGRES_USER=username</span><br><span class="line">      - POSTGRES_PASSWORD=password</span><br><span class="line">      - POSTGRES_DB=postgres</span><br><span class="line">    volumes:</span><br><span class="line">      - ./pg/data:/var/lib/postgresql/data</span><br><span class="line">  mongo:</span><br><span class="line">    # image: mongo:5.0.18 # dockerhub</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/mongo:5.0.18 # 阿里云</span><br><span class="line">    # image: mongo:4.4.29 # cpu不支持AVX时候使用</span><br><span class="line">    container_name: mongo</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 27017:27017</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    command: mongod --keyFile /data/mongodb.key --replSet rs0</span><br><span class="line">    environment:</span><br><span class="line">      - MONGO_INITDB_ROOT_USERNAME=myusername</span><br><span class="line">      - MONGO_INITDB_ROOT_PASSWORD=mypassword</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mongo/data:/data/db</span><br><span class="line">    entrypoint:</span><br><span class="line">      - bash</span><br><span class="line">      - -c</span><br><span class="line">      - |</span><br><span class="line">        openssl rand -base64 128 &gt; /data/mongodb.key</span><br><span class="line">        chmod 400 /data/mongodb.key</span><br><span class="line">        chown 999:999 /data/mongodb.key</span><br><span class="line">        echo &#x27;const isInited = rs.status().ok === 1</span><br><span class="line">        if(!isInited)&#123;</span><br><span class="line">          rs.initiate(&#123;</span><br><span class="line">              _id: &quot;rs0&quot;,</span><br><span class="line">              members: [</span><br><span class="line">                  &#123; _id: 0, host: &quot;mongo:27017&quot; &#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;&#x27; &gt; /data/initReplicaSet.js</span><br><span class="line">        # 启动MongoDB服务</span><br><span class="line">        exec docker-entrypoint.sh &quot;$$@&quot; &amp;</span><br><span class="line"></span><br><span class="line">        # 等待MongoDB服务启动</span><br><span class="line">        until mongo -u myusername -p mypassword --authenticationDatabase admin --eval &quot;print(&#x27;waited for connection&#x27;)&quot; &gt; /dev/null 2&gt;&amp;1; do</span><br><span class="line">          echo &quot;Waiting for MongoDB to start...&quot;</span><br><span class="line">          sleep 2</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        # 执行初始化副本集的脚本</span><br><span class="line">        mongo -u myusername -p mypassword --authenticationDatabase admin /data/initReplicaSet.js</span><br><span class="line"></span><br><span class="line">        # 等待docker-entrypoint.sh脚本执行的MongoDB服务进程</span><br><span class="line">        wait $$!</span><br><span class="line"></span><br><span class="line">  # fastgpt</span><br><span class="line">  sandbox:</span><br><span class="line">    container_name: sandbox</span><br><span class="line">    # image: ghcr.io/labring/fastgpt-sandbox:latest # git</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/fastgpt-sandbox:latest # 阿里云</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    restart: always</span><br><span class="line">  fastgpt:</span><br><span class="line">    container_name: fastgpt</span><br><span class="line">    # image: ghcr.io/labring/fastgpt:v4.8.7 # git</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/fastgpt:v4.8.7 # 阿里云</span><br><span class="line">    ports:</span><br><span class="line">      - 3000:3000</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    depends_on:</span><br><span class="line">      - mongo</span><br><span class="line">      - pg</span><br><span class="line">      - sandbox</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      # root 密码，用户名为: root。如果需要修改 root 密码，直接修改这个环境变量，并重启即可。</span><br><span class="line">      - DEFAULT_ROOT_PSW=1234</span><br><span class="line">      # AI模型的API地址哦。务必加 /v1。这里默认填写了OneApi的访问地址。</span><br><span class="line">      - OPENAI_BASE_URL=http://oneapi:3000/v1</span><br><span class="line">      # AI模型的API Key。（这里默认填写了OneAPI的快速默认key，测试通后，务必及时修改）</span><br><span class="line">      - CHAT_API_KEY=sk-fastgpt</span><br><span class="line">      # 数据库最大连接数</span><br><span class="line">      - DB_MAX_LINK=30</span><br><span class="line">      # 登录凭证密钥</span><br><span class="line">      - TOKEN_KEY=any</span><br><span class="line">      # root的密钥，常用于升级时候的初始化请求</span><br><span class="line">      - ROOT_KEY=root_key</span><br><span class="line">      # 文件阅读加密</span><br><span class="line">      - FILE_TOKEN_KEY=filetoken</span><br><span class="line">      # MongoDB 连接参数. 用户名myusername,密码mypassword。</span><br><span class="line">      - MONGODB_URI=mongodb://myusername:mypassword@mongo:27017/fastgpt?authSource=admin</span><br><span class="line">      # pg 连接参数</span><br><span class="line">      - PG_URL=postgresql://username:password@pg:5432/postgres</span><br><span class="line">      # sandbox 地址</span><br><span class="line">      - SANDBOX_URL=http://sandbox:3000</span><br><span class="line">      # 日志等级: debug, info, warn, error</span><br><span class="line">      - LOG_LEVEL=info</span><br><span class="line">      - STORE_LOG_LEVEL=warn</span><br><span class="line">    volumes:</span><br><span class="line">      - ./config.json:/app/data/config.json</span><br><span class="line"></span><br><span class="line">  # oneapi</span><br><span class="line">  mysql:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/mysql:8.0.36 # 阿里云</span><br><span class="line">    # image: mysql:8.0.36</span><br><span class="line">    container_name: mysql</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 3307:3307</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    command: --default-authentication-plugin=mysql_native_password</span><br><span class="line">    environment:</span><br><span class="line">      # 默认root密码，仅首次运行有效</span><br><span class="line">      MYSQL_ROOT_PASSWORD: oneapimmysql</span><br><span class="line">      MYSQL_DATABASE: oneapi</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mysql:/var/lib/mysql</span><br><span class="line">  oneapi:</span><br><span class="line">    container_name: oneapi</span><br><span class="line">    # image: ghcr.io/songquanpeng/one-api:0.6.7</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/one-api:v0.6.6 # 阿里云</span><br><span class="line">    ports:</span><br><span class="line">      - 3001:3000</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      # mysql 连接参数</span><br><span class="line">      - SQL_DSN=root:oneapimmysql@tcp(mysql:3307)/oneapi</span><br><span class="line">      # 登录凭证加密密钥</span><br><span class="line">      - SESSION_SECRET=oneapikey</span><br><span class="line">      # 内存缓存</span><br><span class="line">      - MEMORY_CACHE_ENABLED=true</span><br><span class="line">      # 启动聚合更新，减少数据交互频率</span><br><span class="line">      - BATCH_UPDATE_ENABLED=true</span><br><span class="line">      # 聚合更新时长</span><br><span class="line">      - BATCH_UPDATE_INTERVAL=10</span><br><span class="line">      # 初始化的 root 密钥（建议部署完后更改，否则容易泄露）</span><br><span class="line">      - INITIAL_ROOT_TOKEN=fastgpt</span><br><span class="line">    volumes:</span><br><span class="line">      - ./oneapi:/data</span><br><span class="line">networks:</span><br><span class="line">  fastgpt:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后等待安装完成（由于我电脑已经完成安装，就不演示了）。完成后docker desktop会显示如下信息：</p><p>docker desktop内容：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/f008bc1ec6184d7486774.png"></p><h4 id="2、启动并配置one-api模型："><a href="#2、启动并配置one-api模型：" class="headerlink" title="2、启动并配置one api模型："></a>2、启动并配置one api模型：</h4><p>访问本地部署好的one api：<a href="http://localhost:3001/">http://localhost:3001</a></p><p>初始化的    用户名:root   密码：123456</p><p><img src="https://telegraph-image-a7r.pages.dev/file/fe7886252f4a7e4b418b8.jpg"></p><p>进入后会叫修改密码之类的，完成后点击“渠道”，配置自己的大语言模型。首次登录进来空的，需要自己添加自己的大模型。</p><p>接下来配置刚刚安装的本地大模型llama3呢？</p><p>第一步：先点击 底部“添加新的渠道”，然后选择“Ollama”。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/6dfcbd0794ee22f1dc615.jpg"></p><p>第二步：配置本地llama3大模型</p><p>查询本地ollama中的模型名称，填入模型的时候用到</p><p>完整的配置界面</p><p>完成后测试通过，下图中有时间返回，就说明模型链接成功。</p><p>oneapi还有最后一步，就是将模型加入到自己的令牌中，点击顶部“令牌”导航进入。选默认的令牌信息，并添加ollama3模型。</p><h3 id="三、配置Fastgpt"><a href="#三、配置Fastgpt" class="headerlink" title="三、配置Fastgpt"></a>三、配置Fastgpt</h3><p>接下来配置Fastgpt并使用咱们导入的本地大模型llama3来进行创建chat 或者 agent了。</p><p>1、配置fastgpt的模型<br>进入最开始的fastgpt文件夹。找到config.json,配置llama3模型，位置和代码如下：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/1b04db794f4f6408851a5.jpg"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/c644551376e684c1f5322.jpg"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/9c9a916640758cee34dbd.jpg"></p><p>完成配置后需要重新启动docker  desktop里面的oneapi和fastgpt。</p><p>2、访问fastgpt<br>地址：<a href="http://localhost:3000，默认用户名：root">http://localhost:3000，默认用户名：root</a>  密码：1234</p><p><img src="https://telegraph-image-a7r.pages.dev/file/a1f766c1e1a33cdcbb135.jpg"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/ede806ff36b5627390923.png"></p><p>2、配置应用chat、agent等：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/039d2ac9efeff6c2b54e3.jpg"></p><p>选择一个大模型，配置到你创建的应用中。</p><p>完成模型选择后进行 发布，发布后即可在右变边的聊天框中输入信息，进行对话。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B/">本地安装部署大模型</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">安装教程</category>
      
      
      <comments>https://jhcgnb.cn/posts/f8ffd5a4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>（linux系统环境下）ollama + fastgpt搭建本地私有大模型</title>
      <link>https://jhcgnb.cn/posts/4b0d6ffc/</link>
      <guid>https://jhcgnb.cn/posts/4b0d6ffc/</guid>
      <pubDate>Sat, 27 Jul 2024 15:54:16 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;一、安装VM虚拟机&quot;&gt;&lt;a href=&quot;#一、安装VM虚拟机&quot; class=&quot;headerlink&quot; title=&quot;一、安装VM虚拟机&quot;&gt;&lt;/a&gt;一、安装VM虚拟机&lt;/h3&gt;&lt;h6 id=&quot;1、安装VM&quot;&gt;&lt;a href=&quot;#1、安装VM&quot; class=&quot;head</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="一、安装VM虚拟机"><a href="#一、安装VM虚拟机" class="headerlink" title="一、安装VM虚拟机"></a>一、安装VM虚拟机</h3><h6 id="1、安装VM"><a href="#1、安装VM" class="headerlink" title="1、安装VM"></a>1、安装VM</h6><p>本文提供的15版本：以及CentOS7</p><p>链接: <a href="https://pan.baidu.com/s/15z4_8S1U21v_fQTSO1zZuw?pwd=9hrn">https://pan.baidu.com/s/15z4_8S1U21v_fQTSO1zZuw?pwd=9hrn</a> 提取码: 9hrn</p><p>可参照以下安装方式，不在赘述。</p><p>地址：<a href="https://blog.csdn.net/weixin_74195551/article/details/127288338">https://blog.csdn.net/weixin_74195551/article/details/127288338</a></p><p><img src="https://telegraph-image-a7r.pages.dev/file/fd8b5862b11f68f2d4f2c.png" alt=""></p><h3 id="二、安装ollama"><a href="#二、安装ollama" class="headerlink" title="二、安装ollama"></a>二、安装ollama</h3><h6 id="1、在ollama官网下载找到linux点击复制，然偶在命令行右键复制（注意如果只是虚拟机的话没法直接复制，建议安装一个远程控制终端）"><a href="#1、在ollama官网下载找到linux点击复制，然偶在命令行右键复制（注意如果只是虚拟机的话没法直接复制，建议安装一个远程控制终端）" class="headerlink" title="1、在ollama官网下载找到linux点击复制，然偶在命令行右键复制（注意如果只是虚拟机的话没法直接复制，建议安装一个远程控制终端）"></a>1、在ollama官网下载找到linux点击复制，然偶在命令行右键复制（注意如果只是虚拟机的话没法直接复制，建议安装一个远程控制终端）</h6><p><img src="https://telegraph-image-a7r.pages.dev/file/6ae8a1046c72aacb58f93.jpg" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/ac74837e7fcc5cbcb6459.jpg" alt=""></p><p>等待下载完成，建议早上或者晚上下载（因为本机已经下载所以不在下载）</p><h6 id="2、下载模型"><a href="#2、下载模型" class="headerlink" title="2、下载模型"></a>2、下载模型</h6><p>ollama官网顶部Models，进入模型列表界面。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/34030191822632ccec634.png" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/a4b93b765e4b9cd65d8a7.png" alt=""></p><p>复制完成后进入linux终端，并开始下载模型，将复制的模型 粘贴并回车。</p><p>等待就行</p><p><img src="https://telegraph-image-a7r.pages.dev/file/08ad8a52551e37ebbc123.png" alt=""></p><p>上图为拉取进度，完成后会自动进行编译。</p><p>经过以上步骤本地大模型llama3以安装完成，接下来我们通过docker进行搭建fastgpt。</p><h3 id="三、安装docker"><a href="#三、安装docker" class="headerlink" title="三、安装docker"></a>三、安装docker</h3><p>注：在安装docker之前如果没有安装git建议安装git。具体操作（可以百度，一大堆）：<a href="https://blog.csdn.net/m0_52985087/article/details/136205445">https://blog.csdn.net/m0_52985087/article/details/136205445</a></p><h6 id="1、具体安装："><a href="#1、具体安装：" class="headerlink" title="1、具体安装："></a>1、具体安装：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 Docker</span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br><span class="line">systemctl enable --now docker</span><br><span class="line"># 安装 docker-compose</span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"># 验证安装</span><br><span class="line">docker -v</span><br><span class="line">docker-compose -v</span><br><span class="line"># 如失效，自行百度</span><br></pre></td></tr></table></figure><h3 id="四、部署Fastgpt"><a href="#四、部署Fastgpt" class="headerlink" title="四、部署Fastgpt"></a>四、部署Fastgpt</h3><h6 id="1、开始部署"><a href="#1、开始部署" class="headerlink" title="1、开始部署"></a>1、开始部署</h6><p>Fastgpt开源项目地址：<a href="https://github.com/labring/FastGPT">https://github.com/labring/FastGPT</a></p><p>Fastgpt官方docker模式部署地址：<a href="https://doc.fastgpt.in/docs/development/docker/">https://doc.fastgpt.in/docs/development/docker/</a></p><p>方法如下：按下边步骤在虚拟机终端输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir fastgpt</span><br><span class="line">cd fastgpt</span><br><span class="line">curl -O https://raw.githubusercontent.com/labring/FastGPT/main/projects/app/data/config.json</span><br><span class="line"> </span><br><span class="line"># pgvector 版本(测试推荐，简单快捷)</span><br><span class="line">curl -o docker-compose.yml https://raw.githubusercontent.com/labring/FastGPT/main/files/docker/docker-compose-pgvector.yml</span><br><span class="line"># milvus 版本</span><br><span class="line"># curl -o docker-compose.yml https://raw.githubusercontent.com/labring/FastGPT/main/files/docker/docker-compose-milvus.yml</span><br><span class="line"># zilliz 版本</span><br><span class="line"># curl -o docker-compose.yml https://raw.githubusercontent.com/labring/FastGPT/main/files/docker/docker-compose-zilliz.yml</span><br></pre></td></tr></table></figure><p>最后通过ls查看下载是否成果：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/11fe9a6411d2baa026370.jpg" alt=""></p><h4 id="注意：执行前修改docker-compose-yml中的内容-取消阿里云的注释，将dockerc-hub的源注释。（“自从2023年5月中旬，著名Docker-容器平台：-http-hub-docker-com-“不知”-何种原因国内均无法正常访问了。”）"><a href="#注意：执行前修改docker-compose-yml中的内容-取消阿里云的注释，将dockerc-hub的源注释。（“自从2023年5月中旬，著名Docker-容器平台：-http-hub-docker-com-“不知”-何种原因国内均无法正常访问了。”）" class="headerlink" title="注意：执行前修改docker-compose.yml中的内容,取消阿里云的注释，将dockerc hub的源注释。（“自从2023年5月中旬，著名Docker 容器平台： http://hub.docker.com “不知” 何种原因国内均无法正常访问了。”）"></a><strong>注意</strong>：<strong><em>执行前修改docker-compose.yml中的内容,取消阿里云的注释，将dockerc hub的源注释。（“自从2023年5月中旬，著名Docker 容器平台： <a href="https://link.zhihu.com/?target=http%3A//hub.docker.com">http://hub.docker.com</a> “不知” 何种原因国内均无法正常访问了。”）</em></strong></h4><p>本人修改如下：可直接复制</p><h4 id="注意如果mysql端口冲突请修改端口"><a href="#注意如果mysql端口冲突请修改端口" class="headerlink" title="注意如果mysql端口冲突请修改端口"></a><strong>注意如果mysql端口冲突请修改端口</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据库的默认账号和密码仅首次运行时设置有效</span><br><span class="line"># 如果修改了账号密码，记得改数据库和项目连接参数，别只改一处~</span><br><span class="line"># 该配置文件只是给快速启动，测试使用。正式使用，记得务必修改账号密码，以及调整合适的知识库参数，共享内存等。</span><br><span class="line"># 如何无法访问 dockerhub 和 git，可以用阿里云（阿里云没有arm包）</span><br><span class="line"></span><br><span class="line">version: &#x27;3.3&#x27;</span><br><span class="line">services:</span><br><span class="line">  # db</span><br><span class="line">  pg:</span><br><span class="line">    # image: pgvector/pgvector:0.7.0-pg15 # docker hub</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/pgvector:v0.7.0 # 阿里云</span><br><span class="line">    container_name: pg</span><br><span class="line">    restart: always</span><br><span class="line">    ports: # 生产环境建议不要暴露</span><br><span class="line">      - 5432:5432</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    environment:</span><br><span class="line">      # 这里的配置只有首次运行生效。修改后，重启镜像是不会生效的。需要把持久化数据删除再重启，才有效果</span><br><span class="line">      - POSTGRES_USER=username</span><br><span class="line">      - POSTGRES_PASSWORD=password</span><br><span class="line">      - POSTGRES_DB=postgres</span><br><span class="line">    volumes:</span><br><span class="line">      - ./pg/data:/var/lib/postgresql/data</span><br><span class="line">  mongo:</span><br><span class="line">    # image: mongo:5.0.18 # dockerhub</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/mongo:5.0.18 # 阿里云</span><br><span class="line">    # image: mongo:4.4.29 # cpu不支持AVX时候使用</span><br><span class="line">    container_name: mongo</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 27017:27017</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    command: mongod --keyFile /data/mongodb.key --replSet rs0</span><br><span class="line">    environment:</span><br><span class="line">      - MONGO_INITDB_ROOT_USERNAME=myusername</span><br><span class="line">      - MONGO_INITDB_ROOT_PASSWORD=mypassword</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mongo/data:/data/db</span><br><span class="line">    entrypoint:</span><br><span class="line">      - bash</span><br><span class="line">      - -c</span><br><span class="line">      - |</span><br><span class="line">        openssl rand -base64 128 &gt; /data/mongodb.key</span><br><span class="line">        chmod 400 /data/mongodb.key</span><br><span class="line">        chown 999:999 /data/mongodb.key</span><br><span class="line">        echo &#x27;const isInited = rs.status().ok === 1</span><br><span class="line">        if(!isInited)&#123;</span><br><span class="line">          rs.initiate(&#123;</span><br><span class="line">              _id: &quot;rs0&quot;,</span><br><span class="line">              members: [</span><br><span class="line">                  &#123; _id: 0, host: &quot;mongo:27017&quot; &#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;&#x27; &gt; /data/initReplicaSet.js</span><br><span class="line">        # 启动MongoDB服务</span><br><span class="line">        exec docker-entrypoint.sh &quot;$$@&quot; &amp;</span><br><span class="line"></span><br><span class="line">        # 等待MongoDB服务启动</span><br><span class="line">        until mongo -u myusername -p mypassword --authenticationDatabase admin --eval &quot;print(&#x27;waited for connection&#x27;)&quot; &gt; /dev/null 2&gt;&amp;1; do</span><br><span class="line">          echo &quot;Waiting for MongoDB to start...&quot;</span><br><span class="line">          sleep 2</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        # 执行初始化副本集的脚本</span><br><span class="line">        mongo -u myusername -p mypassword --authenticationDatabase admin /data/initReplicaSet.js</span><br><span class="line"></span><br><span class="line">        # 等待docker-entrypoint.sh脚本执行的MongoDB服务进程</span><br><span class="line">        wait $$!</span><br><span class="line"></span><br><span class="line">  # fastgpt</span><br><span class="line">  sandbox:</span><br><span class="line">    container_name: sandbox</span><br><span class="line">    # image: ghcr.io/labring/fastgpt-sandbox:latest # git</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/fastgpt-sandbox:latest # 阿里云</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    restart: always</span><br><span class="line">  fastgpt:</span><br><span class="line">    container_name: fastgpt</span><br><span class="line">    # image: ghcr.io/labring/fastgpt:v4.8.7 # git</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/fastgpt:v4.8.7 # 阿里云</span><br><span class="line">    ports:</span><br><span class="line">      - 3000:3000</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    depends_on:</span><br><span class="line">      - mongo</span><br><span class="line">      - pg</span><br><span class="line">      - sandbox</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      # root 密码，用户名为: root。如果需要修改 root 密码，直接修改这个环境变量，并重启即可。</span><br><span class="line">      - DEFAULT_ROOT_PSW=1234</span><br><span class="line">      # AI模型的API地址哦。务必加 /v1。这里默认填写了OneApi的访问地址。</span><br><span class="line">      - OPENAI_BASE_URL=http://oneapi:3000/v1</span><br><span class="line">      # AI模型的API Key。（这里默认填写了OneAPI的快速默认key，测试通后，务必及时修改）</span><br><span class="line">      - CHAT_API_KEY=sk-fastgpt</span><br><span class="line">      # 数据库最大连接数</span><br><span class="line">      - DB_MAX_LINK=30</span><br><span class="line">      # 登录凭证密钥</span><br><span class="line">      - TOKEN_KEY=any</span><br><span class="line">      # root的密钥，常用于升级时候的初始化请求</span><br><span class="line">      - ROOT_KEY=root_key</span><br><span class="line">      # 文件阅读加密</span><br><span class="line">      - FILE_TOKEN_KEY=filetoken</span><br><span class="line">      # MongoDB 连接参数. 用户名myusername,密码mypassword。</span><br><span class="line">      - MONGODB_URI=mongodb://myusername:mypassword@mongo:27017/fastgpt?authSource=admin</span><br><span class="line">      # pg 连接参数</span><br><span class="line">      - PG_URL=postgresql://username:password@pg:5432/postgres</span><br><span class="line">      # sandbox 地址</span><br><span class="line">      - SANDBOX_URL=http://sandbox:3000</span><br><span class="line">      # 日志等级: debug, info, warn, error</span><br><span class="line">      - LOG_LEVEL=info</span><br><span class="line">      - STORE_LOG_LEVEL=warn</span><br><span class="line">    volumes:</span><br><span class="line">      - ./config.json:/app/data/config.json</span><br><span class="line"></span><br><span class="line">  # oneapi</span><br><span class="line">  mysql:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/mysql:8.0.36 # 阿里云</span><br><span class="line">    # image: mysql:8.0.36</span><br><span class="line">    container_name: mysql</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 3307:3307</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    command: --default-authentication-plugin=mysql_native_password</span><br><span class="line">    environment:</span><br><span class="line">      # 默认root密码，仅首次运行有效</span><br><span class="line">      MYSQL_ROOT_PASSWORD: oneapimmysql</span><br><span class="line">      MYSQL_DATABASE: oneapi</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mysql:/var/lib/mysql</span><br><span class="line">  oneapi:</span><br><span class="line">    container_name: oneapi</span><br><span class="line">    # image: ghcr.io/songquanpeng/one-api:0.6.7</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/one-api:v0.6.6 # 阿里云</span><br><span class="line">    ports:</span><br><span class="line">      - 3001:3000</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      # mysql 连接参数</span><br><span class="line">      - SQL_DSN=root:oneapimmysql@tcp(mysql:3307)/oneapi</span><br><span class="line">      # 登录凭证加密密钥</span><br><span class="line">      - SESSION_SECRET=oneapikey</span><br><span class="line">      # 内存缓存</span><br><span class="line">      - MEMORY_CACHE_ENABLED=true</span><br><span class="line">      # 启动聚合更新，减少数据交互频率</span><br><span class="line">      - BATCH_UPDATE_ENABLED=true</span><br><span class="line">      # 聚合更新时长</span><br><span class="line">      - BATCH_UPDATE_INTERVAL=10</span><br><span class="line">      # 初始化的 root 密钥（建议部署完后更改，否则容易泄露）</span><br><span class="line">      - INITIAL_ROOT_TOKEN=fastgpt</span><br><span class="line">    volumes:</span><br><span class="line">      - ./oneapi:/data</span><br><span class="line">networks:</span><br><span class="line">  fastgpt:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件创建好并拷贝出git上对应的两个文件内容，并终端进入当前文件夹执行代码：docker-compose up -d</p><p>然后等待安装完成（由于我电脑已经完成安装，就不演示了）。如图11</p><p>安装完成后</p><p><img src="https://telegraph-image-a7r.pages.dev/file/ba86196d20d089126da66.jpg" alt=""></p><h6 id="2、配置本地llama3大模型"><a href="#2、配置本地llama3大模型" class="headerlink" title="2、配置本地llama3大模型"></a>2、配置本地llama3大模型</h6><p>接下来配置Fastgpt并使用咱们导入的本地大模型llama3来进行创建chat 或者 agent了。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/e8fc3eaf137d480ec167d.jpg" alt=""></p><p>如果没有终端工具可直接在虚拟机CentOS终端按如下操作：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/bf4c592d54a04357b223c.jpg" alt=""></p><p>回车进入后：删除所有内容复制本文提供的，或者挨个取消阿里云注释，然后将dokcer Hub源注释</p><p>（注，如果没有安装Vim需要安装Vim编辑器，百度）</p><p><img src="https://telegraph-image-a7r.pages.dev/file/01ab626cc234d8c1f41f7.jpg" alt=""></p><h6 id="3、配置fastgpt的模型"><a href="#3、配置fastgpt的模型" class="headerlink" title="3、配置fastgpt的模型"></a>3、配置fastgpt的模型</h6><p>进入最开始的fastgpt文件夹。找到config.json,配置llama3模型，位置和代码如下：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/1b04db794f4f6408851a5.jpg" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/c644551376e684c1f5322.jpg" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/9c9a916640758cee34dbd.jpg" alt=""></p><p>如果没有终端工具可直接在虚拟机CentOS终端按如下操作：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/2b2b4542d4ca394d51d79.jpg" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/cffa454291973fc8d4114.jpg" alt=""></p><h6 id="4、启动容器"><a href="#4、启动容器" class="headerlink" title="4、启动容器"></a>4、启动容器</h6><p>在 docker-compose.yml 同级目录下执行。请确保docker-compose版本最好在2.17以上，否则可能无法执行自动化命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动容器</span><br><span class="line">docker-compose up -d</span><br><span class="line"># 等待10s，OneAPI第一次总是要重启几次才能连上Mysql</span><br><span class="line">sleep 10</span><br><span class="line"># 重启一次oneapi(由于OneAPI的默认Key有点问题，不重启的话会提示找不到渠道，临时手动重启一次解决，等待作者修复)</span><br><span class="line">docker restart oneapi</span><br></pre></td></tr></table></figure><h6 id="5、访问fastgpt"><a href="#5、访问fastgpt" class="headerlink" title="5、访问fastgpt"></a>5、访问fastgpt</h6><p>在终端CentOS中输入ipconfig或者百度如何查询自己的ip地址</p><p>地址：ip：3000，默认用户名：root  密码：1234</p><p><img src="https://telegraph-image-a7r.pages.dev/file/a1f766c1e1a33cdcbb135.jpg" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/ede806ff36b5627390923.png" alt=""></p><p>2、配置应用chat、agent等：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/039d2ac9efeff6c2b54e3.jpg" alt=""></p><p>选择一个大模型，配置到你创建的应用中。</p><p>完成模型选择后进行 发布，发布后即可在右变边的聊天框中输入信息，进行对话。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B/">本地安装部署大模型</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">安装教程</category>
      
      
      <comments>https://jhcgnb.cn/posts/4b0d6ffc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第八期）</title>
      <link>https://jhcgnb.cn/posts/3cf6ea2d/</link>
      <guid>https://jhcgnb.cn/posts/3cf6ea2d/</guid>
      <pubDate>Tue, 16 Jul 2024 15:50:39 GMT</pubDate>
      
      <description>&lt;p&gt;说在前面的一些话（碎碎念+吐槽）：&lt;/p&gt;
&lt;p&gt;目前这一段时间一直在忙自己的事情，以前以为自己精力旺盛，但是一上班，一开始朝九晚五，其实还不算是朝九晚五，早上八点半，晚上六点。发现每天回到家里以后是真的累，坐在沙发上休息会后洗漱收拾后一晃就九十点了。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>说在前面的一些话（碎碎念+吐槽）：</p><p>目前这一段时间一直在忙自己的事情，以前以为自己精力旺盛，但是一上班，一开始朝九晚五，其实还不算是朝九晚五，早上八点半，晚上六点。发现每天回到家里以后是真的累，坐在沙发上休息会后洗漱收拾后一晃就九十点了。</p><span id="more"></span><p>​哈哈 “钱难挣，屎难吃”，对我这个普通人太难了。如果目前还在学校的即将毕业的一定要考虑号自己想要的，及时早做准备，两手抓。</p><p>因为这些题目都是之前面试通过记忆面试结束后记录、部分通过录音。目前我还在整理，当然有一部分也是我在做项目中出现的问题，今天就先整理一点（偷懒），因为有些答案还需要实地操作才能得出。当然依旧是答案仅供参考。</p><h3 id="1、cesium里面polyline线段有几种表现"><a href="#1、cesium里面polyline线段有几种表现" class="headerlink" title="1、cesium里面polyline线段有几种表现?"></a>1、cesium里面polyline线段有几种表现?</h3><p>在Cesium中，Polyline（线段）可以有以下几种表现类型：</p><ol><li><p><strong>空间直线 (Space Line &#x2F; No Arc)</strong>: 这种类型的线段表现为两点之间的直接连线，无视地球曲率，适用于小范围或在平面上模拟直线效果。在Cesium中，可以通过设置 <code>Cesium.ArcType.NONE</code> 实现。</p></li><li><p><strong>球面线段 (Geodesic Line &#x2F; Great Circle Arc)</strong>: 考虑地球曲率，这种线段在球面上表现为大圆弧，是两点间地球上实际最短路径。使用 <code>Cesium.ArcType.GEODESIC</code> 可以得到这种表现形式。</p></li><li><p><strong>恒向线 (Rhumb Line &#x2F; Loxodrome)</strong>: 恒向线是一种在航行中保持固定方位角的航线，它在地图上表现为与纬线成一定角度的曲线。在Cesium中，通过指定 <code>Cesium.ArcType.RHUMB</code> 可以创建恒向线。</p></li></ol><h3 id="2、Cesium中3DTiles模型如何旋转"><a href="#2、Cesium中3DTiles模型如何旋转" class="headerlink" title="2、Cesium中3DTiles模型如何旋转"></a>2、Cesium中3DTiles模型如何旋转</h3><p>在Cesium中，对3D Tiles模型进行旋转可以通过修改模型的<code>modelMatrix</code>属性来实现。</p><p>首先加载一个3D Tiles模型，然后定义绕X轴旋转的角度，并将其转换为弧度。接着，使用<code>Cesium.Matrix3.fromRotationX</code>创建了一个表示X轴旋转的3x3矩阵，然后通过<code>Cesium.Matrix4.multiplyByMatrix3</code>将此旋转矩阵与模型的当前变换矩阵相乘，得到新的变换矩阵。最后，将这个包含旋转信息的新变换矩阵赋值给<code>tileset.modelMatrix</code>，从而实现了模型的旋转。</p><p>具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 导入Cesium库</span><br><span class="line">const Cesium = require(&#x27;cesium&#x27;);</span><br><span class="line"></span><br><span class="line">// 假设你已经有了一个Cesium Viewer实例</span><br><span class="line">const viewer = new Cesium.Viewer(&#x27;cesiumContainer&#x27;);</span><br><span class="line"></span><br><span class="line">// 加载3D Tiles数据</span><br><span class="line">const tileset = viewer.scene.primitives.add(new Cesium.Cesium3DTileset(&#123;</span><br><span class="line">    url: &#x27;./path/to/your/3d/tiles/tileset.json&#x27;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">// 定义旋转参数，例如围绕X轴旋转的角度（单位：度）</span><br><span class="line">const RotateX = 45; // 旋转45度为例</span><br><span class="line"></span><br><span class="line">// 将角度转换为弧度</span><br><span class="line">const rotationInRadians = Cesium.Math.toRadians(RotateX);</span><br><span class="line"></span><br><span class="line">// 创建一个旋转矩阵，这里以X轴旋转为例</span><br><span class="line">const rotationMatrix = Cesium.Matrix3.fromRotationX(rotationInRadians);</span><br><span class="line"></span><br><span class="line">// 将旋转矩阵转换为4x4的模型变换矩阵</span><br><span class="line">// 假设tileset的初始modelMatrix为单位矩阵或者你有特定的初始变换</span><br><span class="line">let modelMatrix = Cesium.Matrix4.IDENTITY;</span><br><span class="line"></span><br><span class="line">// 应用旋转到现有的modelMatrix</span><br><span class="line">Cesium.Matrix4.multiplyByMatrix3(modelMatrix, rotationMatrix, modelMatrix);</span><br><span class="line"></span><br><span class="line">// 将更新后的modelMatrix应用到tileset上</span><br><span class="line">tileset.modelMatrix = modelMatrix;</span><br></pre></td></tr></table></figure><h3 id="3、cesium提供了三种方式，可以对camera进行操作，这三种方式，有三个共同的参数，heading-pitch-roll-那么，这三个参数分别是什么呢"><a href="#3、cesium提供了三种方式，可以对camera进行操作，这三种方式，有三个共同的参数，heading-pitch-roll-那么，这三个参数分别是什么呢" class="headerlink" title="3、cesium提供了三种方式，可以对camera进行操作，这三种方式，有三个共同的参数，heading,pitch, roll,那么，这三个参数分别是什么呢?"></a>3、cesium提供了三种方式，可以对camera进行操作，这三种方式，有三个共同的参数，heading,pitch, roll,那么，这三个参数分别是什么呢?</h3><p><strong>简单：</strong>这三个参数组合起来可以精确控制camera的方向和视角，常用于设置camera的初始位置、动画过渡（如flyTo操作）或动态调整观察视角。在Cesium的API中，如<code>setView</code>、<code>flyTo</code>、或<code>lookAt</code>方法中，通过<code>orientation</code>对象传递这些参数，通常需要将角度从度转换为弧度使用<code>Cesium.Math.toRadians</code>函数。</p><p><strong>详细</strong>：</p><p>在Cesium中，对camera进行操作时涉及的三个共同参数——heading、pitch、roll，它们是用来描述camera方向的旋转角度，与航空和航海中常用的欧拉角类似。具体来说：</p><ol><li><strong>Heading（偏航角 &#x2F; Yaw）</strong>: Heading代表camera绕垂直方向（通常是指向地心的方向，也就是上方向）旋转的角度，影响camera左右看向的能力。在Cesium中，正值表示向右转，负值表示向左转。</li><li><strong>Pitch（俯仰角 &#x2F; Pitch）</strong>: Pitch代表camera绕横向（水平面的正面到背面）旋转的角度，决定了camera向上或向下看的程度。正值使camera抬头向上看，负值使camera低头向下看。当pitch达到90度时，camera朝向直接向下，达到-90度时则直接向上。</li><li><strong>Roll（翻滚角 &#x2F; Roll）</strong>: Roll描述camera绕其前进方向的轴线旋转，影响camera自身的侧翻。在大多数应用场景中，camera的roll通常被设置为0，以保持camera平台的水平，但在特殊视觉效果或模拟飞行中可能会用到非零的roll值。</li></ol><h3 id="4、看你做过很多项目，你能描述制作cesium-热力图的逻辑步骤过程嘛，就是你如何做一个热力图。"><a href="#4、看你做过很多项目，你能描述制作cesium-热力图的逻辑步骤过程嘛，就是你如何做一个热力图。" class="headerlink" title="4、看你做过很多项目，你能描述制作cesium 热力图的逻辑步骤过程嘛，就是你如何做一个热力图。"></a>4、看你做过很多项目，你能描述制作cesium 热力图的逻辑步骤过程嘛，就是你如何做一个热力图。</h3><p><strong>简单回答</strong>：直接引入开源的Heatmap</p><p><strong>详细</strong>：</p><ul><li><p><strong>使用heatmap.js</strong>：首先，利用<code>heatmap.js</code>生成热力图的canvas图像。你需要将地理位置数据和权重值传递给<code>heatmap.js</code>，生成对应的热力图可视化。</p></li><li><p><strong>转换为Cesium材质</strong>：将<code>heatmap.js</code>生成的canvas转换为Cesium的材质，然后应用于一个覆盖整个地图的Primitive或Entity上。</p></li><li><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 假设你有数据 points = [&#123;lat: ..., lng: ..., value: ...&#125;, ...]</span><br><span class="line">let heatmapInstance = h337.create(&#123;</span><br><span class="line">    container: document.getElementById(&#x27;heatmapContainer&#x27;), // 这里需要替换为实际的容器</span><br><span class="line">    radius: 25,</span><br><span class="line">&#125;);</span><br><span class="line">heatmapInstance.setData(points);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、Cesium中如何实现不同精度DEM合并"><a href="#5、Cesium中如何实现不同精度DEM合并" class="headerlink" title="5、Cesium中如何实现不同精度DEM合并"></a>5、Cesium中如何实现不同精度DEM合并</h3><p><strong>简单：</strong>使用CesiumLab工具可以实现，它提供了图形界面来导入多个DEM文件，自动进行镶嵌、重采样和切片生成。</p><p><strong>详细：</strong></p><p>在Cesium中实现不同精度的DEM（数字高程模型）合并，通常涉及以下几个关键步骤，尤其是在离线状态下处理不同分辨率的DEM数据以保证模型能够正确贴地显示：</p><ol><li><strong>数据准备</strong>：<ul><li>收集所有需要合并的DEM数据，确保它们覆盖相同的地理区域，但可能具有不同的分辨率（如30m、90m等）。</li><li>将DEM数据转换为兼容的格式，如GeoTIFF，这是许多GIS工具和Cesium支持的标准格式。</li></ul></li><li><strong>DEM镶嵌与重采样</strong>：<ul><li>使用GIS工具（如ArcGIS, QGIS, GDAL等）进行镶嵌处理，将多个DEM数据集合并成一个连续的DEM。在这个过程中，可能需要对低分辨率DEM进行重采样以匹配最高分辨率DEM的网格系统和分辨率。</li><li>通过栅格镶嵌（Mosaic）和栅格重采样（Resampling）操作，可以将不同分辨率的DEM统一到相同的空间参考系和分辨率下，确保数据的一致性。</li></ul></li><li><strong>创建切片</strong>：<ul><li>利用工具（CesiumLab等）或自定义脚本，将合并后的高分辨率DEM切割成Cesium所需的瓦片格式（如Terrain Tiles）。</li></ul></li><li><strong>配置Cesium地形服务</strong>：<ul><li>将生成的瓦片数据部署到Web服务器上，并在Cesium应用中配置自定义地形服务。这通常涉及到修改Cesium Viewer或Scene的<code>terrainProvider</code>属性，指向你的自定义地形服务URL。</li></ul></li></ol><h3 id="6、有没有做过cesium添加PBS发布的服务‘"><a href="#6、有没有做过cesium添加PBS发布的服务‘" class="headerlink" title="6、有没有做过cesium添加PBS发布的服务‘"></a>6、有没有做过cesium添加PBS发布的服务‘</h3><p><strong>本人回答</strong>：<strong>没有</strong></p><p><strong>后期查询</strong>：具体操作看该文章：(<a href="https://www.cnblogs.com/GIScore/p/6047736.html">https://www.cnblogs.com/GIScore/p/6047736.html</a>)</p><p>​确保你的PBS服务器正常运行，并且已经成功发布了所需的地图服务。这通常涉及到使用Terrabuilder或其他工具制作MPT（Mobile Package Tile）格式的数据包，并配置PBS以提供这些数据。确认PBS提供的服务接口类型，常见的有WMS、WMTS或自定义的Tile服务。你需要知道服务的URL、图层名称、坐标系等信息，以便在Cesium中正确引用。</p><p>以上一些仅供参考。</p><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://telegraph-image-a7r.pages.dev/file/d22f645eeb107b36a98d0.jpg" alt="qrcode_for_gh_e879ec750214_258"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/3cf6ea2d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第四期）</title>
      <link>https://jhcgnb.cn/posts/fda46c66/</link>
      <guid>https://jhcgnb.cn/posts/fda46c66/</guid>
      <pubDate>Sun, 14 Jul 2024 03:18:33 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WebGIS面试题（第四期）&quot;&gt;&lt;a href=&quot;#WebGIS面试题（第四期）&quot; class=&quot;headerlink&quot; title=&quot;WebGIS面试题（第四期）&quot;&gt;&lt;/a&gt;WebGIS面试题（第四期）&lt;/h2&gt;&lt;p&gt;以下题目为中煤地质下属公司面试题，题目仅为部</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WebGIS面试题（第四期）"><a href="#WebGIS面试题（第四期）" class="headerlink" title="WebGIS面试题（第四期）"></a>WebGIS面试题（第四期）</h2><p>以下题目为中煤地质下属公司面试题，题目仅为部分题目，全部题目在公众号{GISer世界}，答案仅供参考</p><h3 id="1、详细说一下栅格瓦片和矢量瓦片的区别"><a href="#1、详细说一下栅格瓦片和矢量瓦片的区别" class="headerlink" title="1、详细说一下栅格瓦片和矢量瓦片的区别"></a>1、详细说一下栅格瓦片和矢量瓦片的区别</h3><p>栅格瓦片和矢量瓦片是两种不同类型的地图瓦片，它们在数据存储、处理方式和应用方面有一些显著的区别。</p><ol><li><p><strong>栅格瓦片</strong>：</p><ul><li><strong>数据类型</strong>：栅格瓦片使用栅格或像素的方式来表示地图数据。每个瓦片都是一个图像，通常是PNG或JPEG格式，包含了地图上的各种特征和信息。</li><li><strong>数据处理</strong>：栅格瓦片在制作过程中需要预先渲染地图图层，并将地图数据转换为图像。这些图像可以包含地图的各种样式、标注和特定的视觉效果。</li><li><strong>数据大小</strong>：由于栅格瓦片是图像，它们可能会占用较大的存储空间，尤其是在高分辨率下或者需要包含大量细节的地图。</li></ul></li><li><p><strong>矢量瓦片</strong>：</p><ul><li><strong>数据类型</strong>：矢量瓦片使用矢量数据格式来表示地图信息。矢量数据以几何对象（点、线、面等）和属性数据（例如名称、类别）的形式存储。</li><li><strong>数据处理</strong>：与栅格瓦片不同，矢量瓦片在制作过程中不需要事先渲染图像。它们包含了原始地图数据，并通过矢量绘图引擎动态渲染地图图层。</li><li><strong>数据大小</strong>：相比于栅格瓦片，矢量瓦片通常会更小，因为它们只包含地图的几何数据和属性，而不是像素化的图像数据。</li></ul></li><li><p><strong>应用方面</strong>：</p><ul><li><strong>栅格瓦片</strong>通常用于静态地图展示，尤其是对于需要高度定制化或特定样式的地图来说。它们适合于在离线环境中使用，或者在移动设备上显示地图。</li><li><strong>矢量瓦片</strong>更适用于需要动态地图渲染的场景，例如交互式地图应用程序。由于矢量瓦片可以在客户端动态绘制，因此它们可以根据用户的操作实现更灵活的地图交互和样式更改。</li></ul></li></ol><p>总的来说，栅格瓦片适合静态地图展示和高度定制化的场景，而矢量瓦片则更适合交互式地图应用和动态地图渲染的需求。</p><h3 id="2、84坐标上有一堆点，如何将这些点的坐标转为2000坐标"><a href="#2、84坐标上有一堆点，如何将这些点的坐标转为2000坐标" class="headerlink" title="2、84坐标上有一堆点，如何将这些点的坐标转为2000坐标"></a>2、84坐标上有一堆点，如何将这些点的坐标转为2000坐标</h3><p>要将一组点从84坐标系（通常指WGS 84坐标系，一种地理坐标系统）转换为2000坐标系（可能是其他地理坐标系统，比如CGCS2000或WGS 2000），你可以使用一些地理信息系统（GIS）软件或在线工具来完成。以下是一种可能的步骤：</p><ol><li><p><strong>准备数据</strong>：将84坐标系下的所有点的经度和纬度坐标记录下来。</p></li><li><p><strong>选择转换工具</strong>：使用地理信息系统软件（如ArcGIS、QGIS）或在线坐标转换服务。这些工具通常支持从一种地理坐标系转换到另一种。</p></li><li><p><strong>进行转换</strong>：在所选的工具中，选择从WGS 84到目标2000坐标系的转换选项。输入每个点的经度和纬度，并执行转换。</p></li><li><p><strong>验证结果</strong>：转换完成后，验证转换是否正确。确保转换后的坐标与目标2000坐标系的期望值一致。</p></li><li><p><strong>应用转换后的坐标</strong>：将转换后的2000坐标应用到你的应用程序或项目中。</p></li></ol><p>请注意，准确的转换需要使用正确的参数和算法，以确保转换的精度和准确性。</p><p>（[经纬度WGS84地理坐标系转换成CGCS2000坐标系步骤，必备！ - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/411828029#:~:text=1%E3%80%81">https://zhuanlan.zhihu.com/p/411828029#:~:text=1、</a> 将图层从奥维中导出成shp文件， 2、 打开arcgis-arcmap,3、地理处理-arctoolbox-数据管理工具-投影和变换-要素-投影 4、WGS84坐标转换为地理坐标系-world-ITRF2000 5、打开ArcCatalog ，找到上一步中已经成ITRF2000坐标系的shp文件，单击右键-属性，将图层坐标重新定义成GCGS2000地理坐标系)）</p><h3 id="3、Cesium中，飞机漫游初始状态的朝向"><a href="#3、Cesium中，飞机漫游初始状态的朝向" class="headerlink" title="3、Cesium中，飞机漫游初始状态的朝向"></a>3、Cesium中，飞机漫游初始状态的朝向</h3><p>在Cesium中，飞机漫游的初始状态朝向通常由飞行的方向决定。这可以通过设置飞机的位置和方向来实现。Cesium提供了几种方式来定义飞机的初始状态朝向：</p><ol><li><strong>使用方向向量</strong>：可以指定一个方向向量，表示飞机的初始朝向。在Cesium中，这可以通过设置飞机的朝向（heading）、俯仰（pitch）和滚转（roll）来实现。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置飞机的位置</span></span><br><span class="line"><span class="keyword">var</span> position = <span class="title class_">Cesium</span>.<span class="property">Cartesian3</span>.<span class="title function_">fromDegrees</span>(longitude, latitude, altitude);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置飞机的朝向</span></span><br><span class="line"><span class="keyword">var</span> heading = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(headingDegrees); <span class="comment">// 将角度转换为弧度</span></span><br><span class="line"><span class="keyword">var</span> pitch = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(pitchDegrees);</span><br><span class="line"><span class="keyword">var</span> roll = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(rollDegrees);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orientation = <span class="title class_">Cesium</span>.<span class="property">Transforms</span>.<span class="title function_">headingPitchRollQuaternion</span>(position, <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">HeadingPitchRoll</span>(heading, pitch, roll));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建飞机实体</span></span><br><span class="line"><span class="keyword">var</span> airplaneEntity = viewer.<span class="property">entities</span>.<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="attr">position</span>: position,</span><br><span class="line">    <span class="attr">orientation</span>: orientation,</span><br><span class="line">    <span class="attr">model</span>: &#123;</span><br><span class="line">        <span class="attr">uri</span>: <span class="string">&#x27;path/to/airplane.glb&#x27;</span>, <span class="comment">// 飞机模型文件路径</span></span><br><span class="line">        <span class="attr">scale</span>: <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用航迹</strong>：如果已经有飞机的航迹数据，可以直接使用航迹数据中的方向信息来设置飞机的初始朝向。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用航迹数据设置飞机的位置和方向</span></span><br><span class="line"><span class="keyword">var</span> position = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">SampledPositionProperty</span>();</span><br><span class="line"><span class="keyword">var</span> orientation = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">SampledProperty</span>(<span class="title class_">Cesium</span>.<span class="property">Quaternion</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加航迹数据点</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建飞机实体</span></span><br><span class="line"><span class="keyword">var</span> airplaneEntity = viewer.<span class="property">entities</span>.<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="attr">position</span>: position,</span><br><span class="line">    <span class="attr">orientation</span>: orientation,</span><br><span class="line">    <span class="attr">model</span>: &#123;</span><br><span class="line">        <span class="attr">uri</span>: <span class="string">&#x27;path/to/airplane.glb&#x27;</span>, <span class="comment">// 飞机模型文件路径</span></span><br><span class="line">        <span class="attr">scale</span>: <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>无论选择哪种方式，都可以根据飞机的位置和方向来定义飞机漫游的初始状态朝向。</p><h3 id="4、V-if和v-show的区别"><a href="#4、V-if和v-show的区别" class="headerlink" title="4、V-if和v-show的区别"></a>4、V-if和v-show的区别</h3><p>在Vue.js中，<code>v-if</code>和<code>v-show</code>都是用于条件性地显示或隐藏DOM元素的指令，但它们有一些重要的区别：</p><ol><li><p><strong>渲染方式</strong>：</p><ul><li><code>v-if</code>：当表达式为真（true）时，条件块内的元素才会被创建并插入到DOM中，当表达式为假（false）时，条件块内的元素将被从DOM中移除。因此，<code>v-if</code>在切换时是“真正的”条件渲染，会在DOM中销毁和重新创建元素。</li><li><code>v-show</code>：无论表达式的值是真还是假，元素始终会被渲染到DOM中，只是通过CSS的<code>display</code>属性控制元素的显示与隐藏。因此，<code>v-show</code>不会销毁和重新创建元素，只是简单地在页面上切换元素的显示状态。</li></ul></li><li><p><strong>性能影响</strong>：</p><ul><li><code>v-if</code>：由于在条件不满足时会销毁和重新创建DOM元素，因此适合在需要频繁切换的场景中使用，但会有一定的性能开销。</li><li><code>v-show</code>：由于元素始终保持在DOM中，只是通过CSS进行显示和隐藏，因此在频繁切换时不会有额外的DOM操作，性能开销较小。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li><code>v-if</code>：适用于需要在条件满足时完全渲染新的DOM结构的场景，或者需要在条件不满足时销毁DOM结构以减少内存占用的场景。</li><li><code>v-show</code>：适用于需要频繁切换显示状态，但不需要频繁重新渲染DOM结构的场景。</li></ul></li></ol><p>因此，在选择使用<code>v-if</code>还是<code>v-show</code>时，需要根据具体的情况来考虑渲染性能和页面交互的需求。</p><h3 id="5、解释下深拷贝和浅拷贝"><a href="#5、解释下深拷贝和浅拷贝" class="headerlink" title="5、解释下深拷贝和浅拷贝"></a>5、解释下深拷贝和浅拷贝</h3><p>深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在编程中常见的两种拷贝数据的方法，它们的区别在于拷贝的深度和原始数据结构内部的拷贝方式。</p><h4 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h4><p>浅拷贝是指创建一个新的数据结构，其中包含了原始数据结构中的所有元素的引用（或者是简单的值拷贝）。换句话说，浅拷贝只是复制了原始数据结构的顶层结构，而没有递归地复制内部的元素。</p><p>示例（JavaScript）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> originalArray = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> shallowCopyArray = originalArray.<span class="title function_">slice</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始数组的第二层元素</span></span><br><span class="line">originalArray[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;modified&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalArray); <span class="comment">// 输出：[1, 2, [&#x27;modified&#x27;, 4]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(shallowCopyArray); <span class="comment">// 输出：[1, 2, [&#x27;modified&#x27;, 4]]</span></span><br></pre></td></tr></table></figure><p>在这个示例中，虽然修改了原始数组中的第二层元素，但由于浅拷贝只是复制了引用，因此修改会同时反映在浅拷贝的数组中。</p><h4 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h4><p>深拷贝是指创建一个新的数据结构，并且递归地复制原始数据结构中的所有元素，包括所有的嵌套层级。换句话说，深拷贝会创建一个完全独立于原始数据结构的新结构，修改新结构中的任何元素都不会影响原始数据结构。</p><p>示例（JavaScript，使用Lodash库）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> originalArray = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">let</span> deepCopyArray = _.<span class="title function_">cloneDeep</span>(originalArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始数组的第二层元素</span></span><br><span class="line">originalArray[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;modified&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalArray); <span class="comment">// 输出：[1, 2, [&#x27;modified&#x27;, 4]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deepCopyArray); <span class="comment">// 输出：[1, 2, [3, 4]]</span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用了Lodash库提供的<code>cloneDeep</code>函数进行深拷贝，因此修改原始数组的第二层元素不会影响到深拷贝的数组。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>浅拷贝只复制了原始数据结构的顶层结构，内部元素仍然是引用，因此修改内部元素会影响到其他拷贝。</li><li>深拷贝递归地复制了原始数据结构的所有层级，创建了一个完全独立的新数据结构，因此修改新数据结构中的任何元素都不会影响到原始数据结构。</li></ul><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/fda46c66/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第三期）</title>
      <link>https://jhcgnb.cn/posts/6d679077/</link>
      <guid>https://jhcgnb.cn/posts/6d679077/</guid>
      <pubDate>Sun, 14 Jul 2024 03:18:21 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WebGIS面试题（第三期）（某公司）上机笔试题&quot;&gt;&lt;a href=&quot;#WebGIS面试题（第三期）（某公司）上机笔试题&quot; class=&quot;headerlink&quot; title=&quot;WebGIS面试题（第三期）（某公司）上机笔试题&quot;&gt;&lt;/a&gt;WebGIS面试题（第三期）</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WebGIS面试题（第三期）（某公司）上机笔试题"><a href="#WebGIS面试题（第三期）（某公司）上机笔试题" class="headerlink" title="WebGIS面试题（第三期）（某公司）上机笔试题"></a>WebGIS面试题（第三期）（某公司）上机笔试题</h2><p>以下题目为南京某公司上机笔试题，题目仅为部分题目，全部题目在公众号{GISer世界}，答案仅供参考，需要电子版在公众号{GISer世界}内回复“面试题3”获取PDF版本！！！</p><h3 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h3><h5 id="1、在java中，ByteMAXVALUE的二进制表示形式是"><a href="#1、在java中，ByteMAXVALUE的二进制表示形式是" class="headerlink" title="1、在java中，ByteMAXVALUE的二进制表示形式是"></a>1、在java中，ByteMAXVALUE的二进制表示形式是</h5><ul><li><p><input disabled="" type="checkbox"> A 11111111</p></li><li><p><input disabled="" type="checkbox"> B 1000000</p></li><li><p><input disabled="" type="checkbox"> C 以上都不对</p></li><li><p><input checked="" disabled="" type="checkbox"> D 01111111</p><p>在Java中，<code>Byte.MAX_VALUE</code> 表示一个 <code>byte</code> 数据类型的最大值，其值为 127。其二进制表示形式是 <code>01111111</code>，因此正确答案是：</p><p>D. 01111111</p></li></ul><h5 id="2、GeOJSON格式，支持的Geomnetry类型不包括以下哪种"><a href="#2、GeOJSON格式，支持的Geomnetry类型不包括以下哪种" class="headerlink" title="2、GeOJSON格式，支持的Geomnetry类型不包括以下哪种"></a>2、GeOJSON格式，支持的Geomnetry类型不包括以下哪种</h5><ul><li><p><input disabled="" type="checkbox"> A LineString</p></li><li><p><input disabled="" type="checkbox"> B Polygon</p></li><li><p><input checked="" disabled="" type="checkbox"> C Polyline</p></li><li><p><input disabled="" type="checkbox"> D Point</p><p>GeoJSON 格式支持的 Geometry 类型包括：</p><p>A. LineString<br>B. Polygon<br>D. Point</p><p>GeoJSON 不支持 “Polyline” 这个类型，因此正确答案是：</p><p>C. Polyline</p></li></ul><h5 id="3、以下代码片段的空白处，应该分别填入什么内容可使得代码片段通过编泽"><a href="#3、以下代码片段的空白处，应该分别填入什么内容可使得代码片段通过编泽" class="headerlink" title="3、以下代码片段的空白处，应该分别填入什么内容可使得代码片段通过编泽?"></a>3、以下代码片段的空白处，应该分别填入什么内容可使得代码片段通过编泽?</h5><p>public vold process()Exception {</p><p>Exception0);</p><p>}</p><ul><li><p><input disabled="" type="checkbox"> A throws    throws new</p></li><li><p><input checked="" disabled="" type="checkbox"> B throws    throw new</p></li><li><p><input disabled="" type="checkbox"> C throw      throws new</p></li><li><p><input disabled="" type="checkbox"> D throw      throw new</p><p>在给定的代码片段中，你需要填入异常处理代码以使其通过编译。正确的选项是 B：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>process</code> 方法声明了它可能抛出一个 <code>Exception</code> 异常，并在方法体中使用 <code>throw</code> 语句抛出了一个新的 <code>Exception</code> 异常。</p></li></ul><h5 id="4、使用SQL语句进行分组检索时，为了去掉不满足条件的分组，应该集么处理"><a href="#4、使用SQL语句进行分组检索时，为了去掉不满足条件的分组，应该集么处理" class="headerlink" title="4、使用SQL语句进行分组检索时，为了去掉不满足条件的分组，应该集么处理?"></a>4、使用SQL语句进行分组检索时，为了去掉不满足条件的分组，应该集么处理?</h5><ul><li><p><input checked="" disabled="" type="checkbox"> A 在GROUPBY后面使用HAVING子句</p></li><li><p><input disabled="" type="checkbox"> B 先使用WHERE子句，再使用HAVING子包</p></li><li><p><input disabled="" type="checkbox"> C 先使用HAVING字句，再使用WHERE子句</p></li><li><p><input disabled="" type="checkbox"> D 使用WHERE子句</p><p>为了去掉不满足条件的分组，你应该在 SQL 查询中使用 HAVING 子句。正确答案是：</p><p>A. 在 GROUP BY 后面使用 HAVING 子句</p><p>HAVING 子句用于筛选已经分组的数据，而 WHERE 子句用于筛选未分组的数据。因此，如果你想在分组后筛选分组，应该使用 HAVING 子句。</p></li></ul><h5 id="5、WMS服务提供的接口中，用于获取地瘤服务图层民张教据地是"><a href="#5、WMS服务提供的接口中，用于获取地瘤服务图层民张教据地是" class="headerlink" title="5、WMS服务提供的接口中，用于获取地瘤服务图层民张教据地是?"></a>5、WMS服务提供的接口中，用于获取地瘤服务图层民张教据地是?</h5><ul><li><p><input checked="" disabled="" type="checkbox"> A GetFeatureInfo</p></li><li><p><input disabled="" type="checkbox"> B GetCapabilities</p></li><li><p><input disabled="" type="checkbox"> C GetLegendGraphic</p></li><li><p><input disabled="" type="checkbox"> D GetMap</p><p>WMS（Web Map Service）服务提供了多个接口来满足不同的地图服务需求。用于获取地图图层的元数据信息的接口是 “GetCapabilities”，而用于获取地图图层上的特定位置信息的接口是 “GetFeatureInfo”。</p><p>所以，答案是：</p><p>A. GetFeatureInfo</p></li></ul><h5 id="6、以下的代码片段，违反了SOLID设计原则中的哪一条原则"><a href="#6、以下的代码片段，违反了SOLID设计原则中的哪一条原则" class="headerlink" title="6、以下的代码片段，违反了SOLID设计原则中的哪一条原则"></a>6、以下的代码片段，违反了SOLID设计原则中的哪一条原则</h5><p>package java sql；<br>public class Date extends java.util Date (@Override<br>public Instant tolnstant() {<br>throw new java.lang.UnsupportedOperationException();</p><p>}</p><p>}</p><ul><li><p><input disabled="" type="checkbox"> A 开放闭合原则</p></li><li><p><input checked="" disabled="" type="checkbox"> B 里氏替换原则</p></li><li><p><input disabled="" type="checkbox"> C 接口隔离原则</p></li><li><p><input disabled="" type="checkbox"> D 单一职责原则</p><p>给定的代码片段违反了里氏替换原则（Liskov Substitution Principle）。</p><p>里氏替换原则要求子类必须能够替换其基类而不改变程序的正确性。在这里，你的代码片段尝试继承 <code>java.util.Date</code> 类并覆盖了 <code>toInstant</code> 方法，但在方法体内抛出了 <code>java.lang.UnsupportedOperationException</code> 异常。这违反了里氏替换原则，因为它改变了基类的预期行为，而不是正确地实现了基类的方法。</p><p>所以，答案是：</p><p>B. 里氏替换原则</p></li></ul><h5 id="7、下列哪个选项是es6中用于声明变量的关键字"><a href="#7、下列哪个选项是es6中用于声明变量的关键字" class="headerlink" title="7、下列哪个选项是es6中用于声明变量的关键字?"></a>7、下列哪个选项是es6中用于声明变量的关键字?</h5><ul><li><p><input disabled="" type="checkbox"> A let</p></li><li><p><input disabled="" type="checkbox"> B const</p></li><li><p><input checked="" disabled="" type="checkbox"> C 以上都对</p></li><li><p><input disabled="" type="checkbox"> D var</p><p>在 ECMAScript 6（ES6）中，用于声明变量的关键字有：</p><p>A. let<br>B. const</p><p>所以正确答案是：</p><p>C. 以上都对</p><p>ES6 引入了 <code>let</code> 和 <code>const</code> 关键字，用于声明变量，相较于之前的 <code>var</code> 关键字，它们提供了更好的变量作用域控制和不可变性选项。</p></li></ul><h5 id="8、”A-cass-should-have-only-one-reason-to-change”。这话常用于SOUD设计原则中的那条原则？"><a href="#8、”A-cass-should-have-only-one-reason-to-change”。这话常用于SOUD设计原则中的那条原则？" class="headerlink" title="8、”A cass should have only one reason to change”。这话常用于SOUD设计原则中的那条原则？"></a>8、”A cass should have only one reason to change”。这话常用于SOUD设计原则中的那条原则？</h5><ul><li><p><input disabled="" type="checkbox"> A 开放闭合原则</p></li><li><p><input disabled="" type="checkbox"> B 依赖倒置原则</p></li><li><p><input disabled="" type="checkbox"> C 接口隔离原则</p></li><li><p><input checked="" disabled="" type="checkbox"> D 单一职责原则</p><p>“A class should have only one reason to change” 这句话通常用于单一职责原则（Single Responsibility Principle）中。因此，正确答案是：</p><p>D. 单一职责原则</p><p>单一职责原则要求一个类应该只有一个引起它变化的原因，即它应该具有单一的责任。</p></li></ul><h5 id="9、下列哪个方法可以将多个数组合并为一个数组"><a href="#9、下列哪个方法可以将多个数组合并为一个数组" class="headerlink" title="9、下列哪个方法可以将多个数组合并为一个数组?"></a>9、下列哪个方法可以将多个数组合并为一个数组?</h5><ul><li><input disabled="" type="checkbox"> A splice</li><li><input disabled="" type="checkbox"> B reverse</li><li><input disabled="" type="checkbox"> C shift</li><li><input checked="" disabled="" type="checkbox"> D concat</li></ul><h5 id="10、以下哪项，不是es6提供的新功能"><a href="#10、以下哪项，不是es6提供的新功能" class="headerlink" title="10、以下哪项，不是es6提供的新功能?"></a>10、以下哪项，不是es6提供的新功能?</h5><ul><li><p><input disabled="" type="checkbox"> A  类</p></li><li><p><input checked="" disabled="" type="checkbox"> B 函数表达式</p></li><li><p><input disabled="" type="checkbox"> C 箭头函数</p></li><li><p><input disabled="" type="checkbox"> D 模块</p><p>方法可以将多个数组合并为一个数组是：</p><p>D. concat</p><p><code>concat</code> 方法用于连接两个或多个数组，并返回一个新数组，其中包含了所有连接的数组元素。这允许你将多个数组合并成一个大数组。</p></li></ul><h5 id="11、关于es6的Class，以下说法错误的是？"><a href="#11、关于es6的Class，以下说法错误的是？" class="headerlink" title="11、关于es6的Class，以下说法错误的是？"></a>11、关于es6的Class，以下说法错误的是？</h5><ul><li><p><input disabled="" type="checkbox"> A 在Class中，通过类的名称来访问静态成员</p></li><li><p><input checked="" disabled="" type="checkbox"> B 在子类的构造方法中，可以在任意位置调用父类的构造函</p></li><li><p><input disabled="" type="checkbox"> C es6的class支持创建访问器属性</p></li><li><p><input disabled="" type="checkbox"> D 可在类中使用static关键字，定义静态成员</p><p>ES6（ECMAScript 2015）引入了许多新功能，但其中的一个选项不是新功能。这个选项是：</p><p>B. 函数表达式</p><p>函数表达式不是 ES6 新引入的功能，它在之前的 JavaScript 版本中就已经存在。ES6 引入了类（A）、箭头函数（C）和模块（D）等新功能，但函数表达式是 JavaScript 的基本功能，不属于 ES6 特定的新增内容。</p></li></ul><h5 id="12、数据库事务ACID特性，其中A表示"><a href="#12、数据库事务ACID特性，其中A表示" class="headerlink" title="12、数据库事务ACID特性，其中A表示?"></a>12、数据库事务ACID特性，其中A表示?</h5><ul><li><p><input disabled="" type="checkbox"> A 隔离性</p></li><li><p><input disabled="" type="checkbox"> B 一致性</p></li><li><p><input disabled="" type="checkbox"> C 持久性</p></li><li><p><input checked="" disabled="" type="checkbox"> D 原子性</p><p>以下说法是错误的：</p><p>B. 在子类的构造方法中，可以在任意位置调用父类的构造函数</p><p>在 ES6 的类中，如果子类的构造函数中希望调用父类的构造函数，应该在构造函数的开头使用 <code>super()</code> 调用父类的构造函数。在构造函数的其他位置调用 <code>super()</code> 会导致错误。</p></li></ul><h3 id="二、简答题："><a href="#二、简答题：" class="headerlink" title="二、简答题："></a>二、简答题：</h3><h5 id="17、有以下几张表学生表Student-sid-varchar-10-sname-varchar-10-，课程表Course-cid-varchar-10-cname-varchar-10-，成绩表SC-sid-varchar-10-cid-varchar-10-scoredecimal-18-1-。其中，sid为学号-sname为学生姓名、cid为课程号cname为课程名、score为考试成绩。请编写SQL语句，查询至少有两个学生考试成绩的课程的课程号和该课程的最高成绩。"><a href="#17、有以下几张表学生表Student-sid-varchar-10-sname-varchar-10-，课程表Course-cid-varchar-10-cname-varchar-10-，成绩表SC-sid-varchar-10-cid-varchar-10-scoredecimal-18-1-。其中，sid为学号-sname为学生姓名、cid为课程号cname为课程名、score为考试成绩。请编写SQL语句，查询至少有两个学生考试成绩的课程的课程号和该课程的最高成绩。" class="headerlink" title="17、有以下几张表学生表Student(sid varchar(10)sname varchar(10))，课程表Course(cid varchar(10),cname varchar(10)，成绩表SC(sid varchar(10)cid varchar(10)scoredecimal(18,1))。其中，sid为学号.sname为学生姓名、cid为课程号cname为课程名、score为考试成绩。请编写SQL语句，查询至少有两个学生考试成绩的课程的课程号和该课程的最高成绩。"></a>17、有以下几张表学生表Student(sid varchar(10)sname varchar(10))，课程表Course(cid varchar(10),cname varchar(10)，成绩表SC(sid varchar(10)cid varchar(10)scoredecimal(18,1))。其中，sid为学号.sname为学生姓名、cid为课程号cname为课程名、score为考试成绩。请编写SQL语句，查询至少有两个学生考试成绩的课程的课程号和该课程的最高成绩。</h5><p>答：</p><p>你可以使用 SQL 查询来找到至少有两个学生考试成绩的课程的课程号和该课程的最高成绩。以下是 SQL 查询的示例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.cid <span class="keyword">AS</span> 课程号, <span class="built_in">MAX</span>(sc.score) <span class="keyword">AS</span> 最高成绩</span><br><span class="line"><span class="keyword">FROM</span> Course c</span><br><span class="line"><span class="keyword">JOIN</span> SC sc <span class="keyword">ON</span> c.cid <span class="operator">=</span> sc.cid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.cid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(sc.sid) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这个查询会联接课程表（Course）和成绩表（SC），然后按课程号（cid）分组。通过 HAVING 子句，筛选出至少有两个学生考试成绩的课程，并计算每个课程的最高成绩。</p><h5 id="18、Web-Mercator投影以赤道为标准结线以本初子午线为中央经线，两者交汇处为坐标原点。其覆盖的经度范围为-180-1801，已知赤道半径为6378137米，计算Web-Mercator投影x坐标的覆盖范围。"><a href="#18、Web-Mercator投影以赤道为标准结线以本初子午线为中央经线，两者交汇处为坐标原点。其覆盖的经度范围为-180-1801，已知赤道半径为6378137米，计算Web-Mercator投影x坐标的覆盖范围。" class="headerlink" title="18、Web Mercator投影以赤道为标准结线以本初子午线为中央经线，两者交汇处为坐标原点。其覆盖的经度范围为[-180.1801，已知赤道半径为6378137米，计算Web Mercator投影x坐标的覆盖范围。"></a>18、Web Mercator投影以赤道为标准结线以本初子午线为中央经线，两者交汇处为坐标原点。其覆盖的经度范围为[-180.1801，已知赤道半径为6378137米，计算Web Mercator投影x坐标的覆盖范围。</h5><p>Web Mercator 投影将地球表面的经度和纬度坐标映射到平面坐标系，通常使用经度范围从 -180 度到 180 度。在 Web Mercator 投影中，横坐标 (X) 的取值范围通常被规定为从 -20037508.34 米到 20037508.34 米。这个范围是由赤道半径和π（圆周率）以及一些调整因子计算得出的。</p><p>答：</p><p>Web Mercator 投影的 X 坐标范围是由以下公式计算得出：</p><p>X_min &#x3D; -R * π<br>X_max &#x3D; R * π</p><p>其中，R 为赤道半径，即 6378137 米。</p><p>计算 X 坐标范围：</p><p>X_min &#x3D; -6378137 * π ≈ -20037508.34 米<br>X_max &#x3D; 6378137 * π ≈ 20037508.34 米</p><p>所以 Web Mercator 投影的 X 坐标范围为大约 -20037508.34 米到 20037508.34 米。</p><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/6d679077/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第二期）</title>
      <link>https://jhcgnb.cn/posts/7d7ab8ad/</link>
      <guid>https://jhcgnb.cn/posts/7d7ab8ad/</guid>
      <pubDate>Sun, 14 Jul 2024 02:48:42 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h4&gt;&lt;p&gt;近期看到好多小伙伴在寻找WebGIS方面的面试题，正好本人之前也因自己面试分享过一些面试题，秋招目前逐步也快结束了，所以我现</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>近期看到好多小伙伴在寻找WebGIS方面的面试题，正好本人之前也因自己面试分享过一些面试题，秋招目前逐步也快结束了，所以我现在慢慢整理一些包括自己面试以及网上公开的一些我认为有用的面试题，仅供参考，大多面试主要会围绕你自己简历上的项目以及其他进行展开提问，所以说自己的简历才是最重要的。以下内容作为辅助。（本期为第二期分享。第一期分享：<a href="https://blog.csdn.net/weixin_44857463/article/details/133197256">WebGIS面试（中海达）</a>）</p><h4 id="二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）"><a href="#二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）" class="headerlink" title="二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）"></a>二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）</h4><p>注意webgis面试不一定只问一些GIS相关的，还会提问众多技术相关问题；本人的答案也不一定正确，仅供参考！！！</p><h5 id="1、说一说路由生命周期（也叫导航守卫）"><a href="#1、说一说路由生命周期（也叫导航守卫）" class="headerlink" title="1、说一说路由生命周期（也叫导航守卫）"></a>1、说一说<strong>路由生命周期（也叫导航守卫）</strong></h5><p>路由生命周期，也叫导航守卫，是指在前端Web应用中，控制路由的跳转和导航过程中的一系列事件和钩子函数，用于实现路由的权限控制、数据加载、页面渲染等操作。这些生命周期事件和钩子函数可以根据需要在路由跳转前、跳转时、跳转后执行不同的操作，以确保应用的正确运行和用户体验。</p><p>在Vue.js和Vue Router中，通常有三种导航守卫：</p><ol><li><p><strong>全局前置守卫</strong>：这些守卫会在路由跳转之前触发，允许你执行一些全局的操作，比如权限检查、全局数据加载等。常见的全局前置守卫包括<code>beforeEach</code>。</p></li><li><p><strong>路由独享的守卫</strong>：这些守卫是路由配置中独立于全局守卫的守卫，它们会在特定路由跳转时触发。常见的路由独享守卫包括<code>beforeEnter</code>。</p></li><li><p><strong>全局后置守卫</strong>：这些守卫会在路由跳转完成后触发，允许你执行一些全局的操作，比如页面统计、日志记录等。常见的全局后置守卫包括<code>afterEach</code>。</p></li></ol><p>以下是这些守卫的主要用途和执行时机：</p><ul><li><p><strong>beforeEach</strong>：在路由跳转前执行，通常用于权限控制和全局数据加载。如果在<code>beforeEach</code>中返回<code>false</code>，则路由跳转将被中止。</p></li><li><p><strong>beforeEnter</strong>：在路由配置中独享的守卫，用于特定路由的权限控制和数据加载。</p></li><li><p><strong>afterEach</strong>：在路由跳转完成后执行，通常用于页面切换动画、页面统计等全局操作。</p></li></ul><p>此外，还有一些其他的路由守卫，比如：</p><ul><li><p><strong>beforeResolve</strong>：在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后触发。</p></li><li><p><strong>beforeRouteEnter</strong>：在路由进入前触发，但无法访问组件实例，通常用于异步路由组件。</p></li><li><p><strong>beforeRouteUpdate</strong>：在当前路由改变，但路由参数未改变时触发，用于复用组件。</p></li><li><p><strong>beforeRouteLeave</strong>：在路由离开前触发，通常用于确认离开或取消导航。</p></li></ul><p>这些守卫可以在Vue Router的路由配置中使用，以便更好地控制前端应用的路由导航和行为。根据具体需求，你可以选择使用不同的守卫来实现路由的各种功能，如权限控制、数据加载、页面切换动画等。</p><h5 id="2、关于你在简历中提到的项目-都使用了那些技术栈来进行开发"><a href="#2、关于你在简历中提到的项目-都使用了那些技术栈来进行开发" class="headerlink" title="2、关于你在简历中提到的项目,都使用了那些技术栈来进行开发?"></a>2、关于你在简历中提到的项目,都使用了那些技术栈来进行开发?</h5><p>这个需要结合自己擅长的技术栈以及以及自己的简历。</p><h5 id="3、说一下天地图这个服务是什么格式的类型-具体是怎样加载出来的"><a href="#3、说一下天地图这个服务是什么格式的类型-具体是怎样加载出来的" class="headerlink" title="3、说一下天地图这个服务是什么格式的类型,具体是怎样加载出来的?"></a>3、说一下天地图这个服务是什么格式的类型,具体是怎样加载出来的?</h5><p>“天地图”是中国国家测绘局（National Administration of Surveying, Mapping, and Geoinformation）推出的一套在线地图服务，提供了中国地图的相关数据。这些地图数据通常以标准的Web地图瓦片格式提供，常见的格式包括瓦片图层（Tile Layers）和矢量图层（Vector Layers）。</p><ol><li><p><strong>瓦片图层（Tile Layers）</strong>：这是最常见的地图数据加载方式，天地图提供了标准的瓦片图层，以瓦片（tiles）的形式分割地图，每个瓦片包含一小块地图数据，通常是图片格式，如PNG。你可以通过URL获取这些瓦片并将它们加载到地图上，以显示地图数据。通常，这些URL包括瓦片的x、y坐标和缩放级别，以确保你获取到正确的地图数据。</p></li><li><p><strong>矢量图层（Vector Layers）</strong>：除了瓦片地图，天地图还提供一些矢量地图数据，通常以矢量图层的形式提供。这些数据可以是GeoJSON、KML、WMS等格式。你可以使用前端地图库（如Leaflet、OpenLayers、Mapbox等）加载这些矢量数据，并在地图上绘制要素，如道路、河流、建筑物等。</p></li></ol><p>加载天地图服务通常需要以下步骤：</p><ol><li><p><strong>获取访问权限</strong>：首先，你需要获取访问天地图服务的权限，通常需要在天地图官方网站注册并获取API密钥或访问令牌。</p></li><li><p><strong>选择地图类型</strong>：天地图提供了多种地图类型，如卫星地图、道路地图、地形地图等。根据你的需求选择适合的地图类型。</p></li><li><p><strong>加载地图库</strong>：使用前端地图库，如Leaflet、OpenLayers等，加载地图。你需要在你的网页中引入相应的地图库文件，并创建一个地图容器。</p></li><li><p><strong>添加图层</strong>：根据你的选择，添加天地图的瓦片图层或矢量图层到地图上。如果是瓦片地图，你需要设置天地图瓦片服务的URL，包括x、y坐标和缩放级别。如果是矢量地图，你需要加载相应的矢量数据。</p></li><li><p><strong>设置地图视图</strong>：根据你的需求，设置地图的初始中心点和缩放级别，以及其他交互行为，如缩放、拖动等。</p></li><li><p><strong>处理用户交互</strong>：根据需要，添加交互控件，如放大缩小按钮、信息弹出框等，以增强用户体验。</p></li><li><p><strong>部署到网页</strong>：将配置好的地图应用嵌入到你的网页中，用户可以通过浏览器访问并与地图进行交互。</p></li></ol><p>天地图服务提供了中国地图数据，可以通过瓦片图层或矢量图层的形式加载到前端地图库中，以在网页中显示地图数据并提供交互功能。</p><h5 id="4、在-openLayers-中如何加载-WMTS-服务"><a href="#4、在-openLayers-中如何加载-WMTS-服务" class="headerlink" title="4、在 openLayers 中如何加载 WMTS 服务?"></a>4、在 openLayers 中如何加载 WMTS 服务?</h5><p>在 OpenLayers 中加载WMTS（Web Map Tile Service）服务涉及一系列步骤，包括设置图层、创建地图、配置WMTS图层和视图。<strong>面试可简单回答：</strong></p><ol><li><strong>创建地图容器</strong>：首先，需要在HTML中创建一个<code>&lt;div&gt;</code>容器，用于显示地图。</li><li><strong>初始化地图对象</strong>：使用OpenLayers，初始化一个地图对象，并指定地图的目标容器。</li><li><strong>配置WMTS图层</strong>：设置WMTS图层的参数，包括服务URL、图层名称、图像格式、投影、瓦片网格等。确保提供正确的URL和其他相关信息。</li><li><strong>创建WMTS图层</strong>：基于配置的WMTS源，创建一个WMTS图层。</li><li><strong>将图层添加到地图</strong>：将WMTS图层添加到地图对象中，以便在地图上显示相关地图数据。</li><li><strong>设置地图视图</strong>：配置地图的初始视图，包括中心点和缩放级别。确保投影和坐标系设置正确。</li><li><strong>加载地图</strong>：确保地图被成功加载到页面中，可以添加额外的交互控件，如缩放按钮。</li></ol><p>强调在步骤3中需要注意WMTS图层的配置，包括URL、图层名称、图像格式、投影、瓦片网格等，这些是加载WMTS服务的关键参数。</p><p><strong>以下是详细的介绍，</strong></p><ol><li><strong>引入 OpenLayers 库</strong>：首先，确保你在网页中引入了OpenLayers库的JavaScript文件。你可以从OpenLayers的官方网站下载最新版本的库文件并在HTML中引入。</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/ol@6.10.1/dist/ol.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建地图容器</strong>：在HTML中创建一个用于显示地图的<code>&lt;div&gt;</code>容器。</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;map&quot;</span> <span class="attr">class</span>=<span class="string">&quot;map&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>初始化地图对象</strong>：在JavaScript中，初始化OpenLayers地图对象，并指定地图的目标容器。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> ol.<span class="title class_">Map</span>(&#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;map&#x27;</span>, <span class="comment">// 这里的&#x27;map&#x27;是你创建的地图容器的ID</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>配置WMTS图层</strong>：设置WMTS图层的相关参数，包括图层来源（source）、投影（projection）、瓦片网格（tile grid）等。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建WMTS源</span></span><br><span class="line"><span class="keyword">var</span> wmtsSource = <span class="keyword">new</span> ol.<span class="property">source</span>.<span class="title function_">WMTS</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://your-wmts-service-url.com&#x27;</span>, <span class="comment">// 替换为你的WMTS服务URL</span></span><br><span class="line">  <span class="attr">layer</span>: <span class="string">&#x27;your-wmts-layer&#x27;</span>, <span class="comment">// 替换为你的WMTS图层名</span></span><br><span class="line">  <span class="attr">format</span>: <span class="string">&#x27;image/png&#x27;</span>, <span class="comment">// 图像格式，根据服务配置</span></span><br><span class="line">  <span class="attr">matrixSet</span>: <span class="string">&#x27;your-matrix-set&#x27;</span>, <span class="comment">// 替换为你的矩阵集</span></span><br><span class="line">  <span class="attr">projection</span>: <span class="string">&#x27;EPSG:4326&#x27;</span>, <span class="comment">// 替换为你的投影</span></span><br><span class="line">  <span class="attr">tileGrid</span>: <span class="keyword">new</span> ol.<span class="property">tilegrid</span>.<span class="title function_">WMTS</span>(&#123;</span><br><span class="line">    <span class="attr">origin</span>: [-<span class="number">180</span>, <span class="number">90</span>], <span class="comment">// 瓦片网格的原点</span></span><br><span class="line">    <span class="attr">resolutions</span>: [<span class="number">0.703125</span>, <span class="number">0.3515625</span>, <span class="number">0.17578125</span>, ...], <span class="comment">// 分辨率数组，根据服务配置</span></span><br><span class="line">    <span class="attr">matrixIds</span>: [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, ...], <span class="comment">// 矩阵ID数组，根据服务配置</span></span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建WMTS图层</span></span><br><span class="line"><span class="keyword">var</span> wmtsLayer = <span class="keyword">new</span> ol.<span class="property">layer</span>.<span class="title class_">Tile</span>(&#123;</span><br><span class="line">  <span class="attr">source</span>: wmtsSource,</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>添加图层到地图</strong>：将创建的WMTS图层添加到地图对象中。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.<span class="title function_">addLayer</span>(wmtsLayer);</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>设置地图视图</strong>：配置地图的初始视图，包括中心点、缩放级别等。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> view = <span class="keyword">new</span> ol.<span class="title class_">View</span>(&#123;</span><br><span class="line">  <span class="attr">center</span>: [<span class="number">0</span>, <span class="number">0</span>], <span class="comment">// 中心点坐标</span></span><br><span class="line">  <span class="attr">zoom</span>: <span class="number">2</span>, <span class="comment">// 初始缩放级别</span></span><br><span class="line">  <span class="attr">projection</span>: <span class="string">&#x27;EPSG:4326&#x27;</span>, <span class="comment">// 投影</span></span><br><span class="line">&#125;);</span><br><span class="line">map.<span class="title function_">setView</span>(view);</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>加载地图</strong>：最后，确保地图被正确加载到页面中。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果有需要，可以添加其他交互控件，如缩放按钮、导航控件等</span></span><br><span class="line">map.<span class="title function_">addControl</span>(<span class="keyword">new</span> ol.<span class="property">control</span>.<span class="title class_">Zoom</span>());</span><br></pre></td></tr></table></figure><p>通过上述步骤，可以成功加载WMTS服务并显示在OpenLayers地图中。记得替换示例代码中的URL、图层名称、矩阵集、分辨率、矩阵ID等参数，以适应的具体WMTS服务。</p><h5 id="5、刚才有提到-WMS-可以具体说一下-WMS和-WMTS-两者的区别吗"><a href="#5、刚才有提到-WMS-可以具体说一下-WMS和-WMTS-两者的区别吗" class="headerlink" title="5、刚才有提到 WMS,可以具体说一下 WMS和 WMTS 两者的区别吗?"></a>5、刚才有提到 WMS,可以具体说一下 WMS和 WMTS 两者的区别吗?</h5><p>当涉及到地理信息系统（GIS）和地图服务时，WMS（Web Map Service）和WMTS（Web Map Tile Service）是两种不同的标准，它们有一些重要的区别：</p><ol><li><p><strong>数据传输方式</strong>：</p><ul><li><strong>WMS</strong>：WMS是基于请求-响应模式的。每次请求地图数据时，WMS服务器会动态生成地图图像，然后将整个地图图像作为响应传送给客户端。这意味着每次请求都生成新的地图图像，适用于动态数据和图层的情况，但可能会导致性能较差。</li><li><strong>WMTS</strong>：WMTS采用了瓦片式数据传输，地图被分成小块瓦片，每个瓦片都是一个预先生成的图像。这些瓦片在服务器端预先渲染，客户端通过直接请求这些瓦片来加载地图数据。这种方式通常更高效，尤其适用于静态地图数据，因为无需在每次请求时生成新的地图图像。</li></ul></li><li><p><strong>性能</strong>：</p><ul><li><strong>WMS</strong>：由于动态生成地图图像，WMS可能在性能上不如WMTS，尤其是在大规模地图和高并发请求的情况下。</li><li><strong>WMTS</strong>：WMTS的性能通常更好，因为瓦片数据是预先生成的，服务器只需提供瓦片即可，不需要在每次请求时进行渲染。</li></ul></li><li><p><strong>缓存</strong>：</p><ul><li><strong>WMS</strong>：WMS通常需要客户端自行管理图像的缓存，因为每次请求都会生成新的图像。这可能导致客户端性能问题，因为需要存储大量的图像数据。</li><li><strong>WMTS</strong>：WMTS的瓦片式数据天然适合缓存，因为瓦片是静态的，可以被有效地缓存。客户端可以从缓存中加载瓦片，减轻了服务器和客户端的负担。</li></ul></li><li><p><strong>灵活性</strong>：</p><ul><li><strong>WMS</strong>：WMS提供更多的灵活性，因为它可以在每次请求时动态生成地图图像，允许对地图进行实时操作和渲染。适用于需要动态数据的应用场景。</li><li><strong>WMTS</strong>：WMTS提供了稳定和可预测的地图显示，但通常不支持实时数据更新或动态渲染，因为瓦片是静态的。</li></ul></li></ol><p>总结来说，WMS和WMTS都是用于在Web上提供地图数据的标准，但它们的工作方式和适用场景有所不同。选择哪种标准取决于你的具体需求。如果需要实时渲染和动态数据，WMS可能更合适。如果需要更高的性能和稳定性，以及静态地图数据，WMTS可能是更好的选择。</p><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/7d7ab8ad/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第七期）</title>
      <link>https://jhcgnb.cn/posts/c917cf39/</link>
      <guid>https://jhcgnb.cn/posts/c917cf39/</guid>
      <pubDate>Fri, 14 Jun 2024 03:22:42 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WebGIS面试题（第七期）&quot;&gt;&lt;a href=&quot;#WebGIS面试题（第七期）&quot; class=&quot;headerlink&quot; title=&quot;WebGIS面试题（第七期）&quot;&gt;&lt;/a&gt;WebGIS面试题（第七期）&lt;/h2&gt;&lt;p&gt;以下题目仅为部分题目，全部题目在公众号&lt;/p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WebGIS面试题（第七期）"><a href="#WebGIS面试题（第七期）" class="headerlink" title="WebGIS面试题（第七期）"></a>WebGIS面试题（第七期）</h2><p>以下题目仅为部分题目，全部题目在公众号</p><blockquote><p><strong>{GISer世界}</strong></p></blockquote><p>，答案仅供参考!!!<br>集中则整理了相关有难度的问题，因为我自己回答得一般，所以有些答案参来自网络，仅供参考！！！<br>@[toc]</p><h3 id="1、前端实现geoJson与wkt格式互转"><a href="#1、前端实现geoJson与wkt格式互转" class="headerlink" title="1、前端实现geoJson与wkt格式互转"></a>1、前端实现geoJson与wkt格式互转</h3><p>GeoJSON 和 WKT（Well-Known Text）都是用于表示地理空间数据的格式。GeoJSON 是一种基于 JSON 的格式，广泛用于 Web 映射库，而 WKT 是一种纯文本的地理空间数据表示，遵循 OpenGIS 标准。</p><p>在前端实现 GeoJSON 与 WKT 格式的互转，可以通过以下步骤：</p><h3 id="将-GeoJSON-转换为-WKT"><a href="#将-GeoJSON-转换为-WKT" class="headerlink" title="将 GeoJSON 转换为 WKT"></a>将 GeoJSON 转换为 WKT</h3><ol><li><p><strong>解析 GeoJSON 对象</strong>：首先，需要解析 GeoJSON 对象的结构，GeoJSON 对象通常具有 <code>type</code> 和 <code>coordinates</code> 属性。</p></li><li><p><strong>构建 WKT 字符串</strong>：根据 GeoJSON 对象的类型（如 Point, LineString, Polygon 等），构建对应的 WKT 字符串。WKT 字符串以地理要素类型开头，后跟坐标对。</p></li><li><p><strong>处理子要素</strong>：对于如 <code>MultiPoint</code>, <code>MultiLineString</code>, <code>MultiPolygon</code> 或 <code>GeometryCollection</code> 这类包含多个子要素的 GeoJSON 对象，需要迭代这些子要素并为每个子要素构建 WKT 字符串。</p></li><li><p><strong>示例代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">geojsonToWKT</span>(<span class="params">geojson</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> wkt = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据 GeoJSON 对象的类型构建 WKT</span></span><br><span class="line">  <span class="keyword">switch</span> (geojson.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Point&#x27;</span>:</span><br><span class="line">      wkt = <span class="string">`POINT(<span class="subst">$&#123;geojson.coordinates[<span class="number">0</span>]&#125;</span> <span class="subst">$&#123;geojson.coordinates[<span class="number">1</span>]&#125;</span>)`</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ... 处理其他类型的 case</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> wkt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="将-WKT-转换为-GeoJSON"><a href="#将-WKT-转换为-GeoJSON" class="headerlink" title="将 WKT 转换为 GeoJSON"></a>将 WKT 转换为 GeoJSON</h3><ol><li><p><strong>解析 WKT 字符串</strong>：解析 WKT 字符串以确定地理要素的类型和坐标。</p></li><li><p><strong>构建 GeoJSON 对象</strong>：根据解析出的类型和坐标构建 GeoJSON 对象。GeoJSON 对象需要 <code>type</code> 和 <code>coordinates</code> 属性。</p></li><li><p><strong>处理特殊情况</strong>：对于多要素类型的 WKT（如 <code>MULTIPOINT</code>, <code>MULTILINESTRING</code>, <code>MULTIPOLYGON</code> 等），需要将坐标数组分割成多个单独的要素。</p></li><li><p><strong>示例代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wktToGeojson</span>(<span class="params">wkt</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> geojson = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用正则表达式或字符串方法解析 WKT 字符串</span></span><br><span class="line">  <span class="comment">// 例如，提取 Point 的坐标</span></span><br><span class="line">  <span class="keyword">const</span> matches = wkt.<span class="title function_">match</span>(<span class="regexp">/POINT\(([^)]+)\)/</span>);</span><br><span class="line">  <span class="keyword">if</span> (matches) &#123;</span><br><span class="line">    <span class="keyword">const</span> coords = matches[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line">    geojson = &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;Point&#x27;</span>,</span><br><span class="line">      <span class="attr">coordinates</span>: [coords[<span class="number">0</span>], coords[<span class="number">1</span>]]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 处理其他类型的解析</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> geojson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2、有没有现成的-JavaScript-库可以方便地进行-GeoJSON-与-WKT-格式的转换？"><a href="#2、有没有现成的-JavaScript-库可以方便地进行-GeoJSON-与-WKT-格式的转换？" class="headerlink" title="2、有没有现成的 JavaScript 库可以方便地进行 GeoJSON 与 WKT 格式的转换？"></a>2、有没有现成的 JavaScript 库可以方便地进行 GeoJSON 与 WKT 格式的转换？</h3><p>是的，存在多个 JavaScript 库可以方便地在 GeoJSON 和 WKT 格式之间进行转换。以下是一些流行的库：</p><ol><li><p>**<code>geojson-to-wkt</code> 和 <code>wkt-to-geojson</code>**：</p><ul><li>这两个库分别用于将 GeoJSON 转换为 WKT 和将 WKT 转换为 GeoJSON。它们易于使用，并且可以在 Node.js 环境或浏览器中运行。</li></ul><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装 geojson-to-wkt</span></span><br><span class="line">npm install geojson-to-wkt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装 wkt-to-geojson</span></span><br><span class="line">npm install wkt-to-geojson</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geojsonToWkt = <span class="built_in">require</span>(<span class="string">&#x27;geojson-to-wkt&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> wktToGeojson = <span class="built_in">require</span>(<span class="string">&#x27;wkt-to-geojson&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geojson = &#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Point&quot;</span>,</span><br><span class="line">  <span class="string">&quot;coordinates&quot;</span>: [<span class="number">102.0</span>, <span class="number">0.5</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wkt = <span class="title function_">geojsonToWkt</span>(geojson); <span class="comment">// &quot;POINT (102 0.5)&quot;</span></span><br><span class="line"><span class="keyword">const</span> convertedGeojson = <span class="title function_">wktToGeojson</span>(wkt); <span class="comment">// GeoJSON object</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>terraformer</code> 和 <code>terraformer-wkt-parser</code>**：</p><ul><li><code>terraformer</code> 是一个用于处理 GeoJSON 的 JavaScript 库，而 <code>terraformer-wkt-parser</code> 插件提供了将 WKT 字符串转换为 GeoJSON 的功能。</li></ul><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装 terraformer 和 terraformer-wkt-parser</span></span><br><span class="line">npm install terraformer terraformer-wkt-parser</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Terraformer</span> = <span class="built_in">require</span>(<span class="string">&#x27;terraformer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">WKT</span> = <span class="built_in">require</span>(<span class="string">&#x27;terraformer-wkt-parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wkt = <span class="string">&#x27;POINT (102 0.5)&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> geojson = <span class="variable constant_">WKT</span>.<span class="title function_">parse</span>(wkt); <span class="comment">// Terraformer.Point object</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>@mapbox/geojson-rewind</code>**：</p><ul><li>虽然这个库主要用于处理 GeoJSON 的坐标顺序，但它也可以用于将 GeoJSON 转换为 WKT。</li></ul><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装 @mapbox/geojson-rewind</span></span><br><span class="line">npm install @mapbox/geojson-rewind</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geojsonRewire = <span class="built_in">require</span>(<span class="string">&#x27;@mapbox/geojson-rewind&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geojson = &#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Point&quot;</span>,</span><br><span class="line">  <span class="string">&quot;coordinates&quot;</span>: [<span class="number">102.0</span>, <span class="number">0.5</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wkt = geojsonRewire.<span class="title function_">wkt</span>(geojson); <span class="comment">// &quot;POINT (102 0.5)&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>togeojson</code>**：</p><ul><li>这个库可以将多种地理空间数据格式转换为 GeoJSON，包括 WKT。</li></ul><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装 togeojson</span></span><br><span class="line">npm install togeojson</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toGeoJSON = <span class="built_in">require</span>(<span class="string">&#x27;togeojson&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wkt = <span class="string">&#x27;POINT (102 0.5)&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> geojson = toGeoJSON.<span class="title function_">wkt</span>(wkt); <span class="comment">// GeoJSON object</span></span><br></pre></td></tr></table></figure></li></ol><p>使用这些库，你可以在前端应用程序中轻松实现 GeoJSON 和 WKT 格式的转换，而无需从头开始编写转换逻辑。在使用任何库之前，请确保查看其文档以了解如何正确地集成和使用。</p><h3 id="2、你能谈谈OGR-OGC标准，和WMS-WFS在GeoTools中的作用吗？"><a href="#2、你能谈谈OGR-OGC标准，和WMS-WFS在GeoTools中的作用吗？" class="headerlink" title="2、你能谈谈OGR, OGC标准，和WMS&#x2F;WFS在GeoTools中的作用吗？"></a>2、你能谈谈OGR, OGC标准，和WMS&#x2F;WFS在GeoTools中的作用吗？</h3><p>OGR增强了GeoTools处理多种数据格式的能力，而遵循OGC标准，特别是WMS和WFS，使得GeoTools能够在分布式、网络化的环境中无缝地与其他GIS系统和服务协同工作，无论是作为数据提供者还是消费者，都极大地提升了其在地理信息处理和共享方面的灵活性和兼容性。</p><h3 id="3、解释数据投影和坐标参考系统（CRS）在GeoTools中的处理方式。"><a href="#3、解释数据投影和坐标参考系统（CRS）在GeoTools中的处理方式。" class="headerlink" title="3、解释数据投影和坐标参考系统（CRS）在GeoTools中的处理方式。"></a>3、解释数据投影和坐标参考系统（CRS）在GeoTools中的处理方式。</h3><p>在GeoTools中，数据投影和坐标参考系统（CRS）的处理是基于Open Geospatial Consortium (OGC) 和 International Organization for Standardization (ISO) 的标准，这些标准确保了地理空间数据的准确表达和互操作性。</p><p><strong>详细：</strong></p><p><strong>坐标参考系统（CRS）</strong>：<br>坐标参考系统定义了如何在地球表面或三维空间中测量位置。它包括地理坐标系（如WGS84，基于经纬度）和投影坐标系（如UTM，用于将地球曲面转换为平面）。在GeoTools中，CRS的处理主要通过<code>org.geotools.referencing</code>包中的类来完成，特别是<code>CoordinateReferenceSystem</code>接口及其实现类。GeoTools支持通过EPSG代码、WKT（Well-Known Text）字符串或者PRJ文件等方式来定义和解析CRS。</p><p>要获取或设置一个要素（Feature）或图层（Layer）的CRS，可以使用如下操作：</p><ul><li>获取CRS：通过要素的特征类型（FeatureType）或数据存储（DataStore）的元数据。</li><li>设置CRS：在创建或修改数据时指定CRS。</li></ul><p><strong>数据投影</strong>：<br>数据投影是指将地球表面的三维曲面数据转换到二维平面上的过程，以便于可视化、分析和存储。在GeoTools中，数据投影的转换通常利用<code>MathTransform</code>对象来完成，这个对象定义了从一个CRS到另一个CRS的数学变换关系。</p><p>进行投影转换时，可以按照以下步骤操作：</p><ol><li><strong>获取源CRS和目标CRS</strong>：使用<code>CRS.decode(&quot;EPSG:...&quot;)</code>或类似方法获取CRS实例。</li><li><strong>创建变换</strong>：通过<code>CoordinateOperationFactory</code>创建一个从源CRS到目标CRS的变换。</li><li><strong>转换几何体</strong>：使用变换对几何体进行投影转换，例如通过<code>JTS.transform()</code>方法。</li></ol><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载Shapefile并获取其CRS</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path/to/shapefile.shp&quot;</span>);</span><br><span class="line">Map&lt;String, Object&gt; params = Collections.singletonMap(<span class="string">&quot;url&quot;</span>, file.toURI().toURL());</span><br><span class="line"><span class="type">ShapefileDataStore</span> <span class="variable">dataStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapefileDataStore</span>(params);</span><br><span class="line"><span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> dataStore.getTypeNames()[<span class="number">0</span>];</span><br><span class="line"><span class="type">SimpleFeatureSource</span> <span class="variable">featureSource</span> <span class="operator">=</span> dataStore.getFeatureSource(typeName);</span><br><span class="line"><span class="type">CoordinateReferenceSystem</span> <span class="variable">crs</span> <span class="operator">=</span> featureSource.getSchema().getCoordinateReferenceSystem();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个新的投影（例如，从WGS84转换到UTM Zone 32N）</span></span><br><span class="line"><span class="type">CoordinateReferenceSystem</span> <span class="variable">targetCRS</span> <span class="operator">=</span> CRS.decode(<span class="string">&quot;EPSG:32632&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建变换</span></span><br><span class="line"><span class="type">MathTransform</span> <span class="variable">transform</span> <span class="operator">=</span> CRS.findMathTransform(crs, targetCRS, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们有一个要素集合，这里简化为单个要素处理</span></span><br><span class="line">FeatureCollection&lt;SimpleFeatureType, SimpleFeature&gt; features = featureSource.getFeatures();</span><br><span class="line"><span class="type">SimpleFeature</span> <span class="variable">feature</span> <span class="operator">=</span> features.features().next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对要素的几何体进行投影转换</span></span><br><span class="line"><span class="type">Geometry</span> <span class="variable">geometry</span> <span class="operator">=</span> (Geometry) feature.getDefaultGeometry();</span><br><span class="line"><span class="type">Geometry</span> <span class="variable">transformedGeometry</span> <span class="operator">=</span> JTS.transform(geometry, transform);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出或进一步处理transformedGeometry</span></span><br></pre></td></tr></table></figure><p>总之，GeoTools提供了强大的工具集来处理CRS和数据投影，使得开发者能够轻松地读取、转换和显示具有不同坐标系统的地理空间数据。</p><h3 id="4、在一个项目中，你是如何解决GeoTools与其他库或系统（如PostGIS）集成时遇到的问题的？"><a href="#4、在一个项目中，你是如何解决GeoTools与其他库或系统（如PostGIS）集成时遇到的问题的？" class="headerlink" title="4、在一个项目中，你是如何解决GeoTools与其他库或系统（如PostGIS）集成时遇到的问题的？"></a>4、在一个项目中，你是如何解决GeoTools与其他库或系统（如PostGIS）集成时遇到的问题的？</h3><p>在项目中集成GeoTools与其他库或系统，如PostGIS，可能会遇到诸如数据格式不匹配、版本兼容性问题、性能瓶颈或配置错误等挑战。以下是解决这类问题的一些策略：</p><ol><li><strong>确保版本兼容性</strong>：<ul><li>在开始集成之前，检查GeoTools、PostGIS以及任何其他依赖库的版本兼容性。使用官方文档或社区论坛确认推荐的组合，避免因版本不匹配导致的错误。</li></ul></li><li><strong>数据格式和投影一致性</strong>：<ul><li>确保GeoTools读取或写入PostGIS的数据时，CRS（坐标参考系统）是一致的。如果不一致，使用正确的投影转换逻辑，比如通过<code>MathTransform</code>进行转换。</li><li>检查数据表结构是否符合预期，特别是在字段类型、长度和约束方面。</li></ul></li><li><strong>配置连接参数</strong>：<ul><li>正确配置GeoTools连接到PostGIS的数据源参数，包括数据库URL、用户名、密码等。使用<code>DataStoreFinder</code>时，确保参数正确无误。</li></ul></li><li><strong>使用事务管理提高性能</strong>：<ul><li>在执行大量插入或更新操作时，利用事务管理来提升效率。GeoTools支持通过<code>DataStore</code>的事务特性来批量处理操作，减少数据库交互次数。</li></ul></li><li><strong>日志和错误追踪</strong>：<ul><li>开启详细日志记录，尤其是调试级别日志，可以帮助快速定位问题。分析日志中的错误消息或警告，根据提示进行排查。</li></ul></li><li><strong>利用社区资源</strong>：<ul><li>当遇到问题时，首先查阅GeoTools和PostGIS的官方文档、API参考和教程。</li><li>参与GeoTools和PostGIS的社区论坛或邮件列表，如Stack Overflow、GIS Stack Exchange或项目GitHub页面，提问或搜索已有的解决方案。</li></ul></li><li><strong>编写测试用例</strong>：<ul><li>为关键的集成部分编写单元测试或集成测试，确保各组件协同工作正常。这有助于早期发现问题并验证修复方案的有效性。</li></ul></li><li><strong>性能调优</strong>：<ul><li>监控应用性能，识别瓶颈。可能需要调整GeoTools的缓冲区大小、并发策略或查询优化等。同时，考虑PostGIS侧的索引优化、查询优化策略。</li></ul></li><li><strong>备份与恢复计划</strong>：<ul><li>在进行大规模数据操作前，确保有数据备份计划，以防不测。了解如何从错误中恢复，比如使用事务回滚或数据恢复脚本。</li></ul></li></ol><h3 id="5、使用PostGIS处理空间数据的优缺点是什么？"><a href="#5、使用PostGIS处理空间数据的优缺点是什么？" class="headerlink" title="5、使用PostGIS处理空间数据的优缺点是什么？"></a>5、使用PostGIS处理空间数据的优缺点是什么？</h3><p>PostGIS是一个功能强大的空间数据库扩展，适用于需要进行复杂空间分析和处理大量空间数据的应用场景。</p><p><strong>详细：</strong></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li><strong>功能丰富</strong>：PostGIS提供了广泛的空间数据类型、函数和操作符，支持复杂的空间查询和分析。</li><li><strong>开放标准</strong>：PostGIS遵循OGC（开放地理空间联盟）标准，确保了与其他GIS软件的兼容性。</li><li><strong>开源</strong>：作为一个开源项目，PostGIS允许免费使用和修改，有助于降低成本和促进社区创新。</li><li><strong>SQL集成</strong>：PostGIS与SQL紧密集成，可以使用SQL查询和操作空间数据，便于开发者使用熟悉的数据库技能。</li><li><strong>性能</strong>：通过使用空间索引（如GIST）和高效的查询优化，PostGIS能够处理大型空间数据集。</li><li><strong>扩展性</strong>：PostGIS作为PostgreSQL的扩展，可以利用PostgreSQL的稳定性和强大的事务处理能力。</li><li><strong>社区支持</strong>：拥有活跃的开发社区和用户群体，提供广泛的文档、教程和工具。</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li><strong>学习曲线</strong>：对于新手来说，PostGIS的复杂性和SQL的空间函数可能需要一段时间来学习和掌握。</li><li><strong>性能考量</strong>：虽然PostGIS性能良好，但在处理未优化或未索引的大型数据集时，性能可能会成为瓶颈。</li><li><strong>资源消耗</strong>：空间数据类型和操作可能比传统的关系数据库操作更消耗资源。</li><li><strong>安装配置</strong>：对于不熟悉PostgreSQL的用户，安装和配置PostGIS可能需要额外的时间和精力。</li><li><strong>版本兼容性</strong>：PostGIS与PostgreSQL的特定版本紧密相关，升级可能需要考虑兼容性问题。</li><li><strong>数据完整性</strong>：在多用户编辑环境中，需要额外的机制来维护数据的完整性和一致性。</li><li><strong>地理数据的复杂性</strong>：处理复杂的地理数据（如拓扑关系）可能需要更高级的知识和经验。</li><li><strong>系统维护</strong>：为了保持PostGIS的性能和稳定性，需要定期进行数据库维护，如VACUUM和ANALYZE操作。<br>以上一些仅供参考。</li></ol><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/c917cf39/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第六期）</title>
      <link>https://jhcgnb.cn/posts/5f26df17/</link>
      <guid>https://jhcgnb.cn/posts/5f26df17/</guid>
      <pubDate>Thu, 14 Dec 2023 03:22:34 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WebGIS面试题（第六期）&quot;&gt;&lt;a href=&quot;#WebGIS面试题（第六期）&quot; class=&quot;headerlink&quot; title=&quot;WebGIS面试题（第六期）&quot;&gt;&lt;/a&gt;WebGIS面试题（第六期）&lt;/h2&gt;&lt;p&gt;以下题目仅为部分题目，全部题目在公众号&lt;/p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WebGIS面试题（第六期）"><a href="#WebGIS面试题（第六期）" class="headerlink" title="WebGIS面试题（第六期）"></a>WebGIS面试题（第六期）</h2><p>以下题目仅为部分题目，全部题目在公众号</p><blockquote><p><strong>{GISer世界}</strong></p></blockquote><p>，答案仅供参考!!!<br>因为本人之前做过相关项目用到了GeoServer，因此在简历上写了熟悉GeoServer。所以在相关面试中都有问到，所以我集中则整理了相关有难度的问题，因为我自己回答得一般，所有有些答案参来自网络，仅供参考！！！</p><h3 id="1、请简述一下Geoserver是什么，以及它在GIS系统中的作用。"><a href="#1、请简述一下Geoserver是什么，以及它在GIS系统中的作用。" class="headerlink" title="1、请简述一下Geoserver是什么，以及它在GIS系统中的作用。"></a>1、请简述一下Geoserver是什么，以及它在GIS系统中的作用。</h3><p>GeoServer是一个开源的地理空间服务器，用于发布和管理地理空间数据。</p><p><strong>详细：</strong></p><p>它是一个用Java编写的开源软件服务器，允许用户共享和编辑地理空间数据，并通过开放标准发布这些数据。GeoServer是OpenGIS Web服务器规范的J2EE实现，它可以方便地发布地图数据，并支持用户对特征数据进行更新、删除和插入操作。此外，GeoServer还是开放地理空间联盟（OGC）Web要素服务（WFS）和Web覆盖服务（WCS）标准的参考实现，同时也是一种高性能认证兼容的Web地图服务（WMS）。</p><p>在GIS系统中，GeoServer的作用至关重要。它可以将各种格式的地理空间数据发布为Web服务，如WMS、WFS和WCS，供Web客户端和应用程序使用。这意味着GeoServer能够将地理空间数据转化为可在互联网上访问和使用的形式，从而方便用户进行浏览、查询、分析和编辑等操作。</p><p>此外，GeoServer还提供了强大的数据转换功能，支持多人编辑，并允许用户根据需求定制地图的外观和信息展示方式。这使得GeoServer在地理信息系统开发、空间数据共享、空间数据分析等领域具有广泛的应用价值。</p><h3 id="2、你如何将地理空间数据发布到-GeoServer？"><a href="#2、你如何将地理空间数据发布到-GeoServer？" class="headerlink" title="2、你如何将地理空间数据发布到 GeoServer？"></a>2、你如何将地理空间数据发布到 GeoServer？</h3><p>将地理空间数据发布到 GeoServer 是一个涉及几个步骤的过程，主要包括数据的准备、数据源的创建、以及服务的发布。以下是将地理空间数据发布到 GeoServer 的一般步骤：</p><ol><li><p><strong>准备地理空间数据</strong>：</p><ul><li>确保你的数据是 GeoServer 支持的格式，如 Shapefile、GeoTIFF、PostGIS 等。</li></ul></li><li><p><strong>安装并启动 GeoServer</strong>：</p><ul><li>确保 GeoServer 已经正确安装在你的服务器上，并且服务已经启动。</li></ul></li><li><p><strong>访问 GeoServer 管理界面</strong>：</p><ul><li>通过 Web 浏览器访问 GeoServer 的管理界面，通常是一个 Web 应用，如 <code>http://&lt;server&gt;:8080/geoserver</code>。</li></ul></li><li><p><strong>创建工作空间（Workspace）</strong>：</p><ul><li>如果还没有为数据创建工作空间，你需要添加一个新的工作空间。工作空间是管理数据集的逻辑容器。</li></ul></li><li><p><strong>创建数据源（Data Store）</strong>：</p><ul><li>在工作空间内部，创建一个新的数据源。数据源是连接到数据存储的配置，包括数据连接的详细信息。</li></ul></li><li><p><strong>上传数据</strong>：</p><ul><li>将地理空间数据文件上传到 GeoServer。这通常通过管理界面的“数据”选项卡完成。</li></ul></li><li><p><strong>配置数据源</strong>：</p><ul><li>配置数据源的连接参数，如数据库的 URL、用户名、密码等。</li></ul></li><li><p><strong>创建层（Layer）</strong>：</p><ul><li>一旦数据源被创建，GeoServer 将自动识别数据中的层。你可以为每个数据源创建一个或多个层。</li></ul></li><li><p><strong>设置层属性</strong>：</p><ul><li>为每个层设置名称、标题、描述等属性，并定义其在 Web 地图中的表示方式。</li></ul></li><li><p><strong>应用样式（Style）</strong>：</p><ul><li>为层应用样式，定义如何显示地理要素，如颜色、线型、填充样式等。</li></ul></li><li><p><strong>发布服务</strong>：</p><ul><li>配置服务（如 WMS、WFS、WCS 或 WCS），并发布它们，使得客户端可以通过网络访问这些服务。</li></ul></li><li><p><strong>测试服务</strong>：</p><ul><li>在发布服务后，测试服务是否能够正常工作。你可以使用如 QGIS 或 Web 客户端（如 OpenLayers 或 Leaflet）来请求服务并查看结果。</li></ul></li><li><p><strong>安全性和权限</strong>：</p><ul><li>如果需要，设置访问控制和权限，以限制对数据的访问。</li></ul></li><li><p><strong>优化和调整</strong>：</p><ul><li>根据需要优化性能，调整缓存设置，确保服务响应迅速。</li></ul></li><li><p><strong>文档和维护</strong>：</p><ul><li>为发布的服务编写文档，并进行定期维护。</li></ul></li></ol><p>这个过程可能因 GeoServer 的版本和具体配置而有所不同，但大致步骤是相似的。如果遇到任何问题，可以查阅 GeoServer 的官方文档或社区论坛以获得帮助。</p><h3 id="3、当你尝试发布一个地图服务但出现乱码或无法显示时，你会怎样进行故障排查？"><a href="#3、当你尝试发布一个地图服务但出现乱码或无法显示时，你会怎样进行故障排查？" class="headerlink" title="3、当你尝试发布一个地图服务但出现乱码或无法显示时，你会怎样进行故障排查？"></a>3、当你尝试发布一个地图服务但出现乱码或无法显示时，你会怎样进行故障排查？</h3><p><strong>详细：</strong></p><p>当尝试发布一个地图服务但出现乱码或无法显示时，我会按照以下步骤进行故障排查：</p><p>首先，会检查服务器的字符集设置。乱码问题通常与字符集编码不匹配有关。我会确保服务器使用的字符集（如UTF-8或GBK）与地图数据的编码一致。如果服务器的字符集设置不正确，我会进行调整并重新发布服务。</p><p>其次，会检查GeoServer的工作区字符集设置。在GeoServer中，工作区字符集用于处理地图数据的编码。如果工作区字符集设置不正确，也会导致乱码问题。我会将工作区字符集改为与地图数据编码匹配的字符集，并重新发布服务。</p><p>接着，会检查样式文件中的编码设置。在GeoServer中，样式文件（如SLD文件）用于定义地图的外观。如果样式文件中的编码设置与地图数据的编码不匹配，也会导致乱码问题。我会查看样式文件中的encoding属性，并确保其与地图数据的编码一致。</p><p>此外，还会检查字体设置。有时，乱码问题可能是由于GeoServer中缺少所需的字体导致的。我会检查GeoServer的字体设置，确保所需的字体已经正确安装并配置。如果需要，我会添加或更新字体文件，并重新发布服务。</p><p>如果以上步骤都无法解决问题，我会进一步检查地图数据的完整性和正确性。我会使用GIS软件（如QGIS）打开地图数据，检查数据是否损坏或存在编码问题。如果数据存在问题，我会修复数据并重新发布服务。</p><p>最后，如果问题仍然存在，我会查看GeoServer的日志文件以获取更多关于错误的详细信息。日志文件通常包含有关发布服务过程中发生的错误的详细信息，这有助于我进一步定位问题并进行解决。</p><p>综上所述，当发布地图服务出现乱码或无法显示时，需要从字符集设置、工作区字符集、样式文件编码、字体设置以及地图数据完整性等方面进行故障排查，并根据具体情况采取相应的解决措施。</p><h3 id="4、你如何为-GeoServer-中的层设置样式？"><a href="#4、你如何为-GeoServer-中的层设置样式？" class="headerlink" title="4、你如何为 GeoServer 中的层设置样式？"></a>4、你如何为 GeoServer 中的层设置样式？</h3><p><strong>详细：</strong></p><p>为 GeoServer 中的层设置样式是一个重要的步骤，它决定了数据在客户端地图上的视觉表现。以下是为 GeoServer 中的层设置样式的一般步骤：</p><ol><li><p><strong>访问 GeoServer 管理界面</strong>：</p><ul><li>打开你的 Web 浏览器，并访问 GeoServer 的管理界面。</li></ul></li><li><p><strong>选择层</strong>：</p><ul><li>在 GeoServer 的管理界面中，导航到“Layers”（层）部分，找到你想要设置样式的层。</li></ul></li><li><p><strong>编辑层</strong>：</p><ul><li>选择相应的层并点击“Edit”（编辑）按钮，进入层的编辑界面。</li></ul></li><li><p><strong>选择样式</strong>：</p><ul><li>在层的编辑界面中，找到“Styles”（样式）部分。这里列出了所有可用的样式。</li></ul></li><li><p><strong>创建或选择样式</strong>：</p><ul><li>如果你已经有了一个样式，你可以选择它并应用到层上。如果没有，你需要创建一个新的样式。</li></ul></li><li><p><strong>创建新样式</strong>：</p><ul><li>点击“Add new style”（添加新样式）或“New”（新建）按钮来创建一个新的样式。</li></ul></li><li><p><strong>定义样式特征</strong>：</p><ul><li>在创建新样式的界面中，你需要定义样式的特征，如名称、格式（SLD、CSS 等）和样式的具体规则。</li></ul></li><li><p><strong>编辑样式规则</strong>：</p><ul><li>根据你的数据类型和所需的视觉效果，编辑样式规则。这可能包括选择颜色、线型、填充样式、标签、标签样式等。</li></ul></li><li><p><strong>使用 SLD 编辑器</strong>：</p><ul><li>对于复杂的样式，你可能需要使用 SLD（Styled Layer Descriptor）编辑器，它允许你以 XML 格式编写样式规则。</li></ul></li><li><p><strong>预览样式</strong>：</p><ul><li>在编辑样式时，你可以使用 GeoServer 提供的预览功能来查看样式效果。</li></ul></li><li><p><strong>保存样式</strong>：</p><ul><li>编辑完成后，保存你的样式。</li></ul></li><li><p><strong>应用样式到层</strong>：</p><ul><li>返回到层的编辑界面，选择你刚刚创建或修改的样式，并将其应用到层上。</li></ul></li><li><p><strong>保存层设置</strong>：</p><ul><li>确保保存层的设置，以便样式生效。</li></ul></li><li><p><strong>测试样式</strong>：</p><ul><li>在客户端地图上测试你的样式，确保它按照预期显示。</li></ul></li><li><p><strong>调整和优化</strong>：</p><ul><li>根据测试结果，你可能需要返回到样式编辑器中进行一些调整和优化。</li></ul></li></ol><p>样式的创建和编辑可以非常直观，也可以非常复杂，这取决于需要的视觉效果。GeoServer 支持多种样式语言，包括 SLD、CSS 和 CQL，每种语言都有其特定的语法和功能。如果不熟悉样式语言，GeoServer 的用户界面提供了一些向导和工具来帮助你创建和编辑样式。</p><h3 id="5、你知道Geoserver在保障数据安全方面有哪些措施。"><a href="#5、你知道Geoserver在保障数据安全方面有哪些措施。" class="headerlink" title="5、你知道Geoserver在保障数据安全方面有哪些措施。"></a>5、你知道Geoserver在保障数据安全方面有哪些措施。</h3><p><strong>详细：</strong></p><p>GeoServer在保障数据安全方面采取了多种措施，以确保地理空间数据的安全性和完整性。以下是一些关键的安全措施：</p><ol><li><strong>用户认证和授权</strong>：GeoServer实施了严格的用户认证和授权机制。这意味着只有经过身份验证的用户才能访问GeoServer及其提供的服务。此外，基于角色的访问控制（RBAC）可以用来管理用户权限，确保每个用户只能访问其被授权的数据和功能。</li><li><strong>输入验证和过滤</strong>：为了防止跨站脚本攻击（XSS）和SQL注入等安全漏洞，GeoServer会对从用户接收的输入数据进行严格的验证和过滤。这有助于确保输入数据的合法性和安全性，减少潜在的安全风险。</li><li><strong>安全配置</strong>：GeoServer的配置文件和敏感信息（如数据库凭据）受到保护，只有授权的人员才能访问。这有助于防止未经授权的访问和恶意修改，确保系统的安全性和稳定性。</li><li><strong>服务安全</strong>：GeoServer支持服务级别的访问控制，允许将服务操作锁定到已被授予特定角色的经过身份验证的用户。例如，可以保护整个WFS服务，使得只有经过身份验证的用户才能访问所有WFS操作。同时，也可以允许匿名用户访问只读操作，但保护写操作的安全。</li><li><strong>定期更新和补丁</strong>：为了修复已知的漏洞和安全问题，GeoServer会定期发布更新和补丁。及时应用这些更新和补丁是保持系统安全性的重要措施。</li><li><strong>日志和监控</strong>：GeoServer实施了日志记录和监控机制，以便及时检测和响应潜在的安全事件。这包括实时监控系统性能、网络流量和异常活动，帮助管理员及时发现并处理安全问题。</li></ol><p>GeoServer通过用户认证和授权、输入验证和过滤、安全配置、服务安全、定期更新和补丁以及日志和监控等多种措施来保障数据安全。这些措施共同构成了一个多层次的安全防护体系，为地理空间数据的安全提供了有力的保障。</p><h3 id="6、GeoServer-如何与-QGIS-或-ArcGIS-等其他-GIS-工具集成？"><a href="#6、GeoServer-如何与-QGIS-或-ArcGIS-等其他-GIS-工具集成？" class="headerlink" title="6、GeoServer 如何与 QGIS 或 ArcGIS 等其他 GIS 工具集成？"></a>6、GeoServer 如何与 QGIS 或 ArcGIS 等其他 GIS 工具集成？</h3><p><strong>详细：</strong></p><p>GeoServer 作为一个开源的地理空间数据服务器，能够与多种 GIS 工具集成，包括 QGIS 和 ArcGIS。以下是 GeoServer 与这些工具集成的一些常见方式：</p><ol><li><p><strong>作为数据源</strong>：</p><ul><li>GeoServer 可以作为 QGIS 的数据源。在 QGIS 中，用户可以通过添加 WMS 或 WFS 服务来连接到 GeoServer 发布的地图服务。</li></ul></li><li><p><strong>服务发布</strong>：</p><ul><li>在 GeoServer 中发布地理空间数据后，QGIS 可以使用这些服务。用户可以在 QGIS 中通过“添加 WMS&#x2F;WMTS 层”功能来加载 GeoServer 发布的地图服务。</li></ul></li><li><p><strong>样式设计</strong>：</p><ul><li>根据搜索结果，可以使用 QGIS 对图层进行符号化设计，然后导出为 SLD 格式的样式文件。之后，可以在 GeoServer 中添加和应用这些样式。</li></ul></li><li><p><strong>服务加载</strong>：</p><ul><li>在 QGIS 中，用户可以通过浏览器连接到 GeoServer 发布的服务，并将这些服务加载到 QGIS 中进行进一步的分析和可视化。</li></ul></li><li><p><strong>跨平台兼容性</strong>：</p><ul><li>GeoServer 支持 OpenGIS 标准，这意味着它可以与任何遵循这些标准的 GIS 软件集成。</li></ul></li><li><p><strong>ArcGIS 集成</strong>：</p><ul><li>根据搜索结果，GeoServer 也可以与 ArcGIS 集成。ArcGIS 用户可以通过 ArcGIS Desktop 或 ArcGIS Server 访问 GeoServer 发布的 WMS 或 WFS 服务。</li></ul></li><li><p><strong>插件和扩展</strong>：</p><ul><li>有时可能需要特定的插件或扩展来增强 GeoServer 与其他 GIS 工具的集成能力。</li></ul></li><li><p><strong>Web 服务标准</strong>：</p><ul><li>GeoServer 遵循 OGC 标准，如 WMS（Web Map Service）和 WFS（Web Feature Service），这些是 GIS 行业广泛接受的标准，使得 GeoServer 能够与多种 GIS 客户端软件兼容。</li></ul></li><li><p><strong>直接连接</strong>：</p><ul><li>用户可以直接在 ArcGIS 或 QGIS 中输入 GeoServer 服务的 URL 来建立连接，无需额外的转换或格式调整。</li></ul></li><li><p><strong>数据交换</strong>：</p><ul><li>GeoServer 允许 GIS 专业人员之间进行数据交换，无论他们使用的是哪个品牌的 GIS 软件。</li></ul></li><li><p><strong>缓存切片</strong>：</p><ul><li>根据搜索结果，GeoServer 还可以使用 GeoWebCache 插件来发布 ArcGIS 的缓存切片，这进一步增强了两者之间的集成。</li></ul></li></ol><p>通过这些集成方式，GeoServer 能够作为一个强大的后端服务，支持前端的 GIS 应用程序，如 QGIS 和 ArcGIS，实现数据共享、地图制作和空间分析等功能。</p><pre><code>以上一些仅供参考。</code></pre><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/5f26df17/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>11.性能优化</title>
      <link>https://jhcgnb.cn/posts/5a9e107b/</link>
      <guid>https://jhcgnb.cn/posts/5a9e107b/</guid>
      <pubDate>Wed, 18 Oct 2023 13:51:52 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;雅虎14条Web性能优化规则&quot;&gt;&lt;a href=&quot;#雅虎14条Web性能优化规则&quot; class=&quot;headerlink&quot; title=&quot;雅虎14条Web性能优化规则&quot;&gt;&lt;/a&gt;雅虎14条Web性能优化规则&lt;/h1&gt;&lt;h2 id=&quot;法则-1-减少-HTTP-请求次数</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="雅虎14条Web性能优化规则"><a href="#雅虎14条Web性能优化规则" class="headerlink" title="雅虎14条Web性能优化规则"></a>雅虎14条Web性能优化规则</h1><h2 id="法则-1-减少-HTTP-请求次数"><a href="#法则-1-减少-HTTP-请求次数" class="headerlink" title="法则 1. 减少 HTTP 请求次数"></a>法则 1. 减少 HTTP 请求次数</h2><p>80%的最终用户响应时间花在前端程序上，而其大部分时间则花在各种页面元素， 如图像、 样式表、 脚本和 Flash 等，的下载上。 减少页面元素将会减少 HTTP 请求 次数。这是快速显示页面的关键所在。 一种减少页面元素个数的方法是简化页面设计。 但是否存在其他方式，能做到既有丰富内容，又能获得快速响应时间呢？以下是这样一些技术：<br>Image maps 组合多个图片到一张图片中。总文件大小变化不大，但减少了 HTTP 请求次数从而加快了页面显示速度。该方式只适合图片连续的情况；同时坐标的定义是烦人又容易出错的工作。<br>CSS Sprites 是更好的方法。它可以组合页面中的图片到单个文件中，并使用 CSS 的 background-image 和 background-position 属性来实现所需的部分图片。 Inline images 使用 data: URL scheme 来在页面中内嵌图片。这将增大 HTML 文件的大小。组合 inline images 到你的（缓存）样式表是既能较少 HTTP 请求， 又能避免加大 HTML 文件大小的方法。<br>Combined files 通过组合多个脚本文件到单一文件来减少 HTTP 请求次数。样式 表也可采用类似方法处理。 这个方法虽然简单，但没有得到大规模的使用。  10大 美国网站每页平均有 7 个脚本文件和 2 个样式表。当页面之间脚本和样式表变化 很大时，该方式将遇到很大的挑战，但如果做到的话，将能加快响应时间。<br>小结：减少 HTTP 请求次数是性能优化的起点。这最提高首次访问的效率起到很重要的 作用。 Tenni Theurer 的文章 Browser Cache Usage – Exposed!描述，40-60% 据 的日常访问是首次访问，因此为首次访问者加快页面访问速度是用户体验的关 键。</p><h2 id="法则-2-使用-CDN-Content-Delivery-Network-内容分发网络"><a href="#法则-2-使用-CDN-Content-Delivery-Network-内容分发网络" class="headerlink" title="法则 2. 使用 CDN(Content Delivery Network, 内容分发网络 )"></a>法则 2. 使用 CDN(Content Delivery Network, 内容分发网络 )</h2><p>用户离 web server 的远近对响应时间也有很大影响。从用户角度看，把内容部 署到多个地理位置分散的服务器上将有效提高页面装载速度。 但是该从哪里开始 呢？<br>作为实现内容地理分布的第一步，不要试图重构 web 应用以适应分布架构。 改变 架构将导致多个周期性任务，如同步 session 状态，在多个 server 之间复制数 据库交易。 这样缩短用户与内容距离的尝试可能被应用架构改版所延迟，或阻止。 我们还记得 80-90%的最终用户响应时间花在下载页面中的各种元素上，如图像 文件、 样式表、 脚本和 Flash 等。 与其花在重构系统这个困难的任务上，还不如先 分布静态内容。 这不仅能大大减少响应时间，而且由于 CDN 的存在，分布静态内 容非常容易实现。 CDN 是地理上分布的 web server 的集合，用于更高效地发布内容。 通常基于网络 远近来选择给具体用户服务的 web server。 一些大型网站拥有自己的 CDN，但是使用如 Akamai Technologies, Mirror Image Internet, 或 Limelight Networks 等 CDN 服务提供商的服务将是划算的。 在 Yahoo!把静态内容分布到 CDN 减少了用户影响时间 20%或更多。切换到 CDN 的 代码修改工作是很容易的，但能达到提高网站的速度。</p><h2 id="法则-3-增加-Expires-Header"><a href="#法则-3-增加-Expires-Header" class="headerlink" title="法则 3. 增加 Expires Header"></a>法则 3. 增加 Expires Header</h2><p>网页内容正变得越来越丰富，这意味着更多的脚本文件、样式表、图像文件和 Flash。 首次访问者将不得不面临多次 HTTP 请求，但通过使用 Expires header， 您可以在客户端缓存这些元素。这在后续访问中避免了不必要的 HTTP 请求。 Expires header 最常用于图像文件，但是它也应该用于脚本文件、样式表和 Flash。 浏览器（和代理）使用缓存来减少 HTTP 请求的次数和大小，使得网页加速装载。 Web server 通过 Expires header 告诉客户端一个元素可以缓存的时间长度。 如果服务器是 Apache 的话，您可以使用 ExpiresDefault 基于当期日期来设置 过期日期，如： ExpiresDefault “access plus 10 years” 设置过期时间为从请求时间开始 计算的 10 年。 请记住，如果使用超长的过期时间，则当内容改变时，您必须修改文件名称。 在 Yahoo!我们经常把改名作为 release 的一个步骤：版本号内嵌在文件名中，如 yahoo_2.0.6.js。</p><h2 id="法则-4-压缩页面元素"><a href="#法则-4-压缩页面元素" class="headerlink" title="法则 4. 压缩页面元素"></a>法则 4. 压缩页面元素</h2><p>通过压缩 HTTP 响应内容可减少页面响应时间。从 HTTP&#x2F;1.1 开始，web 客户端在 HTTP 请求中通过 Accept-Encoding 头来表明支持的压缩类型，如：<br>Accept-Encoding: gzip, deflate. 如果 Web server 检查到 Accept-Encoding 头，它会使用客户端支持的方法来压 缩 HTTP 响应，会设置 Content-Encoding 头，如：Content-Encoding: gzip。 Gzip 是目前最流行及有效的压缩方法。 其他的方式如 deflate，但它效果较差， 也不够流行。通过 Gzip，内容一般可减少 70%。如果是 Apache，在 1.3 版本下需 使用 mod_gzip 模块，而在 2.x 版本下，则需使用 mod_deflate。 Web server 根据文件类型来决定是否压缩。 大部分网站对 HTML 文件进行压缩。 但 对脚本文件和样式表进行压缩也是值得的。实际上，对包括 XML 和 JSON 在内的 任务文本信息进行压缩都是值得的。 图像文件和 PDF 文件不应该被压缩，因为它 们本来就是压缩格式保存的。对它们进行压缩，不但浪费 CPU，而且还可能增加 文件的大小。 因此，对尽量多的文件类型进行压缩是一种减少页面大小和提高用户体验的简 便方法。</p><h2 id="法则-5-把样式表放在头上"><a href="#法则-5-把样式表放在头上" class="headerlink" title="法则 5. 把样式表放在头上"></a>法则 5. 把样式表放在头上</h2><p>我们发现把样式表移到 HEAD 部分可以提高界面加载速度，因此这使得页面元素 可以顺序显示。 在很多浏览器下，如 IE，把样式表放在 document 的底部的问题在于它禁止了网 页内容的顺序显示。 浏览器阻止显示以免重画页面元素，那用户只能看到空白页 了。Firefox 不会阻止显示，但这意味着当样式表下载后，有些页面元素可能需 要重画，这导致闪烁问题。 HTML 规范明确要求样式表被定义在 HEAD 中，因此，为避免空白屏幕或闪烁问题， 最好的办法是遵循 HTML 规范，把样式表放在 HEAD 中。</p><h2 id="法则-6-把脚本文件放在底部"><a href="#法则-6-把脚本文件放在底部" class="headerlink" title="法则 6. 把脚本文件放在底部"></a>法则 6. 把脚本文件放在底部</h2><p>与样式文件一样，我们需要注意脚本文件的位置。 我们需尽量把它们放在页面的 底部，这样一方面能顺序显示，另方面可达到最大的并行下载。 浏览器会阻塞显示直到样式表下载完毕，因此我们需要把样式表放在 HEAD 部分。 而对于脚本来说，脚本后面内容的顺序显示将被阻塞，因此把脚本尽量放在底 部意味着更多内容能被快速显示。 脚本引起的第二个问题是它阻塞并行下载数量。HTTP&#x2F;1.1 规范建议浏览器每个 主机的并行下载数不超过 2 个。 因此如果您把图像文件分布到多台机器的话，您可以达到超过 2 个的并行下载。 但是当脚本文件下载时，浏览器不会启动其他的 并行下载，甚至其他主机的下载也不启动。 在某些情况下，不是很容易就能把脚本移到底部的。如，脚本使用 document.write 方法来插入页面内容。 同时可能还存在域的问题。 不过在很多情 况下，还是有一些方法的。 一个备选方法是使用延迟脚本（deferred script）。DEFER 属性表明脚本未包 含 document.write，指示浏览器刻继续显示。不幸的是，Firefox 不支持 DEFER 属性。 IE 中，脚本可能被延迟执行，但不一定得到需要的长时间延迟。 在 不过从 另外角度来说，如果脚本能被延迟执行，那它就可以被放在底部了。</p><h2 id="法则-7-避免-CSS-表达式"><a href="#法则-7-避免-CSS-表达式" class="headerlink" title="法则 7. 避免 CSS 表达式"></a>法则 7. 避免 CSS 表达式</h2><p>CSS 表达式是功能强大的(同时也是危险的)用于动态设置 CSS 属性的方式。IE， 从版本 5 开始支持 CSS 表达式，如 backgourd-color: expression((new Date()).getHours()%2?”#B8D4FF”:”#F08A00”)，即背景色每个小时切换一 次。 CSS 表达式的问题是其执行次数超过大部分人的期望。 不仅页面显示和 resize 时 计算表达式，而且当页面滚屏，甚至当鼠标在页面上移动时都会重新计算表达 式。 一种减少 CSS 表达式执行次数的方法是一次性表达式，即当第一次执行时就以 明确的数值代替表达式。如果必须动态设置的话，可使用事件处理函数代替。如 果您必须使用 CSS 表达式的话，请记住它们可能被执行上千次，从而影响页面 性能。</p><h2 id="法则-8-把-JavaScript-和-CSS-放到外部文件中"><a href="#法则-8-把-JavaScript-和-CSS-放到外部文件中" class="headerlink" title="法则 8. 把 JavaScript 和 CSS 放到外部文件中"></a>法则 8. 把 JavaScript 和 CSS 放到外部文件中</h2><p>上述很多性能优化法则都基于外部文件进行优化。 现在，我们必须问一个问题： JavaScript 和 CSS 应该包括在外部文件，还是在页面文件中？ 在现实世界中，使用外部文件会加快页面显示速度，因为外部文件会被浏览器 缓存。如果内置 JavaScript 和 CSS 在页面中虽然会减少 HTTP 请求次数，但增大 了页面的大小。 另外一方面，使用外部文件，会被浏览器缓存，则页面大小会减 小，同时又不增加 HTTP 请求次数。 因此，一般来说，外部文件是更可行的方式。 唯一的例外是内嵌方式对主页更有 效，如 Yahoo!和 My Yahoo!都使用内嵌方式。一般来说，在一个 session 中，主 页访问此时较少，因此内嵌方式可以取得更快的用户响应时间。</p><h2 id="法则-9-减少-DNS-查询次数"><a href="#法则-9-减少-DNS-查询次数" class="headerlink" title="法则 9. 减少 DNS 查询次数"></a>法则 9. 减少 DNS 查询次数</h2><p>DNS 用于映射主机名和 IP 地址，一般一次解析需要 20～120 毫秒。 为达到更高的 性能，DNS 解析通常被多级别地缓存，如由 ISP 或局域网维护的 caching server，本地机器操作系统的缓存（如 windows 上的 DNS Client Service）， 浏览器。 的缺省 DNS 缓存时间为 30 分钟，Firefox 的缺省缓冲时间是 1 分钟。 IE 减少主机名可减少 DNS 查询的次数，但可能造成并行下载数的减少。避免 DNS 查 询可减少响应时间，而减少并行下载数可能增加响应时间。 一个可行的折中是把 内容分布到至少 2 个，最多 4 个不同的主机名上。</p><h2 id="法则-10-最小化-JavaScript代码"><a href="#法则-10-最小化-JavaScript代码" class="headerlink" title="法则 10. 最小化 JavaScript代码"></a>法则 10. 最小化 JavaScript代码</h2><p>最小化 JavaScript 代码指在 JS 代码中删除不必要的字符，从而降低下载时间。 两个流行的工具是 JSMin 和 YUI Compressor。 混淆是最小化于源码的备选方式。 象最小化一样，它通过删除注释和空格来减少 源码大小，同时它还可以对代码进行混淆处理。 作为混淆的一部分，函数名和变 量名被替换成短的字符串，这使得代码更紧凑，同时也更难读，使得难于被反 向工程。Dojo Compressor (ShrinkSafe)是最常见的混淆工具。 最小化是安全的、直白的过程，而混淆则更复杂，而且容易产生问题。从对美国 10 大网站的调查来看，通过最小化，文件可减少 21%，而混淆则可减少 25%。 除了最小化外部脚本文件外，内嵌的脚本代码也应该被最小化。 即使脚本根据法 则 4 被压缩后传输，最小化脚本刻减少文件大小 5%或更高。</p><h2 id="法则-11-避免重定向"><a href="#法则-11-避免重定向" class="headerlink" title="法则 11. 避免重定向"></a>法则 11. 避免重定向</h2><p>重定向功能是通过 301 和 302 这两个 HTTP 状态码完成的，如： HTTP&#x2F;1.1 301 Moved Permanently Location: <a href="http://example.com/newuri">http://example.com/newuri</a> Content-Type: text&#x2F;html 浏览器自动重定向请求到 Location 指定的 URL 上，重定向的主要问题是降低了 用户体验。 一种最耗费资源、经常发生而很容易被忽视的重定向是 URL 的最后缺少&#x2F;，如访 问 <a href="http://astrology.yahoo.com/astrology">http://astrology.yahoo.com/astrology</a> 将被重定向到 <a href="http://astrology.yahoo.com/astrology/%E3%80%82%E5%9C%A8">http://astrology.yahoo.com/astrology/。在</a> Apache 下，可以通过 Alias，mod_rewrite 或 DirectorySlash 等方式来解决该问题。</p><h2 id="法则-12-删除重复的脚本文件"><a href="#法则-12-删除重复的脚本文件" class="headerlink" title="法则 12. 删除重复的脚本文件"></a>法则 12. 删除重复的脚本文件</h2><p>在一个页面中包含重复的 JS 脚本文件会影响性能，即它会建立不必要的 HTTP 请求和额外的 JS 执行。 不必要的 HTTP 请求发生在 IE 下，而 Firefox 不会产生多余的 HTTP 请求。 额外的 JS 执行，不管在 IE 下，还是在 Firefox 下，都会发生。 一个避免重复的脚本文件的方式是使用模板系统来建立脚本管理模块。 除了防止 重复的脚本文件外，该模块还可以实现依赖性检查和增加版本号到脚本文件名 中，从而实现超长的过期时间。</p><h2 id="法则-13-配置-ETags"><a href="#法则-13-配置-ETags" class="headerlink" title="法则 13. 配置 ETags"></a>法则 13. 配置 ETags</h2><p>ETags 是用于确定浏览器缓存中元素是否与 Web server 中的元素相匹配的机制， 它是比 last-modified date 更灵活的元素验证机制。ETag 是用于唯一表示元素 版本的字符串，它需被包括在引号中。Web server 首先在 response 中指定 ETag： HTTP&#x2F;1.1 200 OK &lt; 03:03:59 2006 Dec 12&gt; 10c24bc-4ab-457e1c1f” Content-Length: 12195 后来，如果浏览器需要验证某元素，它使用 If-None-Match 头回传 ETag 给 Web server，如果 ETag 匹配，则服务器返回 304 代码，从而节省了下载时间</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/5a9e107b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第五期）</title>
      <link>https://jhcgnb.cn/posts/294b6a04/</link>
      <guid>https://jhcgnb.cn/posts/294b6a04/</guid>
      <pubDate>Thu, 14 Sep 2023 03:18:45 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WebGIS面试题（第五期）&quot;&gt;&lt;a href=&quot;#WebGIS面试题（第五期）&quot; class=&quot;headerlink&quot; title=&quot;WebGIS面试题（第五期）&quot;&gt;&lt;/a&gt;WebGIS面试题（第五期）&lt;/h2&gt;&lt;p&gt;以下题目仅为部分题目，全部题目在公众号{GI</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WebGIS面试题（第五期）"><a href="#WebGIS面试题（第五期）" class="headerlink" title="WebGIS面试题（第五期）"></a>WebGIS面试题（第五期）</h2><p>以下题目仅为部分题目，全部题目在公众号{GISer世界}，答案仅供参考</p><h3 id="1、Cesium的核心组件有哪些？"><a href="#1、Cesium的核心组件有哪些？" class="headerlink" title="1、Cesium的核心组件有哪些？"></a>1、Cesium的核心组件有哪些？</h3><p>Cesium的核心组件包括Viewer、Scene、Model、Geometry、Material和Camera等。其中，Viewer是Cesium的主要接口，用于加载和显示3D地球和地图；Scene是场景管理器，负责管理所有的实体，如地形、建筑物、标记等；Camera则定义了视角和视距。</p><p><strong>具体：</strong></p><ol><li><strong>Viewer（查看器）</strong>：Cesium的主要入口点之一。提供了一个用于渲染三维地球的Canvas或WebGL容器，并管理了场景、相机、光照等方面的状态。</li><li><strong>Scene（场景）</strong>：表示三维场景的对象，包括地球、模型、图像等。负责管理渲染的对象、光照、相机等方面。</li><li><strong>Primitive（原始对象）</strong>：Cesium中的基本渲染单元，可用于表示地形、实体、模型等。它们可以是点、线、多边形等形式，用于构建复杂的地球表面和场景。</li><li><strong>Imagery（影像）</strong>：用于加载和显示地球表面图像的组件。支持各种地图服务提供商（如谷歌地图、Bing Maps等）以及自定义图像。</li><li><strong>Terrain（地形）</strong>：用于加载和显示地球表面高程数据的组件。允许将真实世界的地形数据集成到Cesium应用程序中，以实现更真实的地球模拟。</li><li><strong>Entity（实体）</strong>：表示三维场景中的可渲染对象，如飞机、汽车、点标记等。可以具有位置、方向、大小、外观等属性，并可以在场景中动态更新。</li><li><strong>Camera（相机）</strong>：控制场景视角的组件。允许用户控制相机位置、方向、缩放等参数，以浏览和导航场景。</li><li><strong>Geometry（几何体）</strong>：用于创建和处理几何形状的组件，如球体、盒子、圆柱体等。可以用于创建自定义的地球表面对象或模型。</li><li><strong>Interpolation（插值）</strong>：提供了在场景中执行插值和动画的功能。可以用于平滑地过渡相机位置、实体属性等。</li></ol><p>这些是Cesium中一些核心的组件，用于构建各种类型的三维地球和地球上的应用程序。</p><h3 id="2、请解释一下Cesium中的3D-Tiles技术及其作用。"><a href="#2、请解释一下Cesium中的3D-Tiles技术及其作用。" class="headerlink" title="2、请解释一下Cesium中的3D Tiles技术及其作用。"></a>2、请解释一下Cesium中的3D Tiles技术及其作用。</h3><p>3D Tiles是Cesium中用于高效地加载和显示大规模的3D地球数据的技术。它可以将复杂的3D数据分层并进行高度优化，支持大规模的3D地球数据，包括城市、建筑、地形等，从而提高数据的加载速度和显示效率。</p><p><strong>具体：</strong></p><ol><li><strong>数据组织</strong>：3D Tiles技术允许地理数据按照层次结构进行组织，将地球表面划分为一系列的瓦片（tiles）。这些瓦片可以根据需要进行分辨率和细节层次的变化，使得数据可以在不同的缩放级别下进行加载和显示。</li><li><strong>数据压缩</strong>：3D Tiles使用各种压缩技术对地理数据进行压缩，以减少数据的存储和传输开销。这包括空间压缩、纹理压缩等技术，可以大大减少数据文件的大小，提高数据传输效率。</li><li><strong>动态加载</strong>：3D Tiles允许根据视图的位置和缩放级别动态加载和卸载数据瓦片，使得在浏览大范围地理区域时可以实现流畅的体验。这种动态加载的机制可以最大程度地减少内存和网络资源的占用。</li><li><strong>多样化数据支持</strong>：3D Tiles技术不仅可以用于地形数据，还可以用于表示建筑物、植被、城市模型等多种类型的地理数据。这使得Cesium可以呈现出丰富多样的地球表面细节，从而提供更具交互性和真实感的地理应用体验。</li><li><strong>开放标准</strong>：3D Tiles是一个开放的规范，其设计思想是为了支持各种类型的地理数据和应用场景。这意味着开发者可以自由地使用和扩展3D Tiles规范，以满足不同应用的需求。</li></ol><h3 id="3、CZML是什么，以及它用于描述什么样的场景？"><a href="#3、CZML是什么，以及它用于描述什么样的场景？" class="headerlink" title="3、CZML是什么，以及它用于描述什么样的场景？"></a>3、CZML是什么，以及它用于描述什么样的场景？</h3><p>CZML（Cesium Language）是一种描述和显示动态的地球场景的数据格式。它可以用于描述航班轨迹、气象数据、卫星运行轨迹等。CZML中可以包含实体的位置、速度、方向等信息，以及可视化效果的设置。</p><p><strong>具体：</strong></p><p>CZML可以描述的场景包括但不限于：</p><ol><li><strong>地球上的实体和标记</strong>：如建筑物、飞机、汽车、船舶等。这些实体可以具有位置、方向、大小、形状、颜色等属性，并且可以在时间上动态变化。</li><li><strong>传感器和效果</strong>：如雷达、热成像仪等传感器的位置和扫描范围，以及火焰、烟雾等效果的位置和状态。</li><li><strong>时间动画</strong>：CZML可以描述场景中各个元素随时间变化的行为。例如，可以定义飞机的航迹、车辆的移动路径、建筑物的建造过程等。</li><li><strong>地球上的图形和形状</strong>：如多边形、圆形、线条等。这些图形可以用于绘制地图上的区域、路径、边界等。</li><li><strong>图像和文本标签</strong>：CZML还支持在地球表面上添加图像、文本标签等元素，用于展示地理信息或其他内容。</li></ol><h3 id="4、Cesium如何处理地理位置信息？"><a href="#4、Cesium如何处理地理位置信息？" class="headerlink" title="4、Cesium如何处理地理位置信息？"></a>4、Cesium如何处理地理位置信息？</h3><p>Cesium使用ECEF（Earth-Centered, Earth-Fixed）坐标系来处理地理位置信息。ECEF坐标系是一种以地球中心为原点，以赤道面为基准面的三维坐标系。开发者可以使用Cesium的Cartographic类来转换地理位置信息到ECEF坐标系，或者使用Cesium的Ellipsoid类来计算地理位置信息的距离和面积。</p><p><strong>具体：</strong></p><p>Cesium 使用 ECEF（Earth-Centered, Earth-Fixed）坐标系作为其核心坐标系统来处理地理空间数据。ECEF 坐标系以地球的中心为原点，其 X 轴指向本初子午线与赤道的交点，Y 轴指向赤道与东经 90 度的交点，Z 轴指向北极。这种坐标系对于描述地球表面和空间中点的位置非常有用。</p><p>在 Cesium 中，经常需要处理不同坐标系之间的转换。<code>Cartographic</code> 类是 Cesium 中用于表示地理坐标（经度、纬度和高度）的类，而 <code>Cartesian3</code> 类则用于表示 ECEF 坐标系中的三维坐标。Cesium 提供了一系列方法，允许在 <code>Cartographic</code> 和 <code>Cartesian3</code> 之间进行转换。</p><p>1、可以使用 <code>Cartographic.toCartesian</code> 方法将地理坐标转换为 ECEF 坐标：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cartographic = <span class="title class_">Cesium</span>.<span class="property">Cartographic</span>.<span class="title function_">fromDegrees</span>(longitude, latitude, height);  </span><br><span class="line"><span class="keyword">var</span> cartesian3 = <span class="title class_">Cesium</span>.<span class="property">Cartographic</span>.<span class="title function_">toCartesian</span>(cartographic);</span><br></pre></td></tr></table></figure><p>2、也可以使用 <code>Cartesian3.toCartographic</code> 方法将 ECEF 坐标转换回地理坐标：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cartesian3 = ...; <span class="comment">// 已有的 ECEF 坐标  </span></span><br><span class="line"><span class="keyword">var</span> cartographic = <span class="title class_">Cesium</span>.<span class="property">Cartesian3</span>.<span class="title function_">toCartographic</span>(cartesian3, ellipsoid);</span><br></pre></td></tr></table></figure><p>这里的 <code>ellipsoid</code> 是 <code>Ellipsoid</code> 类的实例，代表了地球的椭球模型。Cesium 默认使用 WGS84 椭球模型，但也可以根据需要创建其他椭球模型。</p><p><code>Ellipsoid</code> 类还提供了许多有用的方法来计算基于椭球模型的地理属性，比如两点之间的距离、区域的面积等。如使用 <code>Ellipsoid.cartesianDistanceTo</code> 方法可以计算两个 ECEF 坐标之间的距离：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cartesian1 = ...; <span class="comment">// 第一个 ECEF 坐标  </span></span><br><span class="line"><span class="keyword">var</span> cartesian2 = ...; <span class="comment">// 第二个 ECEF 坐标  </span></span><br><span class="line"><span class="keyword">var</span> distance = <span class="title class_">Cesium</span>.<span class="property">Ellipsoid</span>.<span class="property">WGS84</span>.<span class="title function_">cartesianDistanceTo</span>(cartesian1, cartesian2);</span><br></pre></td></tr></table></figure><h3 id="5、Cesium支持哪些地图源？"><a href="#5、Cesium支持哪些地图源？" class="headerlink" title="5、Cesium支持哪些地图源？"></a>5、Cesium支持哪些地图源？</h3><p>Cesium支持多种地图源，包括OpenStreetMap、Bing Maps、Google Maps等。它提供了一个统一的接口来加载和显示这些地图源。</p><p><strong>具体：</strong></p><ol><li><strong>Cesium Ion</strong>：Cesium Ion是Cesium提供的基于云的服务，提供了高分辨率的地球表面图像和地形数据。开发者可以通过Cesium Ion订阅地图服务，以便在Cesium应用程序中显示实时更新的地图数据。</li><li><strong>Bing Maps</strong>：Cesium可以直接集成Bing Maps提供的地图服务，包括卫星影像、地图和街景等图层。</li><li><strong>Google Maps</strong>：虽然Cesium不能直接集成Google Maps，但是开发者可以使用Cesium的ImageryProvider接口来创建自定义的图像图层，并通过Google Maps API获取地图图像，并将其显示在Cesium应用程序中。</li><li><strong>OpenStreetMap</strong>：Cesium可以直接集成OpenStreetMap提供的地图服务，包括地图、卫星影像和地形等图层。</li><li><strong>Mapbox</strong>：Cesium可以直接集成Mapbox提供的地图服务，包括地图、卫星影像和地形等图层。开发者可以使用Mapbox的样式和图层来自定义地图的外观。</li><li><strong>USGS高程数据</strong>：Cesium可以直接集成USGS提供的地形数据，以显示真实的地球表面高程。</li><li><strong>自定义地图服务</strong>：除了以上提到的地图服务之外，开发者还可以使用Cesium的ImageryProvider和TerrainProvider接口来集成自定义的地图服务，包括WMS、TMS等标准地图服务。</li></ol><h3 id="6、你的项目中有加载十几个G的模型，你自己有没有进行过优化处理，在Cesium种如何处理大数据量的场景"><a href="#6、你的项目中有加载十几个G的模型，你自己有没有进行过优化处理，在Cesium种如何处理大数据量的场景" class="headerlink" title="6、你的项目中有加载十几个G的模型，你自己有没有进行过优化处理，在Cesium种如何处理大数据量的场景?"></a>6、你的项目中有加载十几个G的模型，你自己有没有进行过优化处理，在Cesium种如何处理大数据量的场景?</h3><p>Cesium使用WebGL进行渲染，WebGL是一种基于GPU的渲染技术，可以有效地处理大数据量的场景。此外，Cesium还使用了Occlusion Culling（遮挡剔除）和Billboard Rendering（广告牌渲染）等优化技术，进一步减少了渲染负载。</p><p><strong>具体：</strong></p><ol><li><p>使用Level of Detail (LOD) 技术<br>LOD技术是处理大规模地形和模型数据的有效方法。通过为模型定义不同的细节级别，Cesium可以根据相机与模型的距离动态地切换模型的细节。这样，当模型远离相机时，使用较低精度的模型，从而减少渲染的复杂性和提高性能。</p></li><li><p>利用Octree结构<br>对于大规模的模型，可以使用Octree（八叉树）结构来组织和管理模型的节点。八叉树可以将空间分割成多个区域，并在每个区域内存储模型数据。这样，当相机移动时，只需要渲染相机视野内的模型部分，从而提高渲染效率。</p></li><li><p>遮挡剔除 (Occlusion Culling)<br>遮挡剔除是一种优化技术，可以识别并剔除那些在当前视角下被其他对象完全遮挡的模型部分。这样可以减少不必要的渲染计算，提高性能。</p></li><li><p>地形和建筑物的分块加载<br>将地形和建筑物数据分成小块，只加载相机视野内的块。这种方法可以减少一次性加载的数据量，并且可以根据需要异步加载其他块。</p></li><li><p>使用批处理 (Batch Table) 技术<br>批处理技术可以将多个模型合并为一个绘制调用，减少GPU的调用次数，提高渲染效率。Cesium的批处理功能可以自动合并相邻的相同材质的模型。</p></li><li><p>利用Cesium的动态几何加载<br>对于非常大的模型，如建筑物或者地形，可以使用Cesium的动态几何加载功能。这种功能允许模型在不同的距离级别下使用不同精度的几何体，从而在保持视觉效果的同时减少渲染负担。</p></li><li><p>优化材质和纹理<br>减少材质和纹理的复杂性和数量，使用压缩纹理和MIPmapping技术，可以减少GPU的负担。同时，合理地使用材质和纹理的LOD，可以进一步提高性能。</p></li><li><p>使用Web Workers<br>Web Workers可以在后台线程中执行任务，从而不会阻塞主线程。通过将一些计算密集型的任务，如模型的解析和处理，放在Web Workers中执行，可以提高应用程序的响应性。</p></li><li><p>利用Cesium的TileLoadProgress事件<br>通过监听TileLoadProgress事件，可以监控模型的加载进度，并根据需要动态调整加载策略，如暂停或取消某些不必要的加载任务。</p></li><li><p>预先加载和缓存<br>对于经常需要显示的模型，可以预先加载并缓存到本地，减少每次加载的时间。同时，合理地管理缓存策略，确保缓存的数据是最新的，避免过时数据的加载。</p></li><li><p>模型简化：我本人的研究也就是进行模型简化，这也是当前研究的热点，主要基于简化算法进行模型简化，降低模型的冗余。简单来说就是减少不重要的细节。</p><p>以上一些仅供参考。</p><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2></li></ol><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/294b6a04/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
