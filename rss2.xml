<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>纸飞机的旅行</title>
    <link>https://jhcgnb.cn/</link>
    
    <atom:link href="https://jhcgnb.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>选择有时候比努力更重要</description>
    <pubDate>Sun, 14 Jul 2024 02:58:53 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>page</title>
      <link>https://jhcgnb.cn/posts/140ab620/</link>
      <guid>https://jhcgnb.cn/posts/140ab620/</guid>
      <pubDate>Sun, 14 Jul 2024 02:48:42 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h4&gt;&lt;p&gt;近期看到好多小伙伴在寻找WebGIS方面的面试题，正好本人之前也因自己面试分享过一些面试题，秋招目前逐步也快结束了，所以我现</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>近期看到好多小伙伴在寻找WebGIS方面的面试题，正好本人之前也因自己面试分享过一些面试题，秋招目前逐步也快结束了，所以我现在慢慢整理一些包括自己面试以及网上公开的一些我认为有用的面试题，仅供参考，大多面试主要会围绕你自己简历上的项目以及其他进行展开提问，所以说自己的简历才是最重要的。以下内容作为辅助。（本期为第二期分享。第一期分享：<a href="https://blog.csdn.net/weixin_44857463/article/details/133197256">WebGIS面试（中海达）</a>）</p><h4 id="二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）"><a href="#二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）" class="headerlink" title="二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）"></a>二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）</h4><p>注意webgis面试不一定只问一些GIS相关的，还会提问众多技术相关问题；本人的答案也不一定正确，仅供参考！！！</p><h5 id="1、说一说路由生命周期（也叫导航守卫）"><a href="#1、说一说路由生命周期（也叫导航守卫）" class="headerlink" title="1、说一说路由生命周期（也叫导航守卫）"></a>1、说一说<strong>路由生命周期（也叫导航守卫）</strong></h5><p>路由生命周期，也叫导航守卫，是指在前端Web应用中，控制路由的跳转和导航过程中的一系列事件和钩子函数，用于实现路由的权限控制、数据加载、页面渲染等操作。这些生命周期事件和钩子函数可以根据需要在路由跳转前、跳转时、跳转后执行不同的操作，以确保应用的正确运行和用户体验。</p><p>在Vue.js和Vue Router中，通常有三种导航守卫：</p><ol><li><p><strong>全局前置守卫</strong>：这些守卫会在路由跳转之前触发，允许你执行一些全局的操作，比如权限检查、全局数据加载等。常见的全局前置守卫包括<code>beforeEach</code>。</p></li><li><p><strong>路由独享的守卫</strong>：这些守卫是路由配置中独立于全局守卫的守卫，它们会在特定路由跳转时触发。常见的路由独享守卫包括<code>beforeEnter</code>。</p></li><li><p><strong>全局后置守卫</strong>：这些守卫会在路由跳转完成后触发，允许你执行一些全局的操作，比如页面统计、日志记录等。常见的全局后置守卫包括<code>afterEach</code>。</p></li></ol><p>以下是这些守卫的主要用途和执行时机：</p><ul><li><p><strong>beforeEach</strong>：在路由跳转前执行，通常用于权限控制和全局数据加载。如果在<code>beforeEach</code>中返回<code>false</code>，则路由跳转将被中止。</p></li><li><p><strong>beforeEnter</strong>：在路由配置中独享的守卫，用于特定路由的权限控制和数据加载。</p></li><li><p><strong>afterEach</strong>：在路由跳转完成后执行，通常用于页面切换动画、页面统计等全局操作。</p></li></ul><p>此外，还有一些其他的路由守卫，比如：</p><ul><li><p><strong>beforeResolve</strong>：在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后触发。</p></li><li><p><strong>beforeRouteEnter</strong>：在路由进入前触发，但无法访问组件实例，通常用于异步路由组件。</p></li><li><p><strong>beforeRouteUpdate</strong>：在当前路由改变，但路由参数未改变时触发，用于复用组件。</p></li><li><p><strong>beforeRouteLeave</strong>：在路由离开前触发，通常用于确认离开或取消导航。</p></li></ul><p>这些守卫可以在Vue Router的路由配置中使用，以便更好地控制前端应用的路由导航和行为。根据具体需求，你可以选择使用不同的守卫来实现路由的各种功能，如权限控制、数据加载、页面切换动画等。</p><h5 id="2、关于你在简历中提到的项目-都使用了那些技术栈来进行开发"><a href="#2、关于你在简历中提到的项目-都使用了那些技术栈来进行开发" class="headerlink" title="2、关于你在简历中提到的项目,都使用了那些技术栈来进行开发?"></a>2、关于你在简历中提到的项目,都使用了那些技术栈来进行开发?</h5><p>这个需要结合自己擅长的技术栈以及以及自己的简历。</p><h5 id="3、说一下天地图这个服务是什么格式的类型-具体是怎样加载出来的"><a href="#3、说一下天地图这个服务是什么格式的类型-具体是怎样加载出来的" class="headerlink" title="3、说一下天地图这个服务是什么格式的类型,具体是怎样加载出来的?"></a>3、说一下天地图这个服务是什么格式的类型,具体是怎样加载出来的?</h5><p>“天地图”是中国国家测绘局（National Administration of Surveying, Mapping, and Geoinformation）推出的一套在线地图服务，提供了中国地图的相关数据。这些地图数据通常以标准的Web地图瓦片格式提供，常见的格式包括瓦片图层（Tile Layers）和矢量图层（Vector Layers）。</p><ol><li><p><strong>瓦片图层（Tile Layers）</strong>：这是最常见的地图数据加载方式，天地图提供了标准的瓦片图层，以瓦片（tiles）的形式分割地图，每个瓦片包含一小块地图数据，通常是图片格式，如PNG。你可以通过URL获取这些瓦片并将它们加载到地图上，以显示地图数据。通常，这些URL包括瓦片的x、y坐标和缩放级别，以确保你获取到正确的地图数据。</p></li><li><p><strong>矢量图层（Vector Layers）</strong>：除了瓦片地图，天地图还提供一些矢量地图数据，通常以矢量图层的形式提供。这些数据可以是GeoJSON、KML、WMS等格式。你可以使用前端地图库（如Leaflet、OpenLayers、Mapbox等）加载这些矢量数据，并在地图上绘制要素，如道路、河流、建筑物等。</p></li></ol><p>加载天地图服务通常需要以下步骤：</p><ol><li><p><strong>获取访问权限</strong>：首先，你需要获取访问天地图服务的权限，通常需要在天地图官方网站注册并获取API密钥或访问令牌。</p></li><li><p><strong>选择地图类型</strong>：天地图提供了多种地图类型，如卫星地图、道路地图、地形地图等。根据你的需求选择适合的地图类型。</p></li><li><p><strong>加载地图库</strong>：使用前端地图库，如Leaflet、OpenLayers等，加载地图。你需要在你的网页中引入相应的地图库文件，并创建一个地图容器。</p></li><li><p><strong>添加图层</strong>：根据你的选择，添加天地图的瓦片图层或矢量图层到地图上。如果是瓦片地图，你需要设置天地图瓦片服务的URL，包括x、y坐标和缩放级别。如果是矢量地图，你需要加载相应的矢量数据。</p></li><li><p><strong>设置地图视图</strong>：根据你的需求，设置地图的初始中心点和缩放级别，以及其他交互行为，如缩放、拖动等。</p></li><li><p><strong>处理用户交互</strong>：根据需要，添加交互控件，如放大缩小按钮、信息弹出框等，以增强用户体验。</p></li><li><p><strong>部署到网页</strong>：将配置好的地图应用嵌入到你的网页中，用户可以通过浏览器访问并与地图进行交互。</p></li></ol><p>天地图服务提供了中国地图数据，可以通过瓦片图层或矢量图层的形式加载到前端地图库中，以在网页中显示地图数据并提供交互功能。</p><h5 id="4、在-openLayers-中如何加载-WMTS-服务"><a href="#4、在-openLayers-中如何加载-WMTS-服务" class="headerlink" title="4、在 openLayers 中如何加载 WMTS 服务?"></a>4、在 openLayers 中如何加载 WMTS 服务?</h5><p>在 OpenLayers 中加载WMTS（Web Map Tile Service）服务涉及一系列步骤，包括设置图层、创建地图、配置WMTS图层和视图。<strong>面试可简单回答：</strong></p><ol><li><strong>创建地图容器</strong>：首先，需要在HTML中创建一个<code>&lt;div&gt;</code>容器，用于显示地图。</li><li><strong>初始化地图对象</strong>：使用OpenLayers，初始化一个地图对象，并指定地图的目标容器。</li><li><strong>配置WMTS图层</strong>：设置WMTS图层的参数，包括服务URL、图层名称、图像格式、投影、瓦片网格等。确保提供正确的URL和其他相关信息。</li><li><strong>创建WMTS图层</strong>：基于配置的WMTS源，创建一个WMTS图层。</li><li><strong>将图层添加到地图</strong>：将WMTS图层添加到地图对象中，以便在地图上显示相关地图数据。</li><li><strong>设置地图视图</strong>：配置地图的初始视图，包括中心点和缩放级别。确保投影和坐标系设置正确。</li><li><strong>加载地图</strong>：确保地图被成功加载到页面中，可以添加额外的交互控件，如缩放按钮。</li></ol><p>强调在步骤3中需要注意WMTS图层的配置，包括URL、图层名称、图像格式、投影、瓦片网格等，这些是加载WMTS服务的关键参数。</p><p><strong>以下是详细的介绍，</strong></p><ol><li><strong>引入 OpenLayers 库</strong>：首先，确保你在网页中引入了OpenLayers库的JavaScript文件。你可以从OpenLayers的官方网站下载最新版本的库文件并在HTML中引入。</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/ol@6.10.1/dist/ol.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建地图容器</strong>：在HTML中创建一个用于显示地图的<code>&lt;div&gt;</code>容器。</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;map&quot;</span> <span class="attr">class</span>=<span class="string">&quot;map&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>初始化地图对象</strong>：在JavaScript中，初始化OpenLayers地图对象，并指定地图的目标容器。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> ol.<span class="title class_">Map</span>(&#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;map&#x27;</span>, <span class="comment">// 这里的&#x27;map&#x27;是你创建的地图容器的ID</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>配置WMTS图层</strong>：设置WMTS图层的相关参数，包括图层来源（source）、投影（projection）、瓦片网格（tile grid）等。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建WMTS源</span></span><br><span class="line"><span class="keyword">var</span> wmtsSource = <span class="keyword">new</span> ol.<span class="property">source</span>.<span class="title function_">WMTS</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://your-wmts-service-url.com&#x27;</span>, <span class="comment">// 替换为你的WMTS服务URL</span></span><br><span class="line">  <span class="attr">layer</span>: <span class="string">&#x27;your-wmts-layer&#x27;</span>, <span class="comment">// 替换为你的WMTS图层名</span></span><br><span class="line">  <span class="attr">format</span>: <span class="string">&#x27;image/png&#x27;</span>, <span class="comment">// 图像格式，根据服务配置</span></span><br><span class="line">  <span class="attr">matrixSet</span>: <span class="string">&#x27;your-matrix-set&#x27;</span>, <span class="comment">// 替换为你的矩阵集</span></span><br><span class="line">  <span class="attr">projection</span>: <span class="string">&#x27;EPSG:4326&#x27;</span>, <span class="comment">// 替换为你的投影</span></span><br><span class="line">  <span class="attr">tileGrid</span>: <span class="keyword">new</span> ol.<span class="property">tilegrid</span>.<span class="title function_">WMTS</span>(&#123;</span><br><span class="line">    <span class="attr">origin</span>: [-<span class="number">180</span>, <span class="number">90</span>], <span class="comment">// 瓦片网格的原点</span></span><br><span class="line">    <span class="attr">resolutions</span>: [<span class="number">0.703125</span>, <span class="number">0.3515625</span>, <span class="number">0.17578125</span>, ...], <span class="comment">// 分辨率数组，根据服务配置</span></span><br><span class="line">    <span class="attr">matrixIds</span>: [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, ...], <span class="comment">// 矩阵ID数组，根据服务配置</span></span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建WMTS图层</span></span><br><span class="line"><span class="keyword">var</span> wmtsLayer = <span class="keyword">new</span> ol.<span class="property">layer</span>.<span class="title class_">Tile</span>(&#123;</span><br><span class="line">  <span class="attr">source</span>: wmtsSource,</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>添加图层到地图</strong>：将创建的WMTS图层添加到地图对象中。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.<span class="title function_">addLayer</span>(wmtsLayer);</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>设置地图视图</strong>：配置地图的初始视图，包括中心点、缩放级别等。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> view = <span class="keyword">new</span> ol.<span class="title class_">View</span>(&#123;</span><br><span class="line">  <span class="attr">center</span>: [<span class="number">0</span>, <span class="number">0</span>], <span class="comment">// 中心点坐标</span></span><br><span class="line">  <span class="attr">zoom</span>: <span class="number">2</span>, <span class="comment">// 初始缩放级别</span></span><br><span class="line">  <span class="attr">projection</span>: <span class="string">&#x27;EPSG:4326&#x27;</span>, <span class="comment">// 投影</span></span><br><span class="line">&#125;);</span><br><span class="line">map.<span class="title function_">setView</span>(view);</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>加载地图</strong>：最后，确保地图被正确加载到页面中。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果有需要，可以添加其他交互控件，如缩放按钮、导航控件等</span></span><br><span class="line">map.<span class="title function_">addControl</span>(<span class="keyword">new</span> ol.<span class="property">control</span>.<span class="title class_">Zoom</span>());</span><br></pre></td></tr></table></figure><p>通过上述步骤，可以成功加载WMTS服务并显示在OpenLayers地图中。记得替换示例代码中的URL、图层名称、矩阵集、分辨率、矩阵ID等参数，以适应的具体WMTS服务。</p><h5 id="5、刚才有提到-WMS-可以具体说一下-WMS和-WMTS-两者的区别吗"><a href="#5、刚才有提到-WMS-可以具体说一下-WMS和-WMTS-两者的区别吗" class="headerlink" title="5、刚才有提到 WMS,可以具体说一下 WMS和 WMTS 两者的区别吗?"></a>5、刚才有提到 WMS,可以具体说一下 WMS和 WMTS 两者的区别吗?</h5><p>当涉及到地理信息系统（GIS）和地图服务时，WMS（Web Map Service）和WMTS（Web Map Tile Service）是两种不同的标准，它们有一些重要的区别：</p><ol><li><p><strong>数据传输方式</strong>：</p><ul><li><strong>WMS</strong>：WMS是基于请求-响应模式的。每次请求地图数据时，WMS服务器会动态生成地图图像，然后将整个地图图像作为响应传送给客户端。这意味着每次请求都生成新的地图图像，适用于动态数据和图层的情况，但可能会导致性能较差。</li><li><strong>WMTS</strong>：WMTS采用了瓦片式数据传输，地图被分成小块瓦片，每个瓦片都是一个预先生成的图像。这些瓦片在服务器端预先渲染，客户端通过直接请求这些瓦片来加载地图数据。这种方式通常更高效，尤其适用于静态地图数据，因为无需在每次请求时生成新的地图图像。</li></ul></li><li><p><strong>性能</strong>：</p><ul><li><strong>WMS</strong>：由于动态生成地图图像，WMS可能在性能上不如WMTS，尤其是在大规模地图和高并发请求的情况下。</li><li><strong>WMTS</strong>：WMTS的性能通常更好，因为瓦片数据是预先生成的，服务器只需提供瓦片即可，不需要在每次请求时进行渲染。</li></ul></li><li><p><strong>缓存</strong>：</p><ul><li><strong>WMS</strong>：WMS通常需要客户端自行管理图像的缓存，因为每次请求都会生成新的图像。这可能导致客户端性能问题，因为需要存储大量的图像数据。</li><li><strong>WMTS</strong>：WMTS的瓦片式数据天然适合缓存，因为瓦片是静态的，可以被有效地缓存。客户端可以从缓存中加载瓦片，减轻了服务器和客户端的负担。</li></ul></li><li><p><strong>灵活性</strong>：</p><ul><li><strong>WMS</strong>：WMS提供更多的灵活性，因为它可以在每次请求时动态生成地图图像，允许对地图进行实时操作和渲染。适用于需要动态数据的应用场景。</li><li><strong>WMTS</strong>：WMTS提供了稳定和可预测的地图显示，但通常不支持实时数据更新或动态渲染，因为瓦片是静态的。</li></ul></li></ol><p>总结来说，WMS和WMTS都是用于在Web上提供地图数据的标准，但它们的工作方式和适用场景有所不同。选择哪种标准取决于你的具体需求。如果需要实时渲染和动态数据，WMS可能更合适。如果需要更高的性能和稳定性，以及静态地图数据，WMTS可能是更好的选择。</p><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/140ab620/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>page</title>
      <link>https://jhcgnb.cn/posts/140ab620/</link>
      <guid>https://jhcgnb.cn/posts/140ab620/</guid>
      <pubDate>Sun, 14 Jul 2024 02:47:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/b645139064c54e2aaaae86ecb54ea1ed.jpeg&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、Cesium中有几种拾取坐标的方式，分别介绍&quot;&gt;&lt;a hr</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://img-blog.csdnimg.cn/b645139064c54e2aaaae86ecb54ea1ed.jpeg" alt="在这里插入图片描述"></p><h2 id="1、Cesium中有几种拾取坐标的方式，分别介绍"><a href="#1、Cesium中有几种拾取坐标的方式，分别介绍" class="headerlink" title="1、Cesium中有几种拾取坐标的方式，分别介绍"></a>1、Cesium中有几种拾取坐标的方式，分别介绍</h2><p>Cesium是一个用于创建3D地球和地理空间应用的JavaScript库。在Cesium中，你可以使用不同的方式来拾取坐标，以便与地球或地图上的对象进行交互。以下是Cesium中几种常见的拾取坐标的方式：</p><ol><li><p>鼠标拾取（Mouse Picking）：<br>通过监听鼠标事件（例如鼠标单击或移动）并使用Cesium的API来检测鼠标指针在地球表面的位置。通常使用<code>scene.pick</code>函数来执行鼠标拾取。这个方法返回一个包含有关拾取位置和被选对象的信息的对象。你可以使用以下代码示例来执行鼠标拾取：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> viewer = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Viewer</span>(<span class="string">&#x27;cesiumContainer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">ScreenSpaceEventHandler</span>(viewer.<span class="property">scene</span>.<span class="property">canvas</span>);</span><br><span class="line"></span><br><span class="line">handler.<span class="title function_">setInputAction</span>(<span class="keyword">function</span> (<span class="params">movement</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pickedObject = viewer.<span class="property">scene</span>.<span class="title function_">pick</span>(movement.<span class="property">endPosition</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Cesium</span>.<span class="title function_">defined</span>(pickedObject)) &#123;</span><br><span class="line">        <span class="comment">// 在这里处理拾取到的对象</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Picked object:&#x27;</span>, pickedObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="title class_">Cesium</span>.<span class="property">ScreenSpaceEventType</span>.<span class="property">LEFT_CLICK</span>);</span><br></pre></td></tr></table></figure></li><li><p>键盘拾取（Keyboard Picking）：<br>类似于鼠标拾取，你还可以使用键盘事件来触发拾取操作。这通常用于处理键盘快捷键，以选择或操作场景中的对象。</p></li><li><p>空间拾取（Space Picking）：<br>空间拾取允许你在3D空间中选择对象，而不仅仅是地球表面。你可以使用<code>scene.pickPosition</code>方法来执行空间拾取。这允许你在地球表面之上或以下选择对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> viewer = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Viewer</span>(<span class="string">&#x27;cesiumContainer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">ScreenSpaceEventHandler</span>(viewer.<span class="property">scene</span>.<span class="property">canvas</span>);</span><br><span class="line"></span><br><span class="line">handler.<span class="title function_">setInputAction</span>(<span class="keyword">function</span> (<span class="params">movement</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cartesian = viewer.<span class="property">scene</span>.<span class="title function_">pickPosition</span>(movement.<span class="property">endPosition</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Cesium</span>.<span class="title function_">defined</span>(cartesian)) &#123;</span><br><span class="line">        <span class="comment">// 在这里处理拾取到的空间坐标</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Picked position:&#x27;</span>, cartesian);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="title class_">Cesium</span>.<span class="property">ScreenSpaceEventType</span>.<span class="property">LEFT_CLICK</span>);</span><br></pre></td></tr></table></figure></li><li><p>图元拾取（Primitive Picking）：<br>你还可以通过操作Cesium中的图元对象来实现拾取。图元是可渲染的3D对象，你可以将它们添加到场景中并监听事件以执行拾取操作。</p><ol><li><p><strong>创建图元</strong>：<br>首先，你需要创建一个或多个图元并将它们添加到Cesium的场景中。这可以通过使用Cesium提供的不同类型的图元类来完成，如<code>Cesium.PointPrimitive</code>, <code>Cesium.Model</code>, <code>Cesium.Polyline</code>, 等等。这些图元可以包含你要在地球上显示的内容。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> viewer = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Viewer</span>(<span class="string">&#x27;cesiumContainer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个点图元</span></span><br><span class="line"><span class="keyword">var</span> point = viewer.<span class="property">entities</span>.<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="attr">position</span>: <span class="title class_">Cesium</span>.<span class="property">Cartesian3</span>.<span class="title function_">fromDegrees</span>(-<span class="number">75.0</span>, <span class="number">40.0</span>),</span><br><span class="line">    <span class="attr">point</span>: &#123;</span><br><span class="line">        <span class="attr">pixelSize</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">color</span>: <span class="title class_">Cesium</span>.<span class="property">Color</span>.<span class="property">RED</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个模型图元</span></span><br><span class="line"><span class="keyword">var</span> model = viewer.<span class="property">entities</span>.<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="attr">position</span>: <span class="title class_">Cesium</span>.<span class="property">Cartesian3</span>.<span class="title function_">fromDegrees</span>(-<span class="number">75.0</span>, <span class="number">40.0</span>),</span><br><span class="line">    <span class="attr">model</span>: &#123;</span><br><span class="line">        <span class="attr">uri</span>: <span class="string">&#x27;path/to/3dmodel.gltf&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>监听拾取事件</strong>：<br>接下来，你需要为场景添加一个事件监听器，以便在用户与图元交互时执行拾取操作。通常，你会监听鼠标点击事件或键盘事件来触发拾取。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">ScreenSpaceEventHandler</span>(viewer.<span class="property">scene</span>.<span class="property">canvas</span>);</span><br><span class="line"></span><br><span class="line">handler.<span class="title function_">setInputAction</span>(<span class="keyword">function</span> (<span class="params">click</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行图元拾取操作</span></span><br><span class="line">    <span class="keyword">var</span> pickedObject = viewer.<span class="property">scene</span>.<span class="title function_">pick</span>(click.<span class="property">position</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Cesium</span>.<span class="title function_">defined</span>(pickedObject)) &#123;</span><br><span class="line">        <span class="comment">// 在这里处理拾取到的图元对象</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Picked object:&#x27;</span>, pickedObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="title class_">Cesium</span>.<span class="property">ScreenSpaceEventType</span>.<span class="property">LEFT_CLICK</span>);</span><br></pre></td></tr></table></figure><p>上述代码中，我们监听了左击事件（<code>LEFT_CLICK</code>），但你可以根据需要选择不同的事件类型。</p></li><li><p><strong>处理拾取结果</strong>：<br>当拾取成功时，<code>viewer.scene.pick</code>将返回一个包含有关拾取结果的对象。你可以根据拾取结果来执行相关操作，如查看图元的属性、更改外观或执行其他操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handler.<span class="title function_">setInputAction</span>(<span class="keyword">function</span> (<span class="params">click</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pickedObject = viewer.<span class="property">scene</span>.<span class="title function_">pick</span>(click.<span class="property">position</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Cesium</span>.<span class="title function_">defined</span>(pickedObject)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pickedObject.<span class="property">id</span> === point) &#123;</span><br><span class="line">            <span class="comment">// 用户点击了点图元</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Picked Point:&#x27;</span>, pickedObject);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pickedObject.<span class="property">id</span> === model) &#123;</span><br><span class="line">            <span class="comment">// 用户点击了模型图元</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Picked Model:&#x27;</span>, pickedObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="title class_">Cesium</span>.<span class="property">ScreenSpaceEventType</span>.<span class="property">LEFT_CLICK</span>);</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，你可以创建图元、监听拾取事件，并根据用户的交互来执行相应的操作。这使得你能够实现与地图上的图元对象的高度交互性。请注意，不同类型的图元可能会有不同的属性和方法可供使用，你可以根据你的具体需求来处理拾取结果。</p></li></ol><p>这些是Cesium中一些常见的拾取坐标的方式。你可以根据你的应用需求选择合适的拾取方法来与地图上的对象进行交互。根据你的具体情况，还可以进一步定制拾取操作以实现更复杂的交互。</p><h2 id="2、1TB级别的数据加载到Cesium中如何在浏览器上显示"><a href="#2、1TB级别的数据加载到Cesium中如何在浏览器上显示" class="headerlink" title="2、1TB级别的数据加载到Cesium中如何在浏览器上显示"></a>2、1TB级别的数据加载到Cesium中如何在浏览器上显示</h2><p>将1TB级别的数据加载到Cesium中并在浏览器上显示需要经过一系列复杂的数据处理和性能优化步骤。以下是一般的操作流程和浏览器优化策略：</p><p><strong>1. 数据处理和准备</strong></p><p>在加载大规模数据之前，需要进行数据处理和准备，以减小数据量、提高加载性能，以及将数据转化为Cesium支持的格式。以下是一些可能需要考虑的数据处理步骤：</p><ul><li><strong>数据分块化：</strong> 将数据分成多个块，根据用户视图范围动态加载可见数据。</li><li><strong>数据格式：</strong> 使用Cesium支持的数据格式，例如3D Tiles、glTF、Terrain Tiles、PointCloud格式等，以减小文件大小。</li><li><strong>数据索引：</strong> 在数据中建立索引以便快速访问和查询数据。</li><li><strong>数据压缩：</strong> 对数据进行压缩以减小传输和加载时间。</li><li><strong>LOD策略：</strong> 对于多分辨率数据，实现LOD策略，只加载合适分辨率的数据。</li></ul><p><strong>2. 服务器端优化</strong></p><p>在服务器端，你需要进行以下优化操作：</p><ul><li><strong>启用Gzip压缩：</strong> 配置服务器以使用Gzip或Brotli等压缩算法来减小数据传输大小。</li><li><strong>HTTP缓存：</strong> 使用HTTP缓存头来缓存数据，以减少重复加载。</li><li><strong>分布式存储：</strong> 如果可能，将数据存储在分布式存储系统中，以提高数据访问速度。</li></ul><p><strong>3. 数据加载策略</strong></p><p>对于1TB级别的数据，必须采用适当的数据加载策略，以确保浏览器不会因为过大的数据而崩溃或变得非常缓慢。以下是一些加载策略：</p><ul><li><strong>分块加载：</strong> 只加载用户视图范围内的数据块，可以使用Cesium的Tileset来实现。</li><li><strong>Web Workers：</strong> 利用Web Workers将数据加载和处理分离到后台线程，以防止阻塞主线程。</li><li><strong>Streaming：</strong> 尝试流式加载数据，以便在需要时逐步加载数据。</li></ul><p><strong>4. 数据可视化和交互</strong></p><p>一旦数据加载到Cesium中，你需要考虑如何可视化和交互，包括如何呈现大规模的数据以及如何处理用户的查询和拾取操作。这可能需要：</p><ul><li><strong>数据过滤：</strong> 实现数据过滤，以根据用户需求动态显示或隐藏部分数据。</li><li><strong>Level of Detail (LOD)：</strong> 对于多分辨率数据，使用LOD策略以降低细节级别，提高性能。</li><li><strong>GPU加速：</strong> 使用WebGL和GPU来加速渲染和处理大规模数据。</li><li><strong>数据聚合：</strong> 对于密集数据，可以考虑聚合数据以减少可视化的复杂性。</li></ul><p><strong>5. 浏览器优化</strong></p><p>在浏览器端，可以采取以下优化策略：</p><ul><li><strong>使用最新的浏览器：</strong> 确保用户使用支持WebGL 2.0和WebAssembly的最新浏览器版本，以获得更好的性能。</li><li><strong>WebGL性能：</strong> 使用WebGL性能分析工具来监测和优化3D场景的性能。</li><li><strong>内存管理：</strong> 谨慎管理内存，确保在加载大规模数据时不会超出浏览器的内存限制。</li><li><strong>异步加载：</strong> 使用异步加载资源，以避免阻塞页面渲染。</li><li><strong>用户体验优化：</strong> 提供用户友好的加载进度条和提示，以改善用户体验。</li></ul><p>请注意，处理和显示1TB级别的数据在Web浏览器中是一个复杂的任务，可能需要深入的性能优化和分布式计算。最终的优化策略会根据你的数据类型、用户需求和项目预算而有所不同。建议在开始项目之前进行详细的性能分析和规划，以确保最终的应用程序能够如预期般运行。</p><h2 id="3、VUE中兄弟组件之间如何传值"><a href="#3、VUE中兄弟组件之间如何传值" class="headerlink" title="3、VUE中兄弟组件之间如何传值"></a>3、VUE中兄弟组件之间如何传值</h2><p>在Vue.js中，兄弟组件之间传递数据可以通过以下几种方法来实现：</p><ol><li><p><strong>使用事件总线（Event Bus）：</strong> 通过创建一个事件总线实例，兄弟组件可以通过该实例来进行通信。这是一种非常灵活的方法，适用于复杂的组件通信需求。</p></li><li><p><strong>使用Vuex：</strong> Vuex是Vue.js的官方状态管理库，它可以用于在组件之间共享状态。虽然主要用于管理全局状态，但也可以用于兄弟组件之间的通信。</p></li><li><p><strong>通过父组件传递属性：</strong> 兄弟组件可以共享一个共同的父组件，父组件可以通过<code>props</code>将数据传递给子组件，从而间接地传递给其他子组件。</p></li><li><p><strong>使用自定义事件：</strong> 子组件可以触发自定义事件，而父组件可以监听这些事件来获取数据。</p></li></ol><p>下面我将演示一种通过自定义事件来实现兄弟组件之间数据传递的方法。</p><p><strong>示例代码：</strong></p><p>假设有两个兄弟组件 <code>SiblingA</code> 和 <code>SiblingB</code>，我们要在它们之间传递数据。</p><ol><li>创建一个名为 <code>EventBus.js</code> 的事件总线文件：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EventBus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">EventBus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>();</span><br></pre></td></tr></table></figure><ol start="2"><li>在 <code>SiblingA</code> 组件中触发自定义事件来传递数据：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;sendData&quot;&gt;Send Data to SiblingB&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; EventBus &#125; from &#x27;./EventBus.js&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendData() &#123;</span><br><span class="line">      const data = &#x27;Hello from SiblingA&#x27;;</span><br><span class="line">      EventBus.$emit(&#x27;data-sent&#x27;, data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 <code>SiblingB</code> 组件中监听自定义事件来接收数据：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Data received in SiblingB: &#123;&#123; receivedData &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; EventBus &#125; from &#x27;./EventBus.js&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      receivedData: &#x27;&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    EventBus.$on(&#x27;data-sent&#x27;, data =&gt; &#123;</span><br><span class="line">      this.receivedData = data;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这里的关键点是我们在 <code>SiblingA</code> 组件中使用 <code>EventBus.$emit</code> 来触发自定义事件，然后在 <code>SiblingB</code> 组件中使用 <code>EventBus.$on</code> 来监听同一个自定义事件，并在事件触发时接收数据。这样，数据就可以在兄弟组件之间传递了。</p><p>这是一种简单的方法来实现兄弟组件之间的数据传递。但请注意，对于大型应用程序，使用 Vuex 或通过父组件传递属性可能更有利于管理状态和数据传递。</p><h2 id="4、LocalStorage、cookie、sessionStorage之间的区别"><a href="#4、LocalStorage、cookie、sessionStorage之间的区别" class="headerlink" title="4、LocalStorage、cookie、sessionStorage之间的区别"></a>4、<strong>LocalStorage</strong>、cookie、sessionStorage之间的区别</h2><p><strong>LocalStorage</strong>、<strong>Cookies</strong>和<strong>SessionStorage</strong>都是在Web开发中用于存储数据的客户端存储解决方案，但它们在使用方式、存储持久性和用途上有一些关键区别。下面是它们之间的区别以及各自的优缺点：</p><p><strong>Cookies（HTTP Cookies）：</strong></p><ul><li><strong>持久性：</strong> Cookies可以设置持久性，即可以在指定的过期时间之前一直存在。</li><li><strong>存储容量：</strong> Cookies的存储容量通常较小，约为4KB左右。</li><li><strong>访问：</strong> 可以通过JavaScript和后端服务器来访问和设置Cookies。</li><li><strong>安全性：</strong> Cookies的安全性较低，因为它们可以被客户端修改，所以不适合存储敏感信息。</li><li><strong>用途：</strong> Cookies通常用于存储用户身份验证令牌、会话标识、跟踪用户行为等。</li></ul><p><strong>LocalStorage：</strong></p><ul><li><strong>持久性：</strong> LocalStorage是持久性的，数据不会在浏览器关闭后消失。</li><li><strong>存储容量：</strong> LocalStorage的存储容量通常较大，一般为5-10MB左右（不同浏览器可能有不同限制）。</li><li><strong>访问：</strong> 可以通过JavaScript来访问和设置LocalStorage。</li><li><strong>安全性：</strong> LocalStorage的安全性较高，因为它不容易被客户端修改。</li><li><strong>用途：</strong> LocalStorage通常用于长期存储用户首选项、应用程序设置等。</li></ul><p><strong>SessionStorage：</strong></p><ul><li><strong>持久性：</strong> SessionStorage是会话级别的，数据在浏览器会话结束后会被清除。</li><li><strong>存储容量：</strong> SessionStorage的存储容量通常与LocalStorage相似，也是5-10MB左右。</li><li><strong>访问：</strong> 可以通过JavaScript来访问和设置SessionStorage。</li><li><strong>安全性：</strong> SessionStorage的安全性较高，因为它不容易被客户端修改。</li><li><strong>用途：</strong> SessionStorage通常用于在会话期间临时存储数据，例如在不同页面之间共享数据。</li></ul><p><strong>各自的优缺点：</strong></p><ul><li><p><strong>Cookies：</strong></p><ul><li>优点：持久性、与服务器通信、广泛支持。</li><li>缺点：容量小、安全性差、会影响HTTP请求性能。</li></ul></li><li><p><strong>LocalStorage：</strong></p><ul><li>优点：持久性、较大的容量、安全性好。</li><li>缺点：仅在单个浏览器窗口&#x2F;标签页中可用。</li></ul></li><li><p><strong>SessionStorage：</strong></p><ul><li>优点：临时存储、较大的容量、安全性好。</li><li>缺点：仅在会话期间可用，关闭浏览器会话后数据丢失。</li></ul></li></ul><p><strong>在日常中的使用情况：</strong></p><p>在日常Web开发中，LocalStorage和SessionStorage通常更常见，因为它们提供了比Cookies更大的存储容量和更好的安全性，而且不会在每个HTTP请求中自动发送到服务器，从而减少了带宽开销。LocalStorage通常用于长期存储用户首选项、缓存应用程序数据等。SessionStorage则适用于在单个浏览器会话期间共享数据，例如在不同页面之间传递数据。</p><p>Cookies通常用于存储身份验证令牌、会话标识和跟踪用户行为等需要在客户端和服务器之间传递的信息，但由于安全性较差，所以不适合存储敏感信息。总的来说，选择哪种客户端存储方式取决于具体的需求和安全考虑。</p><h2 id="5、Cesium中如何处理建筑分层单体化"><a href="#5、Cesium中如何处理建筑分层单体化" class="headerlink" title="5、Cesium中如何处理建筑分层单体化"></a>5、Cesium中如何处理建筑分层单体化</h2><p>在Cesium中处理建筑分层单体化，即在一栋高层建筑中分割并展示不同楼层的内部结构，需要使用3D模型和一些技巧来实现。下面是一个简单的示例，演示如何处理建筑分层单体化。</p><p><strong>注意：</strong> 这是一个高级的Cesium应用场景，需要合适的3D建模和数据准备。以下示例仅用于演示概念，实际实现可能更复杂。</p><p><strong>1. 创建3D模型：</strong> 首先，你需要创建一个包含不同楼层内部结构的3D建模。这可以使用3D建模软件（例如Blender、SketchUp、3ds Max等）来完成。确保每个楼层都是独立的3D对象，并且模型中包含了每个楼层的几何形状和纹理。</p><p><strong>2. 导出3D模型：</strong> 将建模好的3D建筑导出为支持的3D文件格式，例如glTF或3D Tiles。</p><p><strong>3. 设置Cesium场景：</strong> 在Cesium中，你需要创建一个场景，并添加一个3D模型或tileset。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> viewer = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Viewer</span>(<span class="string">&#x27;cesiumContainer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> tileset = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">Cesium3DTileset</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;path/to/3dtileset&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">viewer.<span class="property">scene</span>.<span class="property">primitives</span>.<span class="title function_">add</span>(tileset);</span><br></pre></td></tr></table></figure><p><strong>4. 创建楼层选择器：</strong> 为了允许用户选择不同楼层，你可以创建一个楼层选择器界面，例如一个下拉菜单或按钮列表。</p><p><strong>5. 控制楼层可见性：</strong> 当用户选择不同楼层时，通过Cesium的API来控制不同楼层的可见性。这可以通过设置<code>show</code>属性来实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设楼层选择器是一个下拉菜单</span></span><br><span class="line"><span class="keyword">var</span> floorSelector = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;floorSelector&#x27;</span>);</span><br><span class="line"></span><br><span class="line">floorSelector.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> selectedFloor = floorSelector.<span class="property">value</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置不同楼层的可见性</span></span><br><span class="line">    tileset.<span class="property">root</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">child</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> floorNumber = child.<span class="property">content</span>.<span class="property">name</span>; <span class="comment">// 假设模型中包含楼层名称</span></span><br><span class="line">        <span class="keyword">if</span> (floorNumber === selectedFloor) &#123;</span><br><span class="line">            child.<span class="property">show</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            child.<span class="property">show</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码中，当用户选择不同的楼层时，通过遍历模型的子元素并根据用户选择设置不同楼层的可见性。</p><p>这是一个简化的示例，实际应用中可能需要更复杂的逻辑和用户界面来处理建筑的分层单体化。建筑分层单体化通常需要详细的3D建模、数据标注和前端开发工作，以确保用户能够方便地浏览建筑的不同楼层。 Cesium提供了强大的3D渲染和交互功能，可以用于实现这种类型的应用。</p><h2 id="6、openlayer与leaflet之间的区别，优势"><a href="#6、openlayer与leaflet之间的区别，优势" class="headerlink" title="6、openlayer与leaflet之间的区别，优势"></a>6、openlayer与leaflet之间的区别，优势</h2><p>OpenLayers和Leaflet都是流行的开源JavaScript库，用于创建互动性地图应用程序。它们都提供了强大的地图渲染和交互功能，但在某些方面有一些区别和优势。下面是一个超详细的介绍，比较了OpenLayers和Leaflet之间的区别和各自的优势：</p><p><strong>1. 历史和成熟度：</strong></p><ul><li><strong>OpenLayers：</strong> OpenLayers是一个相对较早的开源地图库，于2006年首次发布。它有着长期的发展历史和广泛的用户社区，已经经历了多个版本迭代。</li><li><strong>Leaflet：</strong> Leaflet相对较新，于2011年首次发布，但迅速获得了广泛的认可和用户社区支持。</li></ul><p><strong>2. 复杂性和学习曲线：</strong></p><ul><li><strong>OpenLayers：</strong> OpenLayers在某些方面更复杂，有更多的功能和配置选项，这也导致了较陡峭的学习曲线。它更适合需要高度自定义和复杂地图应用的开发者。</li><li><strong>Leaflet：</strong> Leaflet的设计更加简单和直观，具有较低的学习曲线，因此更适合初学者和快速开发。它的API设计注重易用性，但仍提供了强大的功能。</li></ul><p><strong>3. 社区和生态系统：</strong></p><ul><li><strong>OpenLayers：</strong> OpenLayers拥有庞大的社区和插件生态系统，使得可以找到各种扩展和插件来满足不同需求。它也有更多的第三方资源和教程。</li><li><strong>Leaflet：</strong> Leaflet虽然社区相对较小，但在可用插件和扩展方面也有不少选择。由于其简单性，一些开发者更喜欢自己编写自定义代码，而不是依赖于插件。</li></ul><p><strong>4. 性能和渲染：</strong></p><ul><li><strong>OpenLayers：</strong> OpenLayers在处理大规模数据集时通常表现得更出色，因为它支持WebGL渲染，可以加速地图渲染和交互。</li><li><strong>Leaflet：</strong> Leaflet的渲染性能也很好，但对于大规模数据集，可能会略逊于OpenLayers。但对于大多数应用程序而言，性能足够了。</li></ul><p><strong>5. 样式和外观：</strong></p><ul><li><strong>OpenLayers：</strong> OpenLayers提供了更多样式和外观的自定义选项，使开发者可以更精细地控制地图的外观。</li><li><strong>Leaflet：</strong> Leaflet也支持样式自定义，但通常要求更多的CSS技巧来实现复杂的外观。</li></ul><p><strong>6. 插件和扩展：</strong></p><ul><li><strong>OpenLayers：</strong> OpenLayers拥有丰富的插件和扩展，允许你轻松添加各种功能，如地理编码、地图编辑和复杂的地图分析。</li><li><strong>Leaflet：</strong> Leaflet也有一些插件，但数量和多样性相对较少。不过，你可以编写自定义代码来满足特定需求。</li></ul><p><strong>7. 项目目标：</strong></p><ul><li><strong>OpenLayers：</strong> OpenLayers的目标是提供一个强大的、可高度自定义的地图库，适用于复杂的地理信息系统（GIS）应用。</li><li><strong>Leaflet：</strong> Leaflet的目标是提供一个轻量级、易于使用的地图库，适用于快速开发交互性地图应用。</li></ul><p>总的来说，选择使用OpenLayers还是Leaflet取决于你的项目需求和你的开发经验。如果你需要处理大规模数据、复杂的地理信息系统或需要高度自定义的地图外观和行为，OpenLayers可能更适合。如果你是初学者、需要快速构建简单地图应用或希望简化开发流程，Leaflet可能更适合你。在某些情况下，你还可以考虑结合使用它们，以充分利用各自的优势。</p><h2 id="7、Threejs中如何做BIM分层分块展示"><a href="#7、Threejs中如何做BIM分层分块展示" class="headerlink" title="7、Threejs中如何做BIM分层分块展示"></a>7、Threejs中如何做BIM分层分块展示</h2><p>在Three.js中展示BIM（建筑信息模型）的分层分块，需要一些复杂的3D建模和渲染技巧。以下是一个一般性的步骤：</p><ol><li><p><strong>获取BIM数据：</strong> 首先，你需要获取BIM数据，通常以某种标准格式（如IFC）提供。你可以使用BIM软件（如Revit、AutoCAD）导出BIM模型为合适的格式，然后将数据导入到你的Three.js项目中。</p></li><li><p><strong>加载BIM数据：</strong> 使用Three.js加载BIM数据，通常需要解析BIM文件格式并将其转换为Three.js场景中的对象。你可能需要寻找适当的库或工具来帮助你解析和加载BIM数据。</p></li><li><p><strong>分层和分块：</strong> 一旦加载了BIM数据，你可以根据需要对模型进行分层和分块。这通常涉及到遍历BIM模型的数据结构，将不同的部分分组到不同的Three.js对象或组中。例如，你可以将每个楼层作为一个Three.js组，每个建筑元素（如墙、柱子、窗户等）作为另一个组。</p></li><li><p><strong>设置显示和隐藏：</strong> 为了实现分层分块的展示，你需要提供用户界面或交互方式，以允许用户选择要显示或隐藏的特定层或块。当用户进行选择时，你可以通过设置相关对象或组的可见性来实现显示或隐藏。</p></li></ol><p>以下是一个伪代码示例，演示如何在Three.js中实现基本的分层分块展示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载BIM数据并创建Three.js场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>();</span><br><span class="line"><span class="keyword">const</span> loader = <span class="keyword">new</span> <span class="title class_">BIMLoader</span>();</span><br><span class="line"><span class="keyword">const</span> bimModel = loader.<span class="title function_">loadBIMModel</span>(<span class="string">&#x27;path/to/bim-model.ifc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将BIM模型中的不同部分分组到不同的对象中</span></span><br><span class="line"><span class="keyword">const</span> floorsGroup = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>();</span><br><span class="line"><span class="keyword">const</span> wallsGroup = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>();</span><br><span class="line"><span class="comment">// ...其他分组</span></span><br><span class="line"></span><br><span class="line">bimModel.<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (element.<span class="property">type</span> === <span class="string">&#x27;floor&#x27;</span>) &#123;</span><br><span class="line">    floorsGroup.<span class="title function_">add</span>(element);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">type</span> === <span class="string">&#x27;wall&#x27;</span>) &#123;</span><br><span class="line">    wallsGroup.<span class="title function_">add</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...其他类型的分组</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">scene.<span class="title function_">add</span>(floorsGroup);</span><br><span class="line">scene.<span class="title function_">add</span>(wallsGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置交互方式，允许用户选择显示或隐藏不同的分组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toggleLayer</span>(<span class="params">layerGroup, visible</span>) &#123;</span><br><span class="line">  layerGroup.<span class="property">visible</span> = visible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：当用户点击“显示墙”按钮时，显示或隐藏墙壁分组</span></span><br><span class="line">showWallButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">toggleLayer</span>(wallsGroup, !wallsGroup.<span class="property">visible</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染Three.js场景</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>();</span><br><span class="line"><span class="comment">// ...设置渲染器和相机等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line">  renderer.<span class="title function_">render</span>(scene, camera);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">animate</span>();</span><br></pre></td></tr></table></figure><p>这只是一个基本示例，你需要根据你的BIM数据和项目需求进行定制。在实际项目中，你可能还需要考虑光照、相机控制、用户界面设计等方面的更多细节。为了更好地理解和实现BIM分层分块展示，你可能还需要深入研究BIM数据格式和Three.js的高级用法。</p><h2 id="此处只展示了部分面试题，剩余中海达面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及Cesium面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余中海达面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及Cesium面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余中海达面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及Cesium面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余中海达面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及Cesium面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/140ab620/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>11.性能优化</title>
      <link>https://jhcgnb.cn/posts/5a9e107b/</link>
      <guid>https://jhcgnb.cn/posts/5a9e107b/</guid>
      <pubDate>Wed, 18 Oct 2023 13:51:52 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;雅虎14条Web性能优化规则&quot;&gt;&lt;a href=&quot;#雅虎14条Web性能优化规则&quot; class=&quot;headerlink&quot; title=&quot;雅虎14条Web性能优化规则&quot;&gt;&lt;/a&gt;雅虎14条Web性能优化规则&lt;/h1&gt;&lt;h2 id=&quot;法则-1-减少-HTTP-请求次数</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="雅虎14条Web性能优化规则"><a href="#雅虎14条Web性能优化规则" class="headerlink" title="雅虎14条Web性能优化规则"></a>雅虎14条Web性能优化规则</h1><h2 id="法则-1-减少-HTTP-请求次数"><a href="#法则-1-减少-HTTP-请求次数" class="headerlink" title="法则 1. 减少 HTTP 请求次数"></a>法则 1. 减少 HTTP 请求次数</h2><p>80%的最终用户响应时间花在前端程序上，而其大部分时间则花在各种页面元素， 如图像、 样式表、 脚本和 Flash 等，的下载上。 减少页面元素将会减少 HTTP 请求 次数。这是快速显示页面的关键所在。 一种减少页面元素个数的方法是简化页面设计。 但是否存在其他方式，能做到既有丰富内容，又能获得快速响应时间呢？以下是这样一些技术：<br>Image maps 组合多个图片到一张图片中。总文件大小变化不大，但减少了 HTTP 请求次数从而加快了页面显示速度。该方式只适合图片连续的情况；同时坐标的定义是烦人又容易出错的工作。<br>CSS Sprites 是更好的方法。它可以组合页面中的图片到单个文件中，并使用 CSS 的 background-image 和 background-position 属性来实现所需的部分图片。 Inline images 使用 data: URL scheme 来在页面中内嵌图片。这将增大 HTML 文件的大小。组合 inline images 到你的（缓存）样式表是既能较少 HTTP 请求， 又能避免加大 HTML 文件大小的方法。<br>Combined files 通过组合多个脚本文件到单一文件来减少 HTTP 请求次数。样式 表也可采用类似方法处理。 这个方法虽然简单，但没有得到大规模的使用。  10大 美国网站每页平均有 7 个脚本文件和 2 个样式表。当页面之间脚本和样式表变化 很大时，该方式将遇到很大的挑战，但如果做到的话，将能加快响应时间。<br>小结：减少 HTTP 请求次数是性能优化的起点。这最提高首次访问的效率起到很重要的 作用。 Tenni Theurer 的文章 Browser Cache Usage – Exposed!描述，40-60% 据 的日常访问是首次访问，因此为首次访问者加快页面访问速度是用户体验的关 键。</p><h2 id="法则-2-使用-CDN-Content-Delivery-Network-内容分发网络"><a href="#法则-2-使用-CDN-Content-Delivery-Network-内容分发网络" class="headerlink" title="法则 2. 使用 CDN(Content Delivery Network, 内容分发网络 )"></a>法则 2. 使用 CDN(Content Delivery Network, 内容分发网络 )</h2><p>用户离 web server 的远近对响应时间也有很大影响。从用户角度看，把内容部 署到多个地理位置分散的服务器上将有效提高页面装载速度。 但是该从哪里开始 呢？<br>作为实现内容地理分布的第一步，不要试图重构 web 应用以适应分布架构。 改变 架构将导致多个周期性任务，如同步 session 状态，在多个 server 之间复制数 据库交易。 这样缩短用户与内容距离的尝试可能被应用架构改版所延迟，或阻止。 我们还记得 80-90%的最终用户响应时间花在下载页面中的各种元素上，如图像 文件、 样式表、 脚本和 Flash 等。 与其花在重构系统这个困难的任务上，还不如先 分布静态内容。 这不仅能大大减少响应时间，而且由于 CDN 的存在，分布静态内 容非常容易实现。 CDN 是地理上分布的 web server 的集合，用于更高效地发布内容。 通常基于网络 远近来选择给具体用户服务的 web server。 一些大型网站拥有自己的 CDN，但是使用如 Akamai Technologies, Mirror Image Internet, 或 Limelight Networks 等 CDN 服务提供商的服务将是划算的。 在 Yahoo!把静态内容分布到 CDN 减少了用户影响时间 20%或更多。切换到 CDN 的 代码修改工作是很容易的，但能达到提高网站的速度。</p><h2 id="法则-3-增加-Expires-Header"><a href="#法则-3-增加-Expires-Header" class="headerlink" title="法则 3. 增加 Expires Header"></a>法则 3. 增加 Expires Header</h2><p>网页内容正变得越来越丰富，这意味着更多的脚本文件、样式表、图像文件和 Flash。 首次访问者将不得不面临多次 HTTP 请求，但通过使用 Expires header， 您可以在客户端缓存这些元素。这在后续访问中避免了不必要的 HTTP 请求。 Expires header 最常用于图像文件，但是它也应该用于脚本文件、样式表和 Flash。 浏览器（和代理）使用缓存来减少 HTTP 请求的次数和大小，使得网页加速装载。 Web server 通过 Expires header 告诉客户端一个元素可以缓存的时间长度。 如果服务器是 Apache 的话，您可以使用 ExpiresDefault 基于当期日期来设置 过期日期，如： ExpiresDefault “access plus 10 years” 设置过期时间为从请求时间开始 计算的 10 年。 请记住，如果使用超长的过期时间，则当内容改变时，您必须修改文件名称。 在 Yahoo!我们经常把改名作为 release 的一个步骤：版本号内嵌在文件名中，如 yahoo_2.0.6.js。</p><h2 id="法则-4-压缩页面元素"><a href="#法则-4-压缩页面元素" class="headerlink" title="法则 4. 压缩页面元素"></a>法则 4. 压缩页面元素</h2><p>通过压缩 HTTP 响应内容可减少页面响应时间。从 HTTP&#x2F;1.1 开始，web 客户端在 HTTP 请求中通过 Accept-Encoding 头来表明支持的压缩类型，如：<br>Accept-Encoding: gzip, deflate. 如果 Web server 检查到 Accept-Encoding 头，它会使用客户端支持的方法来压 缩 HTTP 响应，会设置 Content-Encoding 头，如：Content-Encoding: gzip。 Gzip 是目前最流行及有效的压缩方法。 其他的方式如 deflate，但它效果较差， 也不够流行。通过 Gzip，内容一般可减少 70%。如果是 Apache，在 1.3 版本下需 使用 mod_gzip 模块，而在 2.x 版本下，则需使用 mod_deflate。 Web server 根据文件类型来决定是否压缩。 大部分网站对 HTML 文件进行压缩。 但 对脚本文件和样式表进行压缩也是值得的。实际上，对包括 XML 和 JSON 在内的 任务文本信息进行压缩都是值得的。 图像文件和 PDF 文件不应该被压缩，因为它 们本来就是压缩格式保存的。对它们进行压缩，不但浪费 CPU，而且还可能增加 文件的大小。 因此，对尽量多的文件类型进行压缩是一种减少页面大小和提高用户体验的简 便方法。</p><h2 id="法则-5-把样式表放在头上"><a href="#法则-5-把样式表放在头上" class="headerlink" title="法则 5. 把样式表放在头上"></a>法则 5. 把样式表放在头上</h2><p>我们发现把样式表移到 HEAD 部分可以提高界面加载速度，因此这使得页面元素 可以顺序显示。 在很多浏览器下，如 IE，把样式表放在 document 的底部的问题在于它禁止了网 页内容的顺序显示。 浏览器阻止显示以免重画页面元素，那用户只能看到空白页 了。Firefox 不会阻止显示，但这意味着当样式表下载后，有些页面元素可能需 要重画，这导致闪烁问题。 HTML 规范明确要求样式表被定义在 HEAD 中，因此，为避免空白屏幕或闪烁问题， 最好的办法是遵循 HTML 规范，把样式表放在 HEAD 中。</p><h2 id="法则-6-把脚本文件放在底部"><a href="#法则-6-把脚本文件放在底部" class="headerlink" title="法则 6. 把脚本文件放在底部"></a>法则 6. 把脚本文件放在底部</h2><p>与样式文件一样，我们需要注意脚本文件的位置。 我们需尽量把它们放在页面的 底部，这样一方面能顺序显示，另方面可达到最大的并行下载。 浏览器会阻塞显示直到样式表下载完毕，因此我们需要把样式表放在 HEAD 部分。 而对于脚本来说，脚本后面内容的顺序显示将被阻塞，因此把脚本尽量放在底 部意味着更多内容能被快速显示。 脚本引起的第二个问题是它阻塞并行下载数量。HTTP&#x2F;1.1 规范建议浏览器每个 主机的并行下载数不超过 2 个。 因此如果您把图像文件分布到多台机器的话，您可以达到超过 2 个的并行下载。 但是当脚本文件下载时，浏览器不会启动其他的 并行下载，甚至其他主机的下载也不启动。 在某些情况下，不是很容易就能把脚本移到底部的。如，脚本使用 document.write 方法来插入页面内容。 同时可能还存在域的问题。 不过在很多情 况下，还是有一些方法的。 一个备选方法是使用延迟脚本（deferred script）。DEFER 属性表明脚本未包 含 document.write，指示浏览器刻继续显示。不幸的是，Firefox 不支持 DEFER 属性。 IE 中，脚本可能被延迟执行，但不一定得到需要的长时间延迟。 在 不过从 另外角度来说，如果脚本能被延迟执行，那它就可以被放在底部了。</p><h2 id="法则-7-避免-CSS-表达式"><a href="#法则-7-避免-CSS-表达式" class="headerlink" title="法则 7. 避免 CSS 表达式"></a>法则 7. 避免 CSS 表达式</h2><p>CSS 表达式是功能强大的(同时也是危险的)用于动态设置 CSS 属性的方式。IE， 从版本 5 开始支持 CSS 表达式，如 backgourd-color: expression((new Date()).getHours()%2?”#B8D4FF”:”#F08A00”)，即背景色每个小时切换一 次。 CSS 表达式的问题是其执行次数超过大部分人的期望。 不仅页面显示和 resize 时 计算表达式，而且当页面滚屏，甚至当鼠标在页面上移动时都会重新计算表达 式。 一种减少 CSS 表达式执行次数的方法是一次性表达式，即当第一次执行时就以 明确的数值代替表达式。如果必须动态设置的话，可使用事件处理函数代替。如 果您必须使用 CSS 表达式的话，请记住它们可能被执行上千次，从而影响页面 性能。</p><h2 id="法则-8-把-JavaScript-和-CSS-放到外部文件中"><a href="#法则-8-把-JavaScript-和-CSS-放到外部文件中" class="headerlink" title="法则 8. 把 JavaScript 和 CSS 放到外部文件中"></a>法则 8. 把 JavaScript 和 CSS 放到外部文件中</h2><p>上述很多性能优化法则都基于外部文件进行优化。 现在，我们必须问一个问题： JavaScript 和 CSS 应该包括在外部文件，还是在页面文件中？ 在现实世界中，使用外部文件会加快页面显示速度，因为外部文件会被浏览器 缓存。如果内置 JavaScript 和 CSS 在页面中虽然会减少 HTTP 请求次数，但增大 了页面的大小。 另外一方面，使用外部文件，会被浏览器缓存，则页面大小会减 小，同时又不增加 HTTP 请求次数。 因此，一般来说，外部文件是更可行的方式。 唯一的例外是内嵌方式对主页更有 效，如 Yahoo!和 My Yahoo!都使用内嵌方式。一般来说，在一个 session 中，主 页访问此时较少，因此内嵌方式可以取得更快的用户响应时间。</p><h2 id="法则-9-减少-DNS-查询次数"><a href="#法则-9-减少-DNS-查询次数" class="headerlink" title="法则 9. 减少 DNS 查询次数"></a>法则 9. 减少 DNS 查询次数</h2><p>DNS 用于映射主机名和 IP 地址，一般一次解析需要 20～120 毫秒。 为达到更高的 性能，DNS 解析通常被多级别地缓存，如由 ISP 或局域网维护的 caching server，本地机器操作系统的缓存（如 windows 上的 DNS Client Service）， 浏览器。 的缺省 DNS 缓存时间为 30 分钟，Firefox 的缺省缓冲时间是 1 分钟。 IE 减少主机名可减少 DNS 查询的次数，但可能造成并行下载数的减少。避免 DNS 查 询可减少响应时间，而减少并行下载数可能增加响应时间。 一个可行的折中是把 内容分布到至少 2 个，最多 4 个不同的主机名上。</p><h2 id="法则-10-最小化-JavaScript代码"><a href="#法则-10-最小化-JavaScript代码" class="headerlink" title="法则 10. 最小化 JavaScript代码"></a>法则 10. 最小化 JavaScript代码</h2><p>最小化 JavaScript 代码指在 JS 代码中删除不必要的字符，从而降低下载时间。 两个流行的工具是 JSMin 和 YUI Compressor。 混淆是最小化于源码的备选方式。 象最小化一样，它通过删除注释和空格来减少 源码大小，同时它还可以对代码进行混淆处理。 作为混淆的一部分，函数名和变 量名被替换成短的字符串，这使得代码更紧凑，同时也更难读，使得难于被反 向工程。Dojo Compressor (ShrinkSafe)是最常见的混淆工具。 最小化是安全的、直白的过程，而混淆则更复杂，而且容易产生问题。从对美国 10 大网站的调查来看，通过最小化，文件可减少 21%，而混淆则可减少 25%。 除了最小化外部脚本文件外，内嵌的脚本代码也应该被最小化。 即使脚本根据法 则 4 被压缩后传输，最小化脚本刻减少文件大小 5%或更高。</p><h2 id="法则-11-避免重定向"><a href="#法则-11-避免重定向" class="headerlink" title="法则 11. 避免重定向"></a>法则 11. 避免重定向</h2><p>重定向功能是通过 301 和 302 这两个 HTTP 状态码完成的，如： HTTP&#x2F;1.1 301 Moved Permanently Location: <a href="http://example.com/newuri">http://example.com/newuri</a> Content-Type: text&#x2F;html 浏览器自动重定向请求到 Location 指定的 URL 上，重定向的主要问题是降低了 用户体验。 一种最耗费资源、经常发生而很容易被忽视的重定向是 URL 的最后缺少&#x2F;，如访 问 <a href="http://astrology.yahoo.com/astrology">http://astrology.yahoo.com/astrology</a> 将被重定向到 <a href="http://astrology.yahoo.com/astrology/%E3%80%82%E5%9C%A8">http://astrology.yahoo.com/astrology/。在</a> Apache 下，可以通过 Alias，mod_rewrite 或 DirectorySlash 等方式来解决该问题。</p><h2 id="法则-12-删除重复的脚本文件"><a href="#法则-12-删除重复的脚本文件" class="headerlink" title="法则 12. 删除重复的脚本文件"></a>法则 12. 删除重复的脚本文件</h2><p>在一个页面中包含重复的 JS 脚本文件会影响性能，即它会建立不必要的 HTTP 请求和额外的 JS 执行。 不必要的 HTTP 请求发生在 IE 下，而 Firefox 不会产生多余的 HTTP 请求。 额外的 JS 执行，不管在 IE 下，还是在 Firefox 下，都会发生。 一个避免重复的脚本文件的方式是使用模板系统来建立脚本管理模块。 除了防止 重复的脚本文件外，该模块还可以实现依赖性检查和增加版本号到脚本文件名 中，从而实现超长的过期时间。</p><h2 id="法则-13-配置-ETags"><a href="#法则-13-配置-ETags" class="headerlink" title="法则 13. 配置 ETags"></a>法则 13. 配置 ETags</h2><p>ETags 是用于确定浏览器缓存中元素是否与 Web server 中的元素相匹配的机制， 它是比 last-modified date 更灵活的元素验证机制。ETag 是用于唯一表示元素 版本的字符串，它需被包括在引号中。Web server 首先在 response 中指定 ETag： HTTP&#x2F;1.1 200 OK &lt; 03:03:59 2006 Dec 12&gt; 10c24bc-4ab-457e1c1f” Content-Length: 12195 后来，如果浏览器需要验证某元素，它使用 If-None-Match 头回传 ETag 给 Web server，如果 ETag 匹配，则服务器返回 304 代码，从而节省了下载时间</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/5a9e107b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JS面试题</title>
      <link>https://jhcgnb.cn/posts/b94f3717/</link>
      <guid>https://jhcgnb.cn/posts/b94f3717/</guid>
      <pubDate>Fri, 11 Aug 2023 09:15:55 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;在 Vue 3 中，&lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-show&lt;/code&gt; 都是用于控制元素显示和隐藏的指令，但它们之间有一些重要的区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;编译时条件：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;c</description>
        
      
      
      
      <content:encoded><![CDATA[<p>在 Vue 3 中，<code>v-if</code> 和 <code>v-show</code> 都是用于控制元素显示和隐藏的指令，但它们之间有一些重要的区别。</p><ol><li><p><strong>编译时条件：</strong></p><ul><li><code>v-if</code>：当条件为 <code>false</code> 时，元素及其内容不会被渲染到DOM中。只有在条件为 <code>true</code> 时，元素才会被编译并添加到DOM。</li><li><code>v-show</code>：无论条件是 <code>true</code> 还是 <code>false</code>，元素都会被编译到DOM中，但是在条件为 <code>false</code> 时，元素会被设置为 <code>display: none</code>，从而隐藏它。</li></ul></li><li><p><strong>性能：</strong></p><ul><li><code>v-if</code>：当条件频繁切换时，会有一定的性能开销，因为每次切换条件时都会重新创建和销毁元素及其组件。</li><li><code>v-show</code>：适用于频繁切换的情况，因为元素一直在DOM中，只是样式属性变化，没有重新创建和销毁的开销。</li></ul></li><li><p><strong>初始化渲染时间：</strong></p><ul><li><code>v-if</code>：如果初始条件为 <code>false</code>，则在初始渲染时不会渲染元素。</li><li><code>v-show</code>：无论初始条件是 <code>true</code> 还是 <code>false</code>，元素都会被渲染，只是在 <code>false</code> 时不会显示。</li></ul></li><li><p><strong>DOM 结构：</strong></p><ul><li><code>v-if</code>：条件为 <code>false</code> 时，元素及其内容不会在DOM中存在，DOM结构会根据条件的变化而改变。</li><li><code>v-show</code>：无论条件如何，元素始终存在于DOM中，只是样式属性变化。</li></ul></li><li><p><strong>适用场景：</strong></p><ul><li><code>v-if</code>：适用于条件很少改变的情况，或者在初始渲染时元素可能是隐藏的情况。</li><li><code>v-show</code>：适用于需要频繁切换显示和隐藏状态的情况，例如制作可展开折叠的内容块。</li></ul></li></ol><p>综上所述，选择 <code>v-if</code> 还是 <code>v-show</code> 取决于您的具体需求和项目的性能要求。如果条件很少改变，或者初始渲染时元素可能是隐藏的，可以考虑使用 <code>v-if</code>。如果需要频繁切换显示和隐藏状态，并且性能开销比较重要，可以考虑使用 <code>v-show</code>。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/b94f3717/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>流形与非流行</title>
      <link>https://jhcgnb.cn/posts/467cee4/</link>
      <guid>https://jhcgnb.cn/posts/467cee4/</guid>
      <pubDate>Sat, 08 Jul 2023 13:45:31 GMT</pubDate>
      
        
        
      <description>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;流形三角形网格（Manifold-Triangle-Mesh）和非流形网格（Non-Manifold-Mesh）&quot;&gt;&lt;a href=&quot;#流形三角形网格（Manifold-</description>
        
      
      
      
      <content:encoded><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="流形三角形网格（Manifold-Triangle-Mesh）和非流形网格（Non-Manifold-Mesh）"><a href="#流形三角形网格（Manifold-Triangle-Mesh）和非流形网格（Non-Manifold-Mesh）" class="headerlink" title="流形三角形网格（Manifold Triangle Mesh）和非流形网格（Non-Manifold Mesh）"></a>流形三角形网格（Manifold Triangle Mesh）和非流形网格（Non-Manifold Mesh）</h3><p>流形三角形网格（Manifold Triangle Mesh）和非流形网格（Non-Manifold Mesh）是在计算机图形学和几何处理中常见的两种网格类型。它们具有不同的特征和限制，对于不同的应用领域和算法，选择合适的网格类型是非常重要的。</p><ol><li><p>流形三角形网格：<br>流形三角形网格是一种拓扑上具有连续性和封闭性的网格。它的特征包括：</p><ul><li>每个顶点最多与两个边和两个面相连。</li><li>每个边最多与两个面相连。</li><li>每个面最多与三条边和三个顶点相连。</li><li>网格中不存在孤立的顶点、边或面。</li></ul><p>流形三角形网格常用于表示光滑曲面和可变形物体，它具有良好的几何性质和拓扑特征，适用于各种几何处理算法，如渲染、形状分析和物理模拟等。</p></li><li><p>非流形网格：<br>非流形网格是一种拓扑上不具备连续性和封闭性的网格。它的特征包括：</p><ul><li>顶点、边或面可以具有任意数量的相邻元素。</li><li>存在孤立的顶点、边或面。</li><li>边和面之间的连接关系可以是多对多的。</li></ul><p>非流形网格常用于表示复杂的几何结构，如曲面上的孔洞、尖锐的边缘或非连续的形状。然而，由于其拓扑特性的复杂性，非流形网格在某些算法和应用中可能会导致问题，例如光滑、纹理映射和体积建模等。</p></li></ol><p>对于流形三角形网格和非流形网格，需要根据具体的应用场景和算法需求选择合适的网格类型。流形三角形网格适用于大多数常规几何处理任务，而非流形网格则更适用于具有复杂拓扑结构的特殊情况。在处理非流形网格时，需要特别注意处理拓扑上的不连续性和边界条件。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E5%AD%A6%E6%9C%AF/">学术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <comments>https://jhcgnb.cn/posts/467cee4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>详解@RequestParam</title>
      <link>https://jhcgnb.cn/posts/f43726f7/</link>
      <guid>https://jhcgnb.cn/posts/f43726f7/</guid>
      <pubDate>Tue, 04 Jul 2023 02:07:55 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;RequestParam&quot;&gt;&lt;a href=&quot;#RequestParam&quot; class=&quot;headerlink&quot; title=&quot;@RequestParam&quot;&gt;&lt;/a&gt;@RequestParam&lt;/h3&gt;&lt;p&gt;在Java中，&lt;code&gt;@RequestParam&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>在Java中，<code>@RequestParam</code> 是一个注解，用于从HTTP请求中获取参数值。它通常用于Spring MVC框架中的控制器方法中，以指定方法参数应该绑定到HTTP请求中的特定参数。</p><p><code>@RequestParam</code> 可以用于处理HTTP请求的查询参数、表单参数或路径参数。它可以应用于方法的参数或方法的参数上的注解。</p><p>下面是一些示例：</p><ol><li>使用默认参数名称：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将尝试从HTTP请求中获取名为 “param” 的查询参数，并将其绑定到方法参数 <code>param</code>。</p><ol start="2"><li>使用自定义参数名称：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam(&quot;customParam&quot;)</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，<code>@RequestParam</code> 注解指定了参数的自定义名称 “customParam”，它将从HTTP请求中获取该参数，并将其绑定到方法参数 <code>param</code>。</p><ol start="3"><li>设置默认值：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam(value = &quot;param&quot;, defaultValue = &quot;default&quot;)</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，如果请求中没有名为 “param” 的参数，或者参数的值为空，那么方法参数 <code>param</code> 将被设置为默认值 “default”。</p><ol start="4"><li>必需的参数：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam(required = true)</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>@RequestParam</code> 注解的 <code>required</code> 属性被设置为 <code>true</code>，表示参数是必需的。如果请求中没有提供该参数，将会返回错误。</p><p>总结一下，<code>@RequestParam</code> 注解用于从HTTP请求中获取参数值，并将其绑定到Java方法的参数。它提供了许多选项，可以根据需要配置参数的名称、默认值和是否必需。这样，开发者可以方便地处理HTTP请求中的参数。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/Java/">Java</category>
      
      
      <comments>https://jhcgnb.cn/posts/f43726f7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Cesium面试题</title>
      <link>https://jhcgnb.cn/posts/a98e3ede/</link>
      <guid>https://jhcgnb.cn/posts/a98e3ede/</guid>
      <pubDate>Mon, 03 Jul 2023 06:07:01 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e0239a75f96830e577eef736ebcad965.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;heade</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/e0239a75f96830e577eef736ebcad965.png" alt="img"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="Cesium开发面试题"><a href="#Cesium开发面试题" class="headerlink" title="Cesium开发面试题"></a>Cesium开发面试题</h1><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="1、请简要介绍一下Cesium的基本功能。"><a href="#1、请简要介绍一下Cesium的基本功能。" class="headerlink" title="1、请简要介绍一下Cesium的基本功能。"></a>1、请简要介绍一下Cesium的基本功能。</h2><p>答：Cesium是一款3D地球可视化引擎，可以在Web浏览器中显示高度真实感的3D地球场景，包括地形、地表纹理、3D建筑、水域等。它提供多种漫游和导航方式，支持多种地形和影像数据格式，以及3D Tiles、CZML等技术，可以用于实时位置追踪、天文数据显示、地下和空中场景等应用场景。</p><h2 id="2、请解释一下Cesium中的3D-Tiles技术是什么，以及它的作用是什么。"><a href="#2、请解释一下Cesium中的3D-Tiles技术是什么，以及它的作用是什么。" class="headerlink" title="2、请解释一下Cesium中的3D Tiles技术是什么，以及它的作用是什么。"></a>2、请解释一下Cesium中的3D Tiles技术是什么，以及它的作用是什么。</h2><p>  答：3D Tiles是一种用于高效地加载和显示大规模的3D地球数据的技术，可以将复杂的3D数据分层并进行高度优化。Cesium中的3D Tiles技术可以支持大规模的3D地球数据，包括城市、建筑、地形等，提高了数据的加载速度和显示效率。</p><h2 id="3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？"><a href="#3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？" class="headerlink" title="3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？"></a>3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？</h2><p>  答：CZML（Cesium Language）是一种描述和显示动态的地球场景的数据格式，它可以用于描述航班轨迹、气象数据、卫星运行轨迹等。CZML中可以包含实体的位置、速度、方向等信息，以及可视化效果的设置。</p><h2 id="4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。"><a href="#4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。" class="headerlink" title="4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。"></a>4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。</h2><p>  答：ImageryProvider是Cesium中的一个数据提供器，用于提供地图和影像数据。它可以从多种来源获取数据，比如Web Map Service（WMS）、Web Map Tile Service（WMTS）等，并在地球表面上显示出来。通过使用ImageryProvider，开发者可以轻松地获取并显示各种地图和影像数据。</p><h2 id="5、如何加载飞线"><a href="#5、如何加载飞线" class="headerlink" title="5、如何加载飞线"></a>5、如何加载飞线</h2><p>  答：1、创建polyLine实体</p><p>   2、计算带有弧度效果的点集数组作为polyline的positions属性参数</p><h2 id="6、如何设置飞线动效材质"><a href="#6、如何设置飞线动效材质" class="headerlink" title="6、如何设置飞线动效材质"></a>6、如何设置飞线动效材质</h2><p>答：1、创建cesium自定义材质类</p><p>2、创建shader，原理是通过贴图UV移动来实现流光效果</p><h2 id="7、如何在cesium地球上添加柱状图"><a href="#7、如何在cesium地球上添加柱状图" class="headerlink" title="7、如何在cesium地球上添加柱状图"></a>7、如何在cesium地球上添加柱状图</h2><p>答：1、创建entity实体，使用box属性；</p><p>2、dimensions设置长宽；</p><p>3、position设置中心点位置；</p><p>4、heightReference属性设置贴地属性；</p><h2 id="8、如何让柱状图跟随数据变化"><a href="#8、如何让柱状图跟随数据变化" class="headerlink" title="8、如何让柱状图跟随数据变化"></a>8、如何让柱状图跟随数据变化</h2><p>答：1、创建SampledPositionProperty对象</p><p>2、在不同的时间点绑定对应的值</p><p>  将填充好的SampledPositionProperty赋值给dimensions，实现位置随时间的偏移</p><h2 id="9、如何加载天气图的效果"><a href="#9、如何加载天气图的效果" class="headerlink" title="9、如何加载天气图的效果"></a>9、如何加载天气图的效果</h2><p>答：1、使用Wind3D类实现</p><p>实现原理是将nc格式的数据解析之后运用primitive绘制</p><p>​    2、Cesium官网有github的分享案例，需要修改鼠标事件影响该类绘制时的显示隐藏</p><h2 id="10、如何给cesium地球替换表面图层"><a href="#10、如何给cesium地球替换表面图层" class="headerlink" title="10、如何给cesium地球替换表面图层"></a>10、如何给cesium地球替换表面图层</h2><p>答：1、主要是在viewer的imageryLayers地图层级内对单独的layer图层的显示隐藏或者添加与移除，imageryLayers有add与remove方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、viewer.imageryLayers.addImageryProvider(layer, num);</span><br><span class="line">viewer.imageryLayers.remove(viewer.imageryLayers.get(num), true);</span><br></pre></td></tr></table></figure><p>主要是这两个API<br>    3、注意不同的地图图层加载会有对应的投影方式，比如web墨卡托投影和wgs84</p><h2 id="11、cesium如何进行坐标转换"><a href="#11、cesium如何进行坐标转换" class="headerlink" title="11、cesium如何进行坐标转换"></a>11、cesium如何进行坐标转换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">答：1、//经纬度转屏幕坐标</span><br><span class="line"></span><br><span class="line">LngLatToSceenCoordinates(lng, lat) &#123;</span><br><span class="line"></span><br><span class="line">let cartesian3 = Cesium.Cartesian3.fromDegrees(lng, lat);</span><br><span class="line"></span><br><span class="line">let cartesian2 = Cesium.SceneTransforms.wgs84ToWindowCoordinates(</span><br><span class="line"></span><br><span class="line">viewer.scene,</span><br><span class="line"></span><br><span class="line">cartesian3</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">return cartesian2;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">2、 //笛卡尔坐标转经纬度坐标</span><br><span class="line"></span><br><span class="line">Cartesian3ToLngLat(cartesian) &#123;</span><br><span class="line"></span><br><span class="line">let cartographic =</span><br><span class="line"></span><br><span class="line">viewer.scene.globe.ellipsoid.cartesianToCartographic(cartesian);</span><br><span class="line"></span><br><span class="line">let c_height = viewer.camera.positionCartographic.height;</span><br><span class="line"></span><br><span class="line">//将地图坐标（弧度）转为十进制的度数</span><br><span class="line"></span><br><span class="line">let lat_String = Cesium.Math.toDegrees(cartographic.latitude).toFixed(6);</span><br><span class="line"></span><br><span class="line">let log_String = Cesium.Math.toDegrees(cartographic.longitude).toFixed(6);</span><br><span class="line"></span><br><span class="line">return [</span><br><span class="line"></span><br><span class="line">parseFloat(log_String),</span><br><span class="line"></span><br><span class="line">parseFloat(lat_String),</span><br><span class="line"></span><br><span class="line">parseFloat(c_height),</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="12、cesium如何实现标记的添加"><a href="#12、cesium如何实现标记的添加" class="headerlink" title="12、cesium如何实现标记的添加"></a>12、cesium如何实现标记的添加</h2><p>  答：1、创建entity实体对象使用billboard对象场景图标挥着使用billboard collection使用primitive创建</p><h2 id="13、cesium如何实现鼠标拾取弹窗功能"><a href="#13、cesium如何实现鼠标拾取弹窗功能" class="headerlink" title="13、cesium如何实现鼠标拾取弹窗功能"></a>13、cesium如何实现鼠标拾取弹窗功能</h2><p>   答：1、创建new Cesium.ScreenSpaceEventHandler(canvas)对象</p><p> 2、注册鼠标点击事件<br>   3、使用let pick &#x3D; viewer.scene.pick(movement.position); 选取当前的entity</p><h2 id="14、如何设置cesium中的抗锯齿方法"><a href="#14、如何设置cesium中的抗锯齿方法" class="headerlink" title="14、如何设置cesium中的抗锯齿方法"></a>14、如何设置cesium中的抗锯齿方法</h2><p>  答：1、使用fxaa方法，效果较差</p><p>  2、使用msaa方法，但需要浏览器支持webGL2的api方法</p><p><img src="https://bcn.135editor.com/files/images/editor_styles/2b4dad3b5ce0324eb63cde4380e4cdfb.gif" alt="img"></p><p><img src="https://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9wbmcvdm5UNGhiYUxvWDZIWkQxZXFvRmljVXdwR3RPSklNamNzaWNNVVVZWDRvNHNNMGhQQ2RQRUtTV0pIYkdQb2MyVWJQaWNGVlNTM2ljU3hZRDdoOTdNUHYwSW9BLzA/d3hfZm10PXBuZw==" alt="img"></p><p><img src="https://bcn.135editor.com/files/images/editor_styles/8a370d08cb8dee16148088fd86f39e16.png" alt="img"></p><p><img src="https://bexp.135editor.com/files/users/498/4980660/202302/k5PHuh8T_I5qb.jpg?auth_key=1677427199-0-0-d90c72020ea7995dbf533d91bb976f8c" alt="qrcode_for_gh_e879ec750214_258.jpg"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/Cesium/">Cesium</category>
      
      
      <comments>https://jhcgnb.cn/posts/a98e3ede/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JS是如何实现继承的</title>
      <link>https://jhcgnb.cn/posts/undefined/</link>
      <guid>https://jhcgnb.cn/posts/undefined/</guid>
      <pubDate>Wed, 14 Jun 2023 12:37:56 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;JS是如何实现继承的&quot;&gt;&lt;a href=&quot;#JS是如何实现继承的&quot; class=&quot;headerlink&quot; title=&quot;JS是如何实现继承的&quot;&gt;&lt;/a&gt;JS是如何实现继承的&lt;/h3&gt;&lt;p&gt;在 JavaScript 中，继承是通过原型链来实现的。每个对象都有一个原型</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="JS是如何实现继承的"><a href="#JS是如何实现继承的" class="headerlink" title="JS是如何实现继承的"></a>JS是如何实现继承的</h3><p>在 JavaScript 中，继承是通过原型链来实现的。每个对象都有一个原型（prototype）属性，它指向另一个对象，这个对象即作为当前对象的原型。继承就是通过让一个对象继承另一个对象的属性和方法，使得子对象可以共享父对象的功能。</p><p>下面介绍几种常见的继承方式：</p><ol><li><strong>原型链继承</strong>：</li></ol><p>原型链继承是最基本的继承方式，它利用原型链将父对象的属性和方法传递给子对象。子对象的原型链上依次连接着父对象的原型，从而实现继承。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello from <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: &quot;Hello from Child&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>构造函数继承</strong>：</li></ol><p>构造函数继承通过在子对象的构造函数中调用父对象的构造函数来实现继承。这样可以实现父对象属性的继承，但无法继承父对象原型上的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>); <span class="comment">// 输出: &quot;Child&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>组合继承</strong>：</li></ol><p>组合继承是将原型链继承和构造函数继承结合起来的一种方式，它既继承了父对象的属性和方法，又通过调用父对象的构造函数来实现属性的初始化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello from <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 构造函数继承</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 原型链继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: &quot;Hello from Child&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>ES6 Class 继承</strong>：</li></ol><p>ES6 引入了类（class）的概念，使得继承更加清晰和语法更加友好。通过 <code>extends</code> 关键字，可以轻松地实现一个类继承另一个类的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello from <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: &quot;Hello from Child&quot;</span></span><br></pre></td></tr></table></figure><p>无论使用哪种继承方式，都应该注意可能存在的问题，例如原型链继承可能导致属性共享问题，构造函数继承可能无法继承原型上的方法等。选择合适的继承方式要根据具体的需求来决定。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/undefined/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux项目部署详细步骤</title>
      <link>https://jhcgnb.cn/posts/d594835b/</link>
      <guid>https://jhcgnb.cn/posts/d594835b/</guid>
      <pubDate>Tue, 09 May 2023 11:08:33 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;安装部署&quot;&gt;&lt;a href=&quot;#安装部署&quot; class=&quot;headerlink&quot; title=&quot;安装部署&quot;&gt;&lt;/a&gt;安装部署&lt;/h1&gt;&lt;h2 id=&quot;一、环境准备&quot;&gt;&lt;a href=&quot;#一、环境准备&quot; class=&quot;headerlink&quot; title=&quot;一、环境准</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><p>说明：如果已经安装过相关工具就忽略</p><h3 id="1安装JAVA-运行环境"><a href="#1安装JAVA-运行环境" class="headerlink" title="1安装JAVA 运行环境"></a>1安装JAVA 运行环境</h3><p>第一步：上传或下载安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /usr/local</span><br></pre></td></tr></table></figure><p>jdk-8u152-linux-x64.tar.gz</p><p>第二步：解压安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u152-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>第三步：建立软连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/jdk1.8.0_152/  /usr/local/jdk </span><br></pre></td></tr></table></figure><p>第四步：修改环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/jdk</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过命令source /etc/profile让profile文件立即生效</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>第五步、测试是否安装成功</p><p>使用java -version，出现版本为java version “1.8.0_152”</p><h3 id="2安装maven"><a href="#2安装maven" class="headerlink" title="2安装maven"></a>2安装maven</h3><p>第一步：上传或下载安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /usr/local</span><br></pre></td></tr></table></figure><p>apache-maven-3.6.1-bin.tar.gz</p><p>第二步：解压安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar  -zxvf  apache-maven-3.6.1-bin.tar.gz</span><br></pre></td></tr></table></figure><p>第三步：建立软连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln  -s  /usr/local/apache-maven-3.6.1/  /usr/local/maven</span><br></pre></td></tr></table></figure><p>第四步：修改环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export MAVEN_HOME=/usr/local/maven</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过命令source /etc/profile让profile文件立即生效</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>第五步、测试是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn –v</span><br></pre></td></tr></table></figure><h3 id="3安装docker"><a href="#3安装docker" class="headerlink" title="3安装docker"></a>3安装docker</h3><p>环境安装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p>第一步：安装必要的一些系统工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2 </span><br></pre></td></tr></table></figure><p>第二步：添加软件源信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>第三步：更新并安装Docker-CE</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><p>第四步：开启Docker服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>第五步：测试是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -v </span><br></pre></td></tr></table></figure><p>第六步：配置镜像加速器</p><p>您可以通过修改daemon配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json来使用加速器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> &quot;registry-mirrors&quot;: [&quot;https://ldu6wrsf.mirror.aliyuncs.com&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="4安装mysql"><a href="#4安装mysql" class="headerlink" title="4安装mysql"></a>4安装mysql</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name mysql --restart=always -v /home/ljaer/mysql:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 </span><br></pre></td></tr></table></figure><p>第三步：测试mysql</p><p>进入容器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p>登录mysql：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>如果顺利进入，安装成功</p><h3 id="5安装rabbitmq"><a href="#5安装rabbitmq" class="headerlink" title="5安装rabbitmq"></a>5安装rabbitmq</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5672:5672 -p 15672:15672 --restart=always --name rabbitmq rabbitmq:management</span><br></pre></td></tr></table></figure><p>第三步：安装延迟队列插件</p><ol><li><p>首先下载rabbitmq_delayed_message_exchange-3.9.0.ez文件上传到RabbitMQ所在服务器，下载地址：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p></li><li><p>切换到插件所在目录，执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp rabbitmq_delayed_message_exchange-3.9.0.ez rabbitmq:/plugins </span><br></pre></td></tr></table></figure><p>命令，将刚插件拷贝到容器内plugins目录下</p></li><li><p>执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it rabbitmq /bin/bash </span><br></pre></td></tr></table></figure><p>命令进入到容器内部，并 cd plugins 进入plugins目录</p></li><li><p>执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l|grep delay</span><br></pre></td></tr></table></figure><p>  命令查看插件是否copy成功</p></li><li><p>在容器内plugins目录下，执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>  命令启用插件</p></li><li><p>exit命令退出RabbitMQ容器内部，然后执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart rabbitmq </span><br></pre></td></tr></table></figure><p>命令重启RabbitMQ容器</p></li></ol><h3 id="6安装redis"><a href="#6安装redis" class="headerlink" title="6安装redis"></a>6安装redis</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379  --restart=always redis:latest redis-server</span><br></pre></td></tr></table></figure><h3 id="7安装nacos"><a href="#7安装nacos" class="headerlink" title="7安装nacos"></a>7安装nacos</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nacos/nacos-server:1.4.1</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --env MODE=standalone --name nacos --restart=always -d -p 8848:8848 -e JVM_XMS=512m -e JVM_XMX=512m nacos/nacos-server:1.4.1</span><br></pre></td></tr></table></figure><h3 id="8安装sentinel"><a href="#8安装sentinel" class="headerlink" title="8安装sentinel"></a>8安装sentinel</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull bladex/sentinel-dashboard</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name sentinel-dashboard --restart=always -p 8858:8858 -d bladex/sentinel-dashboard:latest  </span><br></pre></td></tr></table></figure><h3 id="9安装elasticsearch"><a href="#9安装elasticsearch" class="headerlink" title="9安装elasticsearch"></a>9安装elasticsearch</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:7.8.0</span><br></pre></td></tr></table></figure><p>第二步：启动</p><p>需要建立：两个文件夹</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /mydata/elasticsearch/plugins</span><br><span class="line"></span><br><span class="line">mkdir -p /mydata/elasticsearch/data</span><br></pre></td></tr></table></figure><p>授予权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /mydata/elasticsearch/data</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 --name elasticsearch --restart=always \-e &quot;discovery.type=single-node&quot; \-e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; \-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \-d elasticsearch:7.8.0</span><br></pre></td></tr></table></figure><p>第三步：安装中文分词器</p><ol><li><p>下载elasticsearch-analysis-ik-7.8.0.zip</p></li><li><p>上传解压：unzip elasticsearch-analysis-ik-7.8.0.zip -d ik-analyzer</p></li><li><p>上传到es容器：docker cp .&#x2F;ik-analyzer a24eb9941759:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</p></li><li><p>重启es：docker restart a24eb9941759</p></li></ol><p>a24eb9941759：表示容器ID 运行时，需要改成自己的容器ID</p><h3 id="10-安装kibana"><a href="#10-安装kibana" class="headerlink" title="10 安装kibana"></a>10 安装kibana</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull kibana:7.8.0</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name kibana --restart=always -e ELASTICSEARCH_URL=http://192.168.112.165:9200 -p 5601:5601 -d kibana:7.8.0</span><br></pre></td></tr></table></figure><p>进入容器修改：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 1e12f8dd3efd /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd config</span><br><span class="line"></span><br><span class="line">vi kibana.yml</span><br><span class="line"></span><br><span class="line">elasticsearch.hosts: [ &quot;http://192.168.200.129:9200&quot; ]</span><br><span class="line"></span><br><span class="line">docker restart 1dc0f78d78ad 重启kibana ！</span><br></pre></td></tr></table></figure><p>测试：安装分词词库是否可以使用！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /.kibana/_analyze</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> &quot;text&quot;: &quot;我是中国人&quot;,</span><br><span class="line"></span><br><span class="line"> &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11安装zipkin"><a href="#11安装zipkin" class="headerlink" title="11安装zipkin"></a>11安装zipkin</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull openzipkin/zipkin</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name zipkin --restart=always -d -p 9411:9411 openzipkin/zipkin </span><br></pre></td></tr></table></figure><h3 id="12安装minio"><a href="#12安装minio" class="headerlink" title="12安装minio"></a>12安装minio</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run \ -p 9000:9000 \ -p 9001:9001 \ --name minio \ -d --restart=always \ -e &quot;MINIO_ROOT_USER=admin&quot; \ -e &quot;MINIO_ROOT_PASSWORD=admin123456&quot; \ -v /home/data:/data \ -v /home/config:/root/.minio \ minio/minio server /data --console-address &quot;:9001&quot;</span><br></pre></td></tr></table></figure><p>浏览器访问：<a href="http://ip:9000/minio/login%EF%BC%8C">http://IP:9000/minio/login，</a></p><h3 id="13-安装logstash"><a href="#13-安装logstash" class="headerlink" title="13 安装logstash"></a>13 安装logstash</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull logstash:7.8.0</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name logstash -p 5044:5044 --restart=always --link elasticsearch:es -v /mydata/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf -d logstash:7.8.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--net root_default \</span><br></pre></td></tr></table></figure><table><thead><tr><th># 需要提前在linux服务器上环境 &#x2F;mydata&#x2F;logstash&#x2F;logstash.conflogstash.confinput { tcp {mode &#x3D;&gt; “server”host &#x3D;&gt; “0.0.0.0”port &#x3D;&gt; 5044codec &#x3D;&gt; json_lines }}filter{ }output { elasticsearch {hosts &#x3D;&gt; “192.168.112.165:9200”index &#x3D;&gt; “gmall-%{+YYYY.MM.dd}” }}</th></tr></thead><tbody><tr><td></td></tr></tbody></table><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>停止所有的容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有的容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>#删除所有的镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p>问题：</p><p>Docker容器做端口映射报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint lamp3 (46b7917c940f7358948e55ec2df69a4dec2c6c7071b002bd374e8dbf0d40022c): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 86 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name.</span><br></pre></td></tr></table></figure><p>解决方法</p><p>docker服务启动时定义的自定义链DOCKER被清除</p><p>重启即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/Java/">Java</category>
      
      
      <comments>https://jhcgnb.cn/posts/d594835b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>多边形</title>
      <link>https://jhcgnb.cn/posts/undefined/</link>
      <guid>https://jhcgnb.cn/posts/undefined/</guid>
      <pubDate>Mon, 08 May 2023 13:28:12 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Voronoi-多边形&quot;&gt;&lt;a href=&quot;#Voronoi-多边形&quot; class=&quot;headerlink&quot; title=&quot;Voronoi 多边形&quot;&gt;&lt;/a&gt;Voronoi 多边形&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://rx6zk4j2b.hn-bkt.</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Voronoi-多边形"><a href="#Voronoi-多边形" class="headerlink" title="Voronoi 多边形"></a>Voronoi 多边形</h3><p><img src="http://rx6zk4j2b.hn-bkt.clouddn.com/blogs/image-20230708212920053.png" alt="image-20230708212920053"></p><p>Voronoi 多边形，也称为 Voronoi 图或 Voronoi 分割，是一种空间分析和几何计算方法，用于将平面或空间划分为不同区域，每个区域都与给定一组点最近邻。这些区域被称为 Voronoi 多边形或 Voronoi 区域，每个多边形由与其对应的点作为最近邻点。</p><p>Voronoi 多边形的生成过程基于以下原则：给定一组点，每个点的 Voronoi 区域包含所有离该点最近的点，并且这些点之间的边界形成多边形。Voronoi 多边形的边界由平分相邻点之间的直线或曲线段组成，这些直线或曲线段是两个点之间的等距离线，也称为 Voronoi 边。因此，Voronoi 多边形的边界是相邻点之间的中垂线。</p><p>Voronoi 多边形在各种领域中有广泛应用，包括计算机图形学、计算机视觉、地理信息系统（GIS）、模式识别等。以下是一些应用 Voronoi 多边形的示例：</p><ol><li><p>空间分析：Voronoi 多边形可用于将地理空间划分为不同的区域，每个区域都由最近邻点决定。这在地理学、城市规划和环境分析中具有重要作用，可以用于确定服务设施的服务范围、确定地理区域的边界等。</p></li><li><p>面积计算：通过计算 Voronoi 多边形的面积，可以了解每个点的影响范围或区域的大小。这在生态学、资源管理和人口统计学中很有用。</p></li><li><p>最近邻搜索：Voronoi 多边形可用于确定给定点的最近邻点。这在图像处理、模式识别和计算机视觉中经常使用，例如图像中的特征匹配、对象识别等。</p></li><li><p>网格生成：Voronoi 多边形可以用作生成网格的方法之一。通过将点集表示为 Voronoi 图，可以生成规则且适应性良好的网格，这在数值计算和有限元分析中很有用。</p></li></ol><p>总之，Voronoi 多边形是一种强大的几何计算工具，可用于空间分析、最近邻搜索、面积计算和网格生成等应用领域。它提供了一种有效的方法来划分空间并了解点之间的关系，为许多问题的解决提供了有力支持。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E5%AD%A6%E6%9C%AF/">学术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <comments>https://jhcgnb.cn/posts/undefined/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
