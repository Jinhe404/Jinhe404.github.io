<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>纸飞机的旅行</title>
    <link>https://jhcgnb.cn/</link>
    
    <atom:link href="https://jhcgnb.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>选择有时候比努力更重要</description>
    <pubDate>Sat, 07 Sep 2024 14:26:26 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>坐标系</title>
      <link>https://jhcgnb.cn/posts/140ab620/</link>
      <guid>https://jhcgnb.cn/posts/140ab620/</guid>
      <pubDate>Sat, 07 Sep 2024 13:51:30 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;em&gt;针对作坐标系这边参考网上以及自己的一些理解大家可以参考学习一下。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;一、GIS-坐标系&quot;&gt;&lt;a href=&quot;#一、GIS-坐标系&quot; class=&quot;headerlink&quot; title=&quot;一、GIS 坐标系&quot;&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><em>针对作坐标系这边参考网上以及自己的一些理解大家可以参考学习一下。</em></p><p>[TOC]</p><h3 id="一、GIS-坐标系"><a href="#一、GIS-坐标系" class="headerlink" title="一、GIS 坐标系"></a><strong>一、GIS 坐标系</strong></h3><p>要想在 Cesium 开发中得心应手，就得熟悉 Cesium 中常用的坐标类型，以及它们之间是如何进行转换的。等真正要用的时候，还可以再回来仔细研究，加深理解。</p><h3 id="二、经纬度坐标（球面坐标）"><a href="#二、经纬度坐标（球面坐标）" class="headerlink" title="二、经纬度坐标（球面坐标）"></a><strong>二、经纬度坐标（球面坐标）</strong></h3><p>经纬度坐标通常被叫做地理坐标或者地球坐标哦。它是一种基于地球表面的坐标系统，专门用来确定地球上任何一个点的位置呢。这个坐标系统主要用两个数值来表示位置，那就是经度和纬度。</p><ol><li><strong>经度（Longitude）</strong>：它表示的是从本初子午线（一般是通过英国伦敦的格林尼治天文台那条线）向东或者向西的角度距离。经度的范围是从 -180° 到 +180°，其中 0° 就代表本初子午线。</li><li><strong>纬度（Latitude）</strong>：表示从赤道向北或者向南的角度距离。纬度的范围是从 -90°（南极点）到 +90°（北极点），而 0° 呢，就表示赤道。</li></ol><p>经纬度坐标也常常被称作：</p><ul><li><strong>球面坐标（Spherical Coordinates）</strong>：因为地球近似是一个球体嘛，所以经纬度坐标就可以看作是在球面上确定点的位置。</li><li><strong>大地坐标（Geodetic Coordinates）</strong>：在大地测量学当中，这种坐标系统是用来描述地球表面上的点的。</li><li><strong>WGS84 坐标</strong>：WGS84（World Geodetic System 1984）是一种被广泛使用的全球地理坐标系统哦。它提供了一个标准化的参考框架，专门用于地理定位呢。</li></ul><p>经纬度坐标的应用可广泛啦，在地图制作、导航、地理信息系统（GIS）、航空和海洋导航等领域都能看到它的身影。在数字地图服务和应用程序当中，经纬度坐标更是最常见的位置表示方式之一呢。</p><h3 id="三、地理坐标（弧度）"><a href="#三、地理坐标（弧度）" class="headerlink" title="三、地理坐标（弧度）"></a><strong>三、地理坐标（弧度）</strong></h3><p>在地理信息系统（GIS）里呀，地理坐标通常指的是地球上某个点的位置，用经纬度来表示。不过呢，因为地球是一个近似的椭球体，要是用弧度而不是角度来表示经纬度坐标的话，就可以避免在计算当中引入一些复杂的情况，特别是在进行距离和面积的测量的时候。</p><p>弧度是一种角度的度量单位哦，它是基于圆的周长和半径之间的关系来定义的。一个完整的圆周被定义为 2π 弧度。弧度和角度的转换关系是这样的：比如角度转弧度，就是用角度值乘以 π/180；弧度转角度呢，就是用弧度值乘以 180/π。</p><p>在 GIS 中，使用弧度的地理坐标可以简化一些数学运算哦，尤其是涉及到三角函数和地球曲率的计算。比如说，在计算两点之间的大圆距离（也就是地球表面的最短路径）的时候，用弧度就可以更直接地应用球面三角学公式呢。</p><p><strong>地理坐标（弧度）的应用</strong>：</p><ol><li><strong>距离计算</strong>：使用球面三角学公式，可以更准确地算出两点之间的距离哦。</li><li><strong>方向计算</strong>：要确定从一个点到另一个点的方向，用弧度可以简化计算过程呢。</li><li><strong>地图投影</strong>：在某些地图投影中，使用弧度可以更自然地处理地球表面的曲率问题。</li></ol><h3 id="四、屏幕坐标系"><a href="#四、屏幕坐标系" class="headerlink" title="四、屏幕坐标系"></a><strong>四、屏幕坐标系</strong></h3><p>屏幕坐标系是一种二维坐标系统，专门用来描述屏幕上的点或者区域的位置。在屏幕坐标系当中，通常是以屏幕的左上角为原点，水平向右是 x 轴正方向，垂直向下是 y 轴正方向。在 Cesium 中，屏幕坐标系也被叫做二维笛卡尔平面坐标哦。</p><p>可以这样来创建屏幕坐标系中的一个点：<code>new Cesium.Cartesian2(x, y)</code>。</p><p>屏幕坐标系有这些特点呢：</p><ol><li><strong>原点位置</strong>：屏幕坐标系的原点（0,0）就在屏幕的左上角。</li><li><strong>正方向</strong>：x 轴正方向是向右的，y 轴正方向是向下的。</li><li><strong>单位</strong>：通常使用像素（px）作为单位。</li><li><strong>范围</strong>：坐标值的范围取决于屏幕或者窗口的大小。</li></ol><h3 id="五、空间直角坐标系"><a href="#五、空间直角坐标系" class="headerlink" title="五、空间直角坐标系"></a><strong>五、空间直角坐标系</strong></h3><p>在地理信息系统（GIS）中，空间直角坐标系是一种三维坐标系统哦，它可以在三维空间中非常精确地表示点、线、面的位置。这种坐标系一般是由三个正交的坐标轴组成，也就是 X、Y 和 Z 轴。</p><p>空间直角坐标系有这些特点：</p><ol><li><strong>正交性</strong>：X、Y 和 Z 轴是相互垂直的，形成了一个直角坐标系。</li><li><strong>三维性</strong>：可以表示三维空间中的任何位置呢，包括高度或者深度信息。</li><li><strong>标准化</strong>：通常是以地球的质心或者某个参考点为原点，建立起一个标准化的坐标系统。</li><li><strong>应用广泛</strong>：在地理测量、城市规划、建筑设计、3D 建模等领域都有广泛的应用。</li></ol><h3 id="六、Cesium-中的坐标系"><a href="#六、Cesium-中的坐标系" class="headerlink" title="六、Cesium 中的坐标系"></a><strong>六、Cesium 中的坐标系</strong></h3><p>Cesium 中支持两种坐标系呢，分别是 3D 笛卡尔坐标系和经纬度坐标系。</p><ol><li>3D 笛卡尔坐标系<ul><li>先来了解一下笛卡尔空间直角坐标系哈。它的 X、Y、Z 三个轴的正方向如下图所示。坐标系的原点是在地球的中心哦。所以呀，这些坐标通常是负的。单位一般是米。可以这样来创建一个 3D 笛卡尔坐标系中的点：<code>Cesium.Cartesian3(x, y, z)</code>。</li></ul></li><li>地理坐标系<ul><li>这是一种基于经度和纬度的坐标系，用度数来表示位置。在 Cesium 中，可以通过将经度、纬度和高度值传递给 Cartographic 对象来表示地理坐标哦。其中经度和纬度是以度数表示的，高度值可以是以米或其他单位表示的。Cesium 会把地理坐标转换为笛卡尔坐标，这样就能在地球表面上进行可视化啦。</li></ul></li></ol><h3 id="七、坐标系转换"><a href="#七、坐标系转换" class="headerlink" title="七、坐标系转换"></a><strong>七、坐标系转换</strong></h3><p>Cesium 提供了很多可以进行坐标系互相转换的大类呢。</p><ol><li><strong>经纬度转空间直角</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cartesian3 = <span class="title class_">Cesium</span>.<span class="property">Cartesian3</span>.<span class="title function_">fromDegrees</span>(lng, lat, height);</span><br></pre></td></tr></table></figure><p>这段代码的意思就是，把经度（lng）、纬度（lat）和高度（height）表示的经纬度坐标转换为空间直角坐标系中的一个点。</p><ol><li><strong>经纬度转地理坐标（弧度）</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> radians = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(degrees);</span><br></pre></td></tr></table></figure><p>这里呢，是把用角度表示的度数（degrees）转换为弧度（radians），也就是把经纬度从角度表示转换为弧度表示。</p><ol><li><strong>地理坐标（弧度）转经纬度</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> degrees = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toDegrees</span>(radians);</span><br></pre></td></tr></table></figure><p>和上面相反，把弧度（radians）表示的地理坐标转换为用角度表示的经纬度度数（degrees）。</p><ol><li><strong>空间直角转经纬度</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先将 3D 笛卡尔坐标转为地理坐标（弧度）</span></span><br><span class="line"><span class="keyword">const</span> cartographic = <span class="title class_">Cesium</span>.<span class="property">Cartographic</span>.<span class="title function_">fromCartesian</span>(cartesian3);</span><br><span class="line"><span class="comment">// 再将地理坐标（弧度）转为经纬度</span></span><br><span class="line"><span class="keyword">const</span> lat = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toDegrees</span>(cartographic.<span class="property">latitude</span>);</span><br><span class="line"><span class="keyword">const</span> lng = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toDegrees</span>(cartographic.<span class="property">longitude</span>);</span><br><span class="line"><span class="keyword">const</span> height = cartographic.<span class="property">height</span>;</span><br></pre></td></tr></table></figure><p>首先把空间直角坐标系中的点（cartesian3）转换为地理坐标（弧度）表示的 Cartographic 对象，然后再把这个对象中的纬度和经度从弧度转换为角度，就得到了经纬度坐标，同时还能得到高度值。</p><ol><li><strong>屏幕坐标转经纬度</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听点击事件，拾取坐标</span></span><br><span class="line"><span class="keyword">const</span> handler = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">ScreenSpaceEventHandler</span>(viewer.<span class="property">scene</span>.<span class="property">canvas</span>);</span><br><span class="line">handler.<span class="title function_">setInputAction</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> clickPosition = viewer.<span class="property">scene</span>.<span class="property">camera</span>.<span class="title function_">pickEllipsoid</span>(e.<span class="property">position</span>);</span><br><span class="line">    <span class="keyword">const</span> radiansPos = <span class="title class_">Cesium</span>.<span class="property">Cartographic</span>.<span class="title function_">fromCartesian</span>(clickPosition);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">        <span class="string">&quot;经度：&quot;</span> +</span><br><span class="line">        <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toDegrees</span>(radiansPos.<span class="property">longitude</span>) +</span><br><span class="line">        <span class="string">&quot;, 纬度：&quot;</span> +</span><br><span class="line">        <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toDegrees</span>(radiansPos.<span class="property">latitude</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;, <span class="title class_">Cesium</span>.<span class="property">ScreenSpaceEventType</span>.<span class="property">LEFT_CLICK</span>);</span><br></pre></td></tr></table></figure><p>这里是通过监听屏幕的点击事件，当用户在屏幕上点击时，获取点击位置对应的地球上的点（clickPosition），然后把这个点从笛卡尔坐标转换为地理坐标（弧度）表示的对象，最后再把这个对象中的经度和纬度从弧度转换为角度，就得到了点击位置对应的经纬度坐标。</p><ol><li><strong>屏幕坐标转空间直角坐标</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cartesian3 = viewer.<span class="property">scene</span>.<span class="property">globe</span>.<span class="title function_">pick</span>(viewer.<span class="property">camera</span>.<span class="title function_">getPickRay</span>(windowPostion), viewer.<span class="property">scene</span>);</span><br></pre></td></tr></table></figure><p>根据屏幕坐标（windowPostion），通过相机的射线拾取方法，获取对应的空间直角坐标系中的点。</p><ol><li><strong>世界坐标转屏幕坐标</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">windowPostion = <span class="title class_">Cesium</span>.<span class="property">SceneTransforms</span>.<span class="title function_">wgs84ToWindowCoordinates</span>(viewer.<span class="property">scene</span>, cartesian3);</span><br></pre></td></tr></table></figure><p>把世界坐标（一般是经纬度坐标转换后的空间直角坐标）表示的点（cartesian3）转换为屏幕坐标（windowPostion）。</p><p>欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</p><p><img src="https://25b7700e.telegraph-image-a7r.pages.dev/file/3bafbf1750de9058f0075.jpg" alt=""></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/Cesium/">Cesium</category>
      
      
      <comments>https://jhcgnb.cn/posts/140ab620/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第九期）</title>
      <link>https://jhcgnb.cn/posts/325c2834/</link>
      <guid>https://jhcgnb.cn/posts/325c2834/</guid>
      <pubDate>Sat, 07 Sep 2024 13:48:36 GMT</pubDate>
      
      <description>本文整理了WebGIS面试题，适合作为WebGIS面试准备。</description>
      
      
      
      <content:encoded><![CDATA[<p>[TOC]</p><h2 id="1、如何使用ArcGIS进行GIS坐标系转换？"><a href="#1、如何使用ArcGIS进行GIS坐标系转换？" class="headerlink" title="1、如何使用ArcGIS进行GIS坐标系转换？"></a>1、如何使用ArcGIS进行GIS坐标系转换？</h2><p>在ArcGIS中进行GIS坐标系转换通常涉及以下步骤：</p><ol><li><p><strong>定义坐标系</strong>：首先，确保你的数据具有正确的坐标系定义。如果数据没有定义坐标系，你需要使用“定义投影”工具来指定正确的坐标系。</p></li><li><p><strong>选择转换工具</strong>：根据你的数据类型（矢量或栅格），选择相应的转换工具。对于矢量数据，使用“投影”工具；对于栅格数据，使用“投影栅格”工具。</p></li><li><p><strong>设置转换参数</strong>：在进行坐标系转换时，可能需要指定“地理转换”参数。这个参数取决于你的数据是否涉及不同的地理坐标系。如果ArcGIS已知二者之间的转换方法，则该参数是可选的；如果未知，则必须自定义转换方法。</p></li><li><p><strong>使用自定义地理变换</strong>：如果ArcGIS不提供所需的坐标系转换方法，你可以使用“创建自定义地理变换”工具来创建新的转换方法。这通常涉及到三参数或七参数变换，其中七参数变换提供了更高精度的转换。</p></li><li><p><strong>执行转换</strong>：设置好所有参数后，运行转换工具。转换过程可能需要一些时间，具体取决于数据的大小和复杂性。</p></li><li><p><strong>验证结果</strong>：转换完成后，检查结果的准确性。你可以通过与已知坐标的点进行比较来验证转换的精度。</p></li><li><p><strong>保存和输出</strong>：一旦确认转换结果无误，保存转换后的数据，并根据需要进行进一步的分析或编辑。</p></li></ol><h2 id="2、Cesium中的Cartesian3坐标系的原点在哪里？它的轴是如何定义的？"><a href="#2、Cesium中的Cartesian3坐标系的原点在哪里？它的轴是如何定义的？" class="headerlink" title="2、Cesium中的Cartesian3坐标系的原点在哪里？它的轴是如何定义的？"></a>2、Cesium中的Cartesian3坐标系的原点在哪里？它的轴是如何定义的？</h2><p>Cartesian3坐标系的原点位于地球中心，通常用作地球的质心。X轴指向东经0度、北纬0度的方向；Y轴指向东经90度、北纬0度的方向；Z轴指向东经0度、北纬90度的方向</p><h2 id="3、如何在Cesium中使用矩阵进行坐标系转换。"><a href="#3、如何在Cesium中使用矩阵进行坐标系转换。" class="headerlink" title="3、如何在Cesium中使用矩阵进行坐标系转换。"></a>3、如何在Cesium中使用矩阵进行坐标系转换。</h2><ol><li><p><strong>建立转换矩阵</strong>：首先，需要建立一个从局部坐标系到世界坐标系（或反之）的转换矩阵。这通常涉及到使用<code>Cesium.Transforms.eastNorthUpToFixedFrame</code>方法，该方法以一个世界坐标系中的点为基础，创建一个局部坐标系，其中x轴指向东，y轴指向北，z轴指向上（通常是椭球体的法线方向）。</p></li><li><p><strong>使用矩阵进行转换</strong>：一旦有了转换矩阵，就可以使用<code>Cesium.Matrix4.multiplyByPoint</code>或<code>Cesium.Matrix4.multiplyByVector</code>方法来将点或向量从局部坐标系转换到世界坐标系，或者进行反向转换。</p></li><li><p><strong>转换经纬度坐标</strong>：如果需要在世界坐标系（WGS84）和笛卡尔坐标系之间转换，可以使用<code>Cesium.Cartesian3.fromDegrees</code>或<code>Cesium.Cartesian3.fromRadians</code>方法将经纬度坐标转换为笛卡尔坐标。反向转换可以使用<code>Cesium.Cartographic.fromCartesian</code>方法。</p></li><li><p><strong>局部坐标系转换</strong>：在处理局部坐标系（如模型或地形的局部坐标系）时，你可能需要将局部坐标转换为全局坐标系中的点。这可以通过将局部坐标乘以模型矩阵来实现，模型矩阵可以从实体的模型中获取。</p></li><li><p><strong>优化转换性能</strong>：在进行大量的坐标转换时，考虑性能优化是非常重要的。Cesium提供了一些工具和方法来减少计算量，例如使用<code>Cesium.Transforms.eastNorthUpToFixedFrame</code>来创建一个高效的转换矩阵，该矩阵可以直接应用于多个坐标点。</p></li></ol><h2 id="4、在Cesium中，如何将屏幕坐标转换为地球表面的坐标？"><a href="#4、在Cesium中，如何将屏幕坐标转换为地球表面的坐标？" class="headerlink" title="4、在Cesium中，如何将屏幕坐标转换为地球表面的坐标？"></a>4、在Cesium中，如何将屏幕坐标转换为地球表面的坐标？</h2><p>在Cesium中，将屏幕坐标（通常是鼠标点击位置）转换为地球表面的坐标（如经纬度坐标）的过程通常涉及到以下几个步骤：</p><ol><li><p><strong>获取屏幕坐标</strong>：首先需要获取用户的点击位置，这通常是通过监听<code>LEFT_CLICK</code>事件来完成的。</p></li><li><p><strong>将屏幕坐标转换为归一化的设备坐标</strong>：将屏幕坐标转换为归一化的设备坐标（normalized device coordinates），这是相对于屏幕尺寸的一个比例坐标。</p></li><li><p><strong>使用相机的光线投射功能</strong>：利用Cesium中的<code>camera.pickEllipsoid</code>方法，从归一化的设备坐标发射一条光线，这条光线会穿过地球模型，直到与地球相交的第一个点。</p></li><li><p><strong>获取交点的地理坐标</strong>：最后，将得到的交点坐标从笛卡尔坐标系（3D直角坐标系）转换为地理坐标系（经纬度坐标）。</p></li></ol><p>下面是具体的JavaScript代码示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取屏幕坐标</span></span><br><span class="line"><span class="keyword">var</span> handler = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">ScreenSpaceEventHandler</span>(viewer.<span class="property">scene</span>.<span class="property">canvas</span>);</span><br><span class="line"></span><br><span class="line">handler.<span class="title function_">setInputAction</span>(<span class="keyword">function</span>(<span class="params">click</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取点击位置的屏幕坐标</span></span><br><span class="line">    <span class="keyword">var</span> screenPosition = click.<span class="property">position</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Ray对象，表示从摄像机发出的光线</span></span><br><span class="line">    <span class="keyword">var</span> ray = viewer.<span class="property">camera</span>.<span class="title function_">getPickRay</span>(screenPosition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用pickEllipsoid方法找到光线与地球椭球体的交点</span></span><br><span class="line">    <span class="keyword">var</span> cartesian3 = viewer.<span class="property">scene</span>.<span class="property">globe</span>.<span class="title function_">pick</span>(ray, viewer.<span class="property">scene</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否找到了交点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Cesium</span>.<span class="title function_">defined</span>(cartesian3)) &#123;</span><br><span class="line">        <span class="comment">// 将笛卡尔坐标转换为地理坐标</span></span><br><span class="line">        <span class="keyword">var</span> cartographic = <span class="title class_">Cesium</span>.<span class="property">Cartographic</span>.<span class="title function_">fromCartesian</span>(cartesian3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将地理坐标（弧度）转换为经纬度（度）</span></span><br><span class="line">        <span class="keyword">var</span> longitude = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toDegrees</span>(cartographic.<span class="property">longitude</span>);</span><br><span class="line">        <span class="keyword">var</span> latitude = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toDegrees</span>(cartographic.<span class="property">latitude</span>);</span><br><span class="line">        <span class="keyword">var</span> height = cartographic.<span class="property">height</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;经度: &quot;</span> + longitude + <span class="string">&quot;, 纬度: &quot;</span> + latitude + <span class="string">&quot;, 高度: &quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="title class_">Cesium</span>.<span class="property">ScreenSpaceEventType</span>.<span class="property">LEFT_CLICK</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>screenPosition</code> 是点击位置的屏幕坐标。</li><li><code>ray</code> 是从摄像机发出的一条光线。</li><li><code>viewer.scene.globe.pick</code> 方法用于找到光线与地球椭球体的交点。</li><li><code>Cesium.Cartographic.fromCartesian</code> 方法将笛卡尔坐标转换为地理坐标。</li><li><code>Cesium.Math.toDegrees</code> 方法将弧度转换为度数。</li></ul><p>这段代码将会打印出点击位置的经纬度坐标和高度。</p><h2 id="5、Cesium-中的-Cartesian3-和-Cartographic-有什么区别？"><a href="#5、Cesium-中的-Cartesian3-和-Cartographic-有什么区别？" class="headerlink" title="5、Cesium 中的 Cartesian3 和 Cartographic 有什么区别？"></a>5、Cesium 中的 Cartesian3 和 Cartographic 有什么区别？</h2><p><strong><code>Cartesian3</code></strong>：笛卡尔坐标系，使用 <code>x, y, z</code> 三个维度来表示物体在空间中的位置，单位为米。</p><p><strong><code>Cartographic</code></strong>：地理坐标系，使用经度、纬度和高度来表示物体在地球表面的位置，经纬度单位为度，高度单位为米。</p><h2 id="6、Cesium-中的地心坐标系（ECI）与地固坐标系（ECEF）有什么区别？"><a href="#6、Cesium-中的地心坐标系（ECI）与地固坐标系（ECEF）有什么区别？" class="headerlink" title="6、Cesium 中的地心坐标系（ECI）与地固坐标系（ECEF）有什么区别？"></a>6、Cesium 中的地心坐标系（ECI）与地固坐标系（ECEF）有什么区别？</h2><p><strong>ECI（Earth-Centered Inertial）</strong>：地心惯性坐标系，与地球的自转无关，是惯性参考系。</p><p><strong>ECEF（Earth-Centered Earth-Fixed）</strong>：地固坐标系，固定在地球上，随着地球的自转而转动，是 Cesium 中常用的坐标系。</p><h2 id="7、Cesium-中为什么采用-WGS84-坐标系？"><a href="#7、Cesium-中为什么采用-WGS84-坐标系？" class="headerlink" title="7、Cesium 中为什么采用 WGS84 坐标系？"></a>7、Cesium 中为什么采用 WGS84 坐标系？</h2><p>WGS84 是全球使用的标准地理坐标系统，具有高度的精度和广泛的使用范围，Cesium 使用它来确保兼容性和一致性。</p><h2 id="8、如何处理-Cesium-中的坐标系漂移问题？"><a href="#8、如何处理-Cesium-中的坐标系漂移问题？" class="headerlink" title="8、如何处理 Cesium 中的坐标系漂移问题？"></a>8、如何处理 Cesium 中的坐标系漂移问题？</h2><p>Cesium 提供了一些工具来减少坐标精度的影响，例如使用 <code>relativeToCenter</code> 来处理相对坐标，以避免精度损失。</p><h2 id="9、如果要将一个在本地坐标系下的模型加载到-Cesium-中，并且要正确定位在地球表面，需要考虑哪些坐标系相关的问题？"><a href="#9、如果要将一个在本地坐标系下的模型加载到-Cesium-中，并且要正确定位在地球表面，需要考虑哪些坐标系相关的问题？" class="headerlink" title="9、如果要将一个在本地坐标系下的模型加载到 Cesium 中，并且要正确定位在地球表面，需要考虑哪些坐标系相关的问题？"></a>9、如果要将一个在本地坐标系下的模型加载到 Cesium 中，并且要正确定位在地球表面，需要考虑哪些坐标系相关的问题？</h2><p>需要考虑本地坐标系与 Cesium 坐标系的转换关系，可能需要知道模型在本地坐标系中的位置、旋转、缩放等信息，并通过合适的方法转换到 Cesium 的世界坐标系中。</p><p><strong>详细</strong>：</p><p>在将一个本地坐标系下的模型加载到 Cesium 中并正确定位在地球表面时，需要考虑以下坐标系相关的问题：</p><h3 id="1-本地坐标系与全球坐标系的转换"><a href="#1-本地坐标系与全球坐标系的转换" class="headerlink" title="1. 本地坐标系与全球坐标系的转换"></a>1. <strong>本地坐标系与全球坐标系的转换</strong></h3><ul><li><strong>本地坐标系</strong>：通常是指模型在局部的平面或三维坐标系下（如建筑物或小区域的局部坐标），通常以模型中心或某一特定点作为原点。</li><li><strong>全球坐标系</strong>：Cesium 使用的全球坐标系是地球固定坐标系 (ECEF - Earth-Centered Earth-Fixed)，即地球椭球体中心为原点的笛卡尔坐标系。</li></ul><p>将本地坐标系下的模型放置到 Cesium 中的全球坐标系下，需要对模型的原点位置进行转换，并考虑旋转和缩放问题。</p><h3 id="2-坐标系原点的转换"><a href="#2-坐标系原点的转换" class="headerlink" title="2. 坐标系原点的转换"></a>2. <strong>坐标系原点的转换</strong></h3><ul><li><p>本地坐标系的原点需要映射到地球上的某一特定位置。这个位置通常通过经纬度（<code>longitude</code> 和 <code>latitude</code>）以及高度（<code>height</code>）来指定。</p></li><li><p><strong>方法</strong>：使用 <code>Cesium.Cartesian3.fromDegrees(longitude, latitude, height)</code> 将经纬度和高度转换为 Cesium 的全球笛卡尔坐标。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> modelPosition = <span class="title class_">Cesium</span>.<span class="property">Cartesian3</span>.<span class="title function_">fromDegrees</span>(longitude, latitude, height);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-模型的旋转"><a href="#3-模型的旋转" class="headerlink" title="3. 模型的旋转"></a>3. <strong>模型的旋转</strong></h3><p>本地坐标系的方向通常不符合地球坐标系的方向（东、北、上）。需要考虑模型的旋转角度：</p><ul><li><strong>轴的对齐</strong>：Cesium 的地球坐标系使用的是 ECEF 坐标系（<code>x</code> 向量指向赤道上的本初子午线方向，<code>z</code> 向量指向北极），而模型可能使用其他轴定义。</li><li><strong>调整旋转矩阵</strong>：可以通过给模型添加旋转矩阵或四元数来调整模型的姿态。Cesium 提供了 <code>Matrix4</code> 和 <code>Quaternion</code> 来进行矩阵变换和旋转。</li></ul><p>例如，可以使用 <code>Cesium.Transforms.headingPitchRollQuaternion</code> 根据模型的朝向角（heading）、俯仰角（pitch）、滚动角（roll）进行姿态调整：</p>   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> orientation = <span class="title class_">Cesium</span>.<span class="property">Transforms</span>.<span class="title function_">headingPitchRollQuaternion</span>(</span><br><span class="line">    modelPosition,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">HeadingPitchRoll</span>(heading, pitch, roll)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="4-缩放问题"><a href="#4-缩放问题" class="headerlink" title="4. 缩放问题"></a>4. <strong>缩放问题</strong></h3><p>本地坐标系中的模型可能需要根据其实际大小进行缩放，以确保在全球坐标系中的正确尺寸。</p><ul><li><p>Cesium 支持通过 <code>scale</code> 属性设置模型的缩放因子。例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">model.<span class="property">scale</span> = <span class="number">2.0</span>;  <span class="comment">// 将模型放大 2 倍</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-地球曲率的影响"><a href="#5-地球曲率的影响" class="headerlink" title="5. 地球曲率的影响"></a>5. <strong>地球曲率的影响</strong></h3><p>本地坐标系通常是平面的，但在 Cesium 中模型是放置在曲面的地球椭球体上。如果模型覆盖的区域较大，则需要考虑地球曲率的影响，可能需要对模型的平面坐标进行变换，使其适应地球的球形表面。</p><h3 id="6-模型的局部平移和旋转"><a href="#6-模型的局部平移和旋转" class="headerlink" title="6. 模型的局部平移和旋转"></a>6. <strong>模型的局部平移和旋转</strong></h3><p>如果模型在本地坐标系中有相对的平移或旋转，可以通过 Cesium 的 <code>ModelMatrix</code> 来处理这些局部变换：</p><ul><li><strong>平移</strong>：如果需要对模型在本地坐标系中进行相对的平移，可以调整模型的 <code>ModelMatrix</code> 来实现。</li><li><strong>局部旋转</strong>：通过修改 <code>ModelMatrix</code> 进行局部旋转，保持模型的相对方向。</li></ul><h3 id="7-Cesium-中的-ModelMatrix"><a href="#7-Cesium-中的-ModelMatrix" class="headerlink" title="7. Cesium 中的 ModelMatrix"></a>7. <strong>Cesium 中的 <code>ModelMatrix</code></strong></h3><p>Cesium 中的 <code>ModelMatrix</code> 可以用来定义模型的位置、旋转和缩放变换。你可以根据上述经纬度、旋转和缩放信息设置模型的矩阵。例如：</p>   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> modelMatrix = <span class="title class_">Cesium</span>.<span class="property">Transforms</span>.<span class="title function_">eastNorthUpToFixedFrame</span>(modelPosition);</span><br><span class="line"><span class="keyword">var</span> model = viewer.<span class="property">scene</span>.<span class="property">primitives</span>.<span class="title function_">add</span>(<span class="title class_">Cesium</span>.<span class="property">Model</span>.<span class="title function_">fromGltf</span>(&#123;</span><br><span class="line">    url : <span class="string">&#x27;model.gltf&#x27;</span>,</span><br><span class="line">    modelMatrix : modelMatrix,</span><br><span class="line">    <span class="attr">scale</span>: <span class="number">1.0</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="8-高程数据的处理"><a href="#8-高程数据的处理" class="headerlink" title="8. 高程数据的处理"></a>8. <strong>高程数据的处理</strong></h3><ul><li><p>如果模型的位置需要精确匹配地形，可以考虑使用 Cesium 的高程数据服务，通过 <code>sampleTerrain</code> 方法来查询特定经纬度的地形高度：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> terrainProvider = <span class="title class_">Cesium</span>.<span class="title function_">createWorldTerrain</span>();</span><br><span class="line"><span class="title class_">Cesium</span>.<span class="title function_">sampleTerrain</span>(terrainProvider, <span class="number">11</span>, [cartographic]).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">updatedPositions</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> height = updatedPositions[<span class="number">0</span>].<span class="property">height</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</p><p><img src="https://25b7700e.telegraph-image-a7r.pages.dev/file/3bafbf1750de9058f0075.jpg" alt=""></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/325c2834/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>linux系统下环境部署</title>
      <link>https://jhcgnb.cn/posts/e89aff94/</link>
      <guid>https://jhcgnb.cn/posts/e89aff94/</guid>
      <pubDate>Mon, 12 Aug 2024 07:49:45 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;一、环境准备&quot;&gt;&lt;a href=&quot;#一、环境准备&quot; class=&quot;headerlink&quot; title=&quot;一、环境准备&quot;&gt;&lt;/a&gt;一、环境准备&lt;/h1&gt;&lt;p&gt;说明：如果已经安装过相关工具就忽略&lt;/p&gt;
&lt;h2 id=&quot;1、安装JAVA-运行环境&quot;&gt;&lt;a href=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h1><p>说明：如果已经安装过相关工具就忽略</p><h2 id="1、安装JAVA-运行环境"><a href="#1、安装JAVA-运行环境" class="headerlink" title="1、安装JAVA 运行环境"></a>1、安装JAVA 运行环境</h2><h6 id="第一步：上传或下载安装包"><a href="#第一步：上传或下载安装包" class="headerlink" title="第一步：上传或下载安装包"></a>第一步：上传或下载安装包</h6><p>cd  /usr/local</p><p>jdk-8u152-linux-x64.tar.gz</p><h6 id="第二步：解压安装包"><a href="#第二步：解压安装包" class="headerlink" title="第二步：解压安装包"></a>第二步：解压安装包</h6><p>tar -zxvf jdk-8u152-linux-x64.tar.gz</p><h6 id="第三步：建立软连接"><a href="#第三步：建立软连接" class="headerlink" title="第三步：建立软连接"></a>第三步：建立软连接</h6><p>ln -s /usr/local/jdk1.8.0_152/  /usr/local/jdk</p><h6 id="第四步：修改环境变量"><a href="#第四步：修改环境变量" class="headerlink" title="第四步：修改环境变量"></a>第四步：修改环境变量</h6><p>vim /etc/profile</p><p>export JAVA_HOME=/usr/local/jdk</p><p>export JRE_HOME=$JAVA_HOME/jre</p><p>export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib</p><p>export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</p><p>通过命令source /etc/profile让profile文件立即生效</p><p>source /etc/profile</p><h6 id="第五步、测试是否安装成功"><a href="#第五步、测试是否安装成功" class="headerlink" title="第五步、测试是否安装成功"></a>第五步、测试是否安装成功</h6><p>使用java -version，出现版本为java version “1.8.0_152”</p><h2 id="2、安装maven"><a href="#2、安装maven" class="headerlink" title="2、安装maven"></a>2、安装maven</h2><h6 id="第一步：上传或下载安装包-1"><a href="#第一步：上传或下载安装包-1" class="headerlink" title="第一步：上传或下载安装包"></a>第一步：上传或下载安装包</h6><p>cd  /usr/local</p><p>apache-maven-3.6.1-bin.tar.gz</p><h6 id="第二步：解压安装包-1"><a href="#第二步：解压安装包-1" class="headerlink" title="第二步：解压安装包"></a>第二步：解压安装包</h6><p>tar  -zxvf  apache-maven-3.6.1-bin.tar.gz</p><h6 id="第三步：建立软连接-1"><a href="#第三步：建立软连接-1" class="headerlink" title="第三步：建立软连接"></a>第三步：建立软连接</h6><p>ln  -s  /usr/local/apache-maven-3.6.1/  /usr/local/maven</p><h6 id="第四步：修改环境变量-1"><a href="#第四步：修改环境变量-1" class="headerlink" title="第四步：修改环境变量"></a>第四步：修改环境变量</h6><p>vim /etc/profile</p><p>export MAVEN_HOME=/usr/local/maven</p><p>export PATH=$PATH:$MAVEN_HOME/bin</p><p>通过命令source /etc/profile让profile文件立即生效</p><p>source /etc/profile</p><h6 id="第五步、测试是否安装成功-1"><a href="#第五步、测试是否安装成功-1" class="headerlink" title="第五步、测试是否安装成功"></a>第五步、测试是否安装成功</h6><p>mvn –v</p><h2 id="3、安装docker"><a href="#3、安装docker" class="headerlink" title="3、安装docker"></a>3、安装docker</h2><h6 id="环境安装："><a href="#环境安装：" class="headerlink" title="环境安装："></a>环境安装：</h6><p>yum -y install gcc-c++</p><h6 id="第一步：安装必要的一些系统工具"><a href="#第一步：安装必要的一些系统工具" class="headerlink" title="第一步：安装必要的一些系统工具"></a>第一步：安装必要的一些系统工具</h6><p>yum install -y yum-utils device-mapper-persistent-data lvm2</p><h6 id="第二步：添加软件源信息"><a href="#第二步：添加软件源信息" class="headerlink" title="第二步：添加软件源信息"></a>第二步：添加软件源信息</h6><p>yum-config-manager —add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p><h6 id="第三步：更新并安装Docker-CE"><a href="#第三步：更新并安装Docker-CE" class="headerlink" title="第三步：更新并安装Docker-CE"></a>第三步：更新并安装Docker-CE</h6><p>yum makecache fast</p><p>yum -y install docker-ce</p><h6 id="第四步：开启Docker服务"><a href="#第四步：开启Docker服务" class="headerlink" title="第四步：开启Docker服务"></a>第四步：开启Docker服务</h6><p>systemctl start docker</p><p>systemctl enable docker</p><h6 id="第五步：测试是否安装成功"><a href="#第五步：测试是否安装成功" class="headerlink" title="第五步：测试是否安装成功"></a>第五步：测试是否安装成功</h6><p>docker -v</p><h6 id="第六步：配置镜像加速器"><a href="#第六步：配置镜像加速器" class="headerlink" title="第六步：配置镜像加速器"></a>第六步：配置镜像加速器</h6><p>您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器</p><p>sudo mkdir -p /etc/docker</p><p>sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’</p><p>{</p><p>“registry-mirrors”: [“<a href="https://ldu6wrsf.mirror.aliyuncs.com">https://ldu6wrsf.mirror.aliyuncs.com</a>“]</p><p>}</p><p>EOF</p><p>sudo systemctl daemon-reload</p><p>sudo systemctl restart docker</p><h2 id="4、安装mysql"><a href="#4、安装mysql" class="headerlink" title="4、安装mysql"></a>4、安装mysql</h2><h6 id="第一步：拉取镜像"><a href="#第一步：拉取镜像" class="headerlink" title="第一步：拉取镜像"></a>第一步：拉取镜像</h6><p>docker pull mysql:5.7</p><h6 id="第二步：启动"><a href="#第二步：启动" class="headerlink" title="第二步：启动"></a>第二步：启动</h6><p>docker run —name mysql —restart=always -v /home/ljaer/mysql:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</p><h6 id="第三步：测试mysql"><a href="#第三步：测试mysql" class="headerlink" title="第三步：测试mysql"></a>第三步：测试mysql</h6><p>进入容器：</p><p>docker exec -it mysql /bin/bash</p><p>登录mysql：</p><p>mysql -u root -p</p><p>如果顺利进入，安装成功</p><h2 id="5、安装rabbitmq"><a href="#5、安装rabbitmq" class="headerlink" title="5、安装rabbitmq"></a>5、安装rabbitmq</h2><h6 id="第一步：拉取镜像-1"><a href="#第一步：拉取镜像-1" class="headerlink" title="第一步：拉取镜像"></a>第一步：拉取镜像</h6><p>docker pull rabbitmq:management</p><h6 id="第二步：启动-1"><a href="#第二步：启动-1" class="headerlink" title="第二步：启动"></a>第二步：启动</h6><p>docker run -d -p 5672:5672 -p 15672:15672 —restart=always —name rabbitmq rabbitmq:management</p><h6 id="第三步：安装延迟队列插件"><a href="#第三步：安装延迟队列插件" class="headerlink" title="第三步：安装延迟队列插件"></a>第三步：安装延迟队列插件</h6><ol><li>首先下载rabbitmq_delayed_message_exchange-3.9.0.ez文件上传到RabbitMQ所在服务器，下载地址：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></li><li>切换到插件所在目录，执行 docker cp rabbitmq_delayed_message_exchange-3.9.0.ez rabbitmq:/plugins 命令，将刚插件拷贝到容器内plugins目录下</li><li>执行 docker exec -it rabbitmq /bin/bash 命令进入到容器内部，并 cd plugins 进入plugins目录</li><li>执行 ls -l|grep delay  命令查看插件是否copy成功</li><li>在容器内plugins目录下，执行 rabbitmq-plugins enable rabbitmq_delayed_message_exchange  命令启用插件</li><li>exit命令退出RabbitMQ容器内部，然后执行 docker restart rabbitmq 命令重启RabbitMQ容器</li></ol><h2 id="6、安装redis"><a href="#6、安装redis" class="headerlink" title="6、安装redis"></a>6、安装redis</h2><h6 id="第一步：拉取镜像-2"><a href="#第一步：拉取镜像-2" class="headerlink" title="第一步：拉取镜像"></a>第一步：拉取镜像</h6><p>docker pull redis:latest</p><h6 id="第二步：启动-2"><a href="#第二步：启动-2" class="headerlink" title="第二步：启动"></a>第二步：启动</h6><p>docker run -d -p 6379:6379  —restart=always redis:latest redis-server</p><h2 id="7、安装nacos"><a href="#7、安装nacos" class="headerlink" title="7、安装nacos"></a>7、安装nacos</h2><h6 id="第一步：拉取镜像-3"><a href="#第一步：拉取镜像-3" class="headerlink" title="第一步：拉取镜像"></a>第一步：拉取镜像</h6><p>docker pull nacos/nacos-server:1.4.1</p><h6 id="第二步：启动-3"><a href="#第二步：启动-3" class="headerlink" title="第二步：启动"></a>第二步：启动</h6><p>docker run —env MODE=standalone —name nacos —restart=always -d -p 8848:8848 -e JVM_XMS=512m -e JVM_XMX=512m nacos/nacos-server:1.4.1</p><h2 id="8、安装sentinel"><a href="#8、安装sentinel" class="headerlink" title="8、安装sentinel"></a>8、安装sentinel</h2><h6 id="第一步：拉取镜像-4"><a href="#第一步：拉取镜像-4" class="headerlink" title="第一步：拉取镜像"></a>第一步：拉取镜像</h6><p>docker pull bladex/sentinel-dashboard</p><h6 id="第二步：启动-4"><a href="#第二步：启动-4" class="headerlink" title="第二步：启动"></a>第二步：启动</h6><p>docker run —name sentinel-dashboard —restart=always -p 8858:8858 -d bladex/sentinel-dashboard:latest</p><h2 id="9、安装elasticsearch"><a href="#9、安装elasticsearch" class="headerlink" title="9、安装elasticsearch"></a>9、安装elasticsearch</h2><h6 id="第一步：拉取镜像-5"><a href="#第一步：拉取镜像-5" class="headerlink" title="第一步：拉取镜像"></a>第一步：拉取镜像</h6><p>docker pull elasticsearch:7.8.0</p><h6 id="第二步：启动-5"><a href="#第二步：启动-5" class="headerlink" title="第二步：启动"></a>第二步：启动</h6><p>需要建立：两个文件夹</p><p>mkdir -p /mydata/elasticsearch/plugins</p><p>mkdir -p /mydata/elasticsearch/data</p><p>授予权限chmod 777 /mydata/elasticsearch/data</p><p>docker run -p 9200:9200 -p 9300:9300 —name elasticsearch —restart=always -e “discovery.type=single-node” -e ES_JAVA_OPTS=”-Xms512m -Xmx512m” -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -d elasticsearch:7.8.0</p><h6 id="第三步：安装中文分词器"><a href="#第三步：安装中文分词器" class="headerlink" title="第三步：安装中文分词器"></a>第三步：安装中文分词器</h6><ol><li>下载elasticsearch-analysis-ik-7.8.0.zip</li><li>上传解压：unzip elasticsearch-analysis-ik-7.8.0.zip -d ik-analyzer</li><li>上传到es容器：docker cp ./ik-analyzer a24eb9941759:/usr/share/elasticsearch/plugins ///  docker cp ./ik-analyzer elasticsearch:/usr/share/elasticsearch/plugins</li><li>重启es：docker restart a24eb9941759</li></ol><p>a24eb9941759：表示容器ID 运行时，需要改成自己的容器ID</p><h2 id="10-、安装kibana"><a href="#10-、安装kibana" class="headerlink" title="10 、安装kibana"></a>10 、安装kibana</h2><h6 id="第一步：拉取镜像-6"><a href="#第一步：拉取镜像-6" class="headerlink" title="第一步：拉取镜像"></a>第一步：拉取镜像</h6><p>docker pull kibana:7.8.0</p><h6 id="第二步：启动-6"><a href="#第二步：启动-6" class="headerlink" title="第二步：启动"></a>第二步：启动</h6><p>docker run —name kibana —restart=always -e ELASTICSEARCH_URL=<a href="http://192.168.6.103:9200">http://192.168.6.103:9200</a> -p 5601:5601 -d kibana:7.8.0</p><p>进入容器修改：docker exec -it 1e12f8dd3efd /bin/bash  ///   docker exec -it kibana /bin/bash</p><p>cd config</p><p>vi kibana.yml</p><p>elasticsearch.hosts: [ “<a href="http://192.168.200.129:9200">http://192.168.200.129:9200</a>“ ]</p><p>docker restart 1dc0f78d78ad 重启kibana ！</p><p>测试：安装分词词库是否可以使用！</p><p>GET /.kibana/_analyze</p><p>{</p><p>“text”: “我是中国人”,</p><p>“analyzer”: “ik_max_word”</p><p>}</p><h2 id="11、安装zipkin"><a href="#11、安装zipkin" class="headerlink" title="11、安装zipkin"></a>11、安装zipkin</h2><h6 id="第一步：拉取镜像-7"><a href="#第一步：拉取镜像-7" class="headerlink" title="第一步：拉取镜像"></a>第一步：拉取镜像</h6><p>docker pull openzipkin/zipkin</p><h6 id="第二步：启动-7"><a href="#第二步：启动-7" class="headerlink" title="第二步：启动"></a>第二步：启动</h6><p>docker run —name zipkin —restart=always -d -p 9411:9411 openzipkin/zipkin</p><h2 id="12、安装minio"><a href="#12、安装minio" class="headerlink" title="12、安装minio"></a>12、安装minio</h2><h6 id="第一步：拉取镜像-8"><a href="#第一步：拉取镜像-8" class="headerlink" title="第一步：拉取镜像"></a>第一步：拉取镜像</h6><p>docker pull minio/minio</p><h6 id="第二步：启动-8"><a href="#第二步：启动-8" class="headerlink" title="第二步：启动"></a>第二步：启动</h6><p>docker run \ -p 9000:9000 \ -p 9001:9001 \ —name minio \ -d —restart=always \ -e “MINIO_ROOT_USER=admin” \ -e “MINIO_ROOT_PASSWORD=admin123456” \ -v /home/data:/data \ -v /home/config:/root/.minio \ minio/minio server /data —console-address “:9001”</p><p>浏览器访问：<a href="http://IP:9000/minio/login，">http://IP:9000/minio/login，</a></p><h2 id="13-、安装logstash"><a href="#13-、安装logstash" class="headerlink" title="13 、安装logstash"></a>13 、安装logstash</h2><h6 id="第一步：拉取镜像-9"><a href="#第一步：拉取镜像-9" class="headerlink" title="第一步：拉取镜像"></a>第一步：拉取镜像</h6><p>docker pull logstash:7.8.0</p><h6 id="第二步：启动-9"><a href="#第二步：启动-9" class="headerlink" title="第二步：启动"></a>第二步：启动</h6><p>docker run —name logstash -p 5044:5044 —restart=always —link elasticsearch:es -v /mydata/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf -d logstash:7.8.0</p><p>—net root_default \</p><div class="table-container"><table><thead><tr><th># 需要提前在linux服务器上环境 /mydata/logstash/logstash.conf    logstash.conf    input {     tcp {        mode =&gt; “server”        host =&gt; “0.0.0.0”        port =&gt; 5044        codec =&gt; json_lines     }    }    filter{         }    output {     elasticsearch {        hosts =&gt; “192.168.6.103:9200”        index =&gt; “gmall-%{+YYYY.MM.dd}”     }    }</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>停止所有的容器</p><p>docker stop $(docker ps -aq)</p><p>删除所有的容器</p><p>docker rm $(docker ps -aq)</p><p>#删除所有的镜像</p><p>docker rmi $(docker images -q)</p><p>问题：</p><p>Docker容器做端口映射报错</p><p>docker: Error response from daemon: driver failed programming external connectivity on endpoint lamp3 (46b7917c940f7358948e55ec2df69a4dec2c6c7071b002bd374e8dbf0d40022c): (iptables failed: iptables —wait -t nat -A DOCKER -p tcp -d 0/0 —dport 86 -j DNAT —to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name.</p><p>解决方法</p><p>docker服务启动时定义的自定义链DOCKER被清除</p><p>重启即可systemctl restart docker</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">linux环境下部署开发环境</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">安装教程</category>
      
      
      <comments>https://jhcgnb.cn/posts/e89aff94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>（windows系统环境下）ollama + fastgpt搭建本地私有大模型</title>
      <link>https://jhcgnb.cn/posts/f8ffd5a4/</link>
      <guid>https://jhcgnb.cn/posts/f8ffd5a4/</guid>
      <pubDate>Sat, 27 Jul 2024 15:55:47 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;（windows系统环境下）ollama-fastgpt搭建本地私有大模型&quot;&gt;&lt;a href=&quot;#（windows系统环境下）ollama-fastgpt搭建本地私有大模型&quot; class=&quot;headerlink&quot; title=&quot;（windows系统环境下）olla</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="（windows系统环境下）ollama-fastgpt搭建本地私有大模型"><a href="#（windows系统环境下）ollama-fastgpt搭建本地私有大模型" class="headerlink" title="（windows系统环境下）ollama + fastgpt搭建本地私有大模型"></a>（windows系统环境下）ollama + fastgpt搭建本地私有大模型</h2><p>[TOC]</p><h3 id="一、安装ollama"><a href="#一、安装ollama" class="headerlink" title="一、安装ollama"></a>一、安装ollama</h3><h4 id="1、安装ollama"><a href="#1、安装ollama" class="headerlink" title="1、安装ollama"></a>1、安装ollama</h4><p>下载ollama官方windows安装程序，下载后直接双击应用程序安装。</p><p>地址：Ollama.com</p><p><img src="https://telegraph-image-a7r.pages.dev/file/95791eeaca4c584a3fa12.png"></p><p>安装完成后进行更换ollama的存储位置</p><p>（设置环境变量）：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/2c482d652c8bf28d8817d.png"></p><p>设置完成后重启电脑。</p><h4 id="2、下载模型"><a href="#2、下载模型" class="headerlink" title="2、下载模型"></a>2、下载模型</h4><p>ollama官网顶部Models，进入模型列表界面。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/34030191822632ccec634.png"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/a4b93b765e4b9cd65d8a7.png"></p><p>复制完成后进入cmd，并开始下载模型，将复制的模型 粘贴并回车。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/6867a5d6c0f298b65d2e8.png"></p><p>等待就行</p><p><img src="https://telegraph-image-a7r.pages.dev/file/08ad8a52551e37ebbc123.png"></p><p>上图为拉取进度，完成后会自动进行编译，然后本地cmd方式即可进行对话。</p><p>经过以上步骤本地大模型llama3以安装完成，接下来我们通过docker desktop进行搭建fastgpt。</p><h3 id="二、安装部署Fastgpt"><a href="#二、安装部署Fastgpt" class="headerlink" title="二、安装部署Fastgpt"></a>二、安装部署Fastgpt</h3><h4 id="1、部署fastgpt到dockerdesktop"><a href="#1、部署fastgpt到dockerdesktop" class="headerlink" title="1、部署fastgpt到dockerdesktop"></a>1、部署fastgpt到dockerdesktop</h4><p>Fastgpt开源项目地址：<a href="https://github.com/labring/FastGPT">https://github.com/labring/FastGPT</a></p><p>Fastgpt官方docker模式部署地址：<a href="https://doc.fastgpt.in/docs/development/docker/">https://doc.fastgpt.in/docs/development/docker/</a></p><p>方法如下：</p><p>下载 docker desktop。</p><p>安装 docker desktop</p><p>（百度，非常简单）</p><p>依次执行下面命令，创建 FastGPT 文件夹并下载docker-compose.yml和config.json文件，完成后目录下会有 2 个文件。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/865c3ff67d02fc1a11604.png"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/f1d431750dc49be1658af.png" alt="8"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/3ad7f66a837e77d2052c4.png" alt="9"></p><p>文件创建好并拷贝出git上对应的两个文件内容，并cmd进入当前文件夹执行代码：docker-compose up -d</p><p><img src="https://telegraph-image-a7r.pages.dev/file/a1f9e46a65221afe4b4d3.png"></p><h5 id="注意：执行前修改docker-compose-yml中的内容-取消阿里云的注释，将dockerc-hub的源注释。（“自从2023年5月中旬，著名Docker-容器平台：-http-hub-docker-com-“不知”-何种原因国内均无法正常访问了。”）"><a href="#注意：执行前修改docker-compose-yml中的内容-取消阿里云的注释，将dockerc-hub的源注释。（“自从2023年5月中旬，著名Docker-容器平台：-http-hub-docker-com-“不知”-何种原因国内均无法正常访问了。”）" class="headerlink" title="注意：执行前修改docker-compose.yml中的内容,取消阿里云的注释，将dockerc hub的源注释。（“自从2023年5月中旬，著名Docker 容器平台： http://hub.docker.com “不知” 何种原因国内均无法正常访问了。”）"></a><strong>注意</strong>：<em><strong>执行前修改docker-compose.yml中的内容,取消阿里云的注释，将dockerc hub的源注释。（“自从2023年5月中旬，著名Docker 容器平台： <a href="https://link.zhihu.com/?target=http://hub.docker.com">http://hub.docker.com</a> “不知” 何种原因国内均无法正常访问了。”）</strong></em></h5><p>本人修改如下：可直接复制</p><h5 id="注意如果mysql端口冲突请修改端口"><a href="#注意如果mysql端口冲突请修改端口" class="headerlink" title="注意如果mysql端口冲突请修改端口"></a><strong>注意如果mysql端口冲突请修改端口</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据库的默认账号和密码仅首次运行时设置有效</span><br><span class="line"># 如果修改了账号密码，记得改数据库和项目连接参数，别只改一处~</span><br><span class="line"># 该配置文件只是给快速启动，测试使用。正式使用，记得务必修改账号密码，以及调整合适的知识库参数，共享内存等。</span><br><span class="line"># 如何无法访问 dockerhub 和 git，可以用阿里云（阿里云没有arm包）</span><br><span class="line"></span><br><span class="line">version: &#x27;3.3&#x27;</span><br><span class="line">services:</span><br><span class="line">  # db</span><br><span class="line">  pg:</span><br><span class="line">    # image: pgvector/pgvector:0.7.0-pg15 # docker hub</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/pgvector:v0.7.0 # 阿里云</span><br><span class="line">    container_name: pg</span><br><span class="line">    restart: always</span><br><span class="line">    ports: # 生产环境建议不要暴露</span><br><span class="line">      - 5432:5432</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    environment:</span><br><span class="line">      # 这里的配置只有首次运行生效。修改后，重启镜像是不会生效的。需要把持久化数据删除再重启，才有效果</span><br><span class="line">      - POSTGRES_USER=username</span><br><span class="line">      - POSTGRES_PASSWORD=password</span><br><span class="line">      - POSTGRES_DB=postgres</span><br><span class="line">    volumes:</span><br><span class="line">      - ./pg/data:/var/lib/postgresql/data</span><br><span class="line">  mongo:</span><br><span class="line">    # image: mongo:5.0.18 # dockerhub</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/mongo:5.0.18 # 阿里云</span><br><span class="line">    # image: mongo:4.4.29 # cpu不支持AVX时候使用</span><br><span class="line">    container_name: mongo</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 27017:27017</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    command: mongod --keyFile /data/mongodb.key --replSet rs0</span><br><span class="line">    environment:</span><br><span class="line">      - MONGO_INITDB_ROOT_USERNAME=myusername</span><br><span class="line">      - MONGO_INITDB_ROOT_PASSWORD=mypassword</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mongo/data:/data/db</span><br><span class="line">    entrypoint:</span><br><span class="line">      - bash</span><br><span class="line">      - -c</span><br><span class="line">      - |</span><br><span class="line">        openssl rand -base64 128 &gt; /data/mongodb.key</span><br><span class="line">        chmod 400 /data/mongodb.key</span><br><span class="line">        chown 999:999 /data/mongodb.key</span><br><span class="line">        echo &#x27;const isInited = rs.status().ok === 1</span><br><span class="line">        if(!isInited)&#123;</span><br><span class="line">          rs.initiate(&#123;</span><br><span class="line">              _id: &quot;rs0&quot;,</span><br><span class="line">              members: [</span><br><span class="line">                  &#123; _id: 0, host: &quot;mongo:27017&quot; &#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;&#x27; &gt; /data/initReplicaSet.js</span><br><span class="line">        # 启动MongoDB服务</span><br><span class="line">        exec docker-entrypoint.sh &quot;$$@&quot; &amp;</span><br><span class="line"></span><br><span class="line">        # 等待MongoDB服务启动</span><br><span class="line">        until mongo -u myusername -p mypassword --authenticationDatabase admin --eval &quot;print(&#x27;waited for connection&#x27;)&quot; &gt; /dev/null 2&gt;&amp;1; do</span><br><span class="line">          echo &quot;Waiting for MongoDB to start...&quot;</span><br><span class="line">          sleep 2</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        # 执行初始化副本集的脚本</span><br><span class="line">        mongo -u myusername -p mypassword --authenticationDatabase admin /data/initReplicaSet.js</span><br><span class="line"></span><br><span class="line">        # 等待docker-entrypoint.sh脚本执行的MongoDB服务进程</span><br><span class="line">        wait $$!</span><br><span class="line"></span><br><span class="line">  # fastgpt</span><br><span class="line">  sandbox:</span><br><span class="line">    container_name: sandbox</span><br><span class="line">    # image: ghcr.io/labring/fastgpt-sandbox:latest # git</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/fastgpt-sandbox:latest # 阿里云</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    restart: always</span><br><span class="line">  fastgpt:</span><br><span class="line">    container_name: fastgpt</span><br><span class="line">    # image: ghcr.io/labring/fastgpt:v4.8.7 # git</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/fastgpt:v4.8.7 # 阿里云</span><br><span class="line">    ports:</span><br><span class="line">      - 3000:3000</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    depends_on:</span><br><span class="line">      - mongo</span><br><span class="line">      - pg</span><br><span class="line">      - sandbox</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      # root 密码，用户名为: root。如果需要修改 root 密码，直接修改这个环境变量，并重启即可。</span><br><span class="line">      - DEFAULT_ROOT_PSW=1234</span><br><span class="line">      # AI模型的API地址哦。务必加 /v1。这里默认填写了OneApi的访问地址。</span><br><span class="line">      - OPENAI_BASE_URL=http://oneapi:3000/v1</span><br><span class="line">      # AI模型的API Key。（这里默认填写了OneAPI的快速默认key，测试通后，务必及时修改）</span><br><span class="line">      - CHAT_API_KEY=sk-fastgpt</span><br><span class="line">      # 数据库最大连接数</span><br><span class="line">      - DB_MAX_LINK=30</span><br><span class="line">      # 登录凭证密钥</span><br><span class="line">      - TOKEN_KEY=any</span><br><span class="line">      # root的密钥，常用于升级时候的初始化请求</span><br><span class="line">      - ROOT_KEY=root_key</span><br><span class="line">      # 文件阅读加密</span><br><span class="line">      - FILE_TOKEN_KEY=filetoken</span><br><span class="line">      # MongoDB 连接参数. 用户名myusername,密码mypassword。</span><br><span class="line">      - MONGODB_URI=mongodb://myusername:mypassword@mongo:27017/fastgpt?authSource=admin</span><br><span class="line">      # pg 连接参数</span><br><span class="line">      - PG_URL=postgresql://username:password@pg:5432/postgres</span><br><span class="line">      # sandbox 地址</span><br><span class="line">      - SANDBOX_URL=http://sandbox:3000</span><br><span class="line">      # 日志等级: debug, info, warn, error</span><br><span class="line">      - LOG_LEVEL=info</span><br><span class="line">      - STORE_LOG_LEVEL=warn</span><br><span class="line">    volumes:</span><br><span class="line">      - ./config.json:/app/data/config.json</span><br><span class="line"></span><br><span class="line">  # oneapi</span><br><span class="line">  mysql:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/mysql:8.0.36 # 阿里云</span><br><span class="line">    # image: mysql:8.0.36</span><br><span class="line">    container_name: mysql</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 3307:3307</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    command: --default-authentication-plugin=mysql_native_password</span><br><span class="line">    environment:</span><br><span class="line">      # 默认root密码，仅首次运行有效</span><br><span class="line">      MYSQL_ROOT_PASSWORD: oneapimmysql</span><br><span class="line">      MYSQL_DATABASE: oneapi</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mysql:/var/lib/mysql</span><br><span class="line">  oneapi:</span><br><span class="line">    container_name: oneapi</span><br><span class="line">    # image: ghcr.io/songquanpeng/one-api:0.6.7</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/one-api:v0.6.6 # 阿里云</span><br><span class="line">    ports:</span><br><span class="line">      - 3001:3000</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      # mysql 连接参数</span><br><span class="line">      - SQL_DSN=root:oneapimmysql@tcp(mysql:3307)/oneapi</span><br><span class="line">      # 登录凭证加密密钥</span><br><span class="line">      - SESSION_SECRET=oneapikey</span><br><span class="line">      # 内存缓存</span><br><span class="line">      - MEMORY_CACHE_ENABLED=true</span><br><span class="line">      # 启动聚合更新，减少数据交互频率</span><br><span class="line">      - BATCH_UPDATE_ENABLED=true</span><br><span class="line">      # 聚合更新时长</span><br><span class="line">      - BATCH_UPDATE_INTERVAL=10</span><br><span class="line">      # 初始化的 root 密钥（建议部署完后更改，否则容易泄露）</span><br><span class="line">      - INITIAL_ROOT_TOKEN=fastgpt</span><br><span class="line">    volumes:</span><br><span class="line">      - ./oneapi:/data</span><br><span class="line">networks:</span><br><span class="line">  fastgpt:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后等待安装完成（由于我电脑已经完成安装，就不演示了）。完成后docker desktop会显示如下信息：</p><p>docker desktop内容：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/f008bc1ec6184d7486774.png"></p><h4 id="2、启动并配置one-api模型："><a href="#2、启动并配置one-api模型：" class="headerlink" title="2、启动并配置one api模型："></a>2、启动并配置one api模型：</h4><p>访问本地部署好的one api：<a href="http://localhost:3001/">http://localhost:3001</a></p><p>初始化的    用户名:root   密码：123456</p><p><img src="https://telegraph-image-a7r.pages.dev/file/fe7886252f4a7e4b418b8.jpg"></p><p>进入后会叫修改密码之类的，完成后点击“渠道”，配置自己的大语言模型。首次登录进来空的，需要自己添加自己的大模型。</p><p>接下来配置刚刚安装的本地大模型llama3呢？</p><p>第一步：先点击 底部“添加新的渠道”，然后选择“Ollama”。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/6dfcbd0794ee22f1dc615.jpg"></p><p>第二步：配置本地llama3大模型</p><p>查询本地ollama中的模型名称，填入模型的时候用到</p><p>完整的配置界面</p><p>完成后测试通过，下图中有时间返回，就说明模型链接成功。</p><p>oneapi还有最后一步，就是将模型加入到自己的令牌中，点击顶部“令牌”导航进入。选默认的令牌信息，并添加ollama3模型。</p><h3 id="三、配置Fastgpt"><a href="#三、配置Fastgpt" class="headerlink" title="三、配置Fastgpt"></a>三、配置Fastgpt</h3><p>接下来配置Fastgpt并使用咱们导入的本地大模型llama3来进行创建chat 或者 agent了。</p><p>1、配置fastgpt的模型<br>进入最开始的fastgpt文件夹。找到config.json,配置llama3模型，位置和代码如下：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/1b04db794f4f6408851a5.jpg"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/c644551376e684c1f5322.jpg"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/9c9a916640758cee34dbd.jpg"></p><p>完成配置后需要重新启动docker  desktop里面的oneapi和fastgpt。</p><p>2、访问fastgpt<br>地址：<a href="http://localhost:3000，默认用户名：root">http://localhost:3000，默认用户名：root</a>  密码：1234</p><p><img src="https://telegraph-image-a7r.pages.dev/file/a1f766c1e1a33cdcbb135.jpg"></p><p><img src="https://telegraph-image-a7r.pages.dev/file/ede806ff36b5627390923.png"></p><p>2、配置应用chat、agent等：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/039d2ac9efeff6c2b54e3.jpg"></p><p>选择一个大模型，配置到你创建的应用中。</p><p>完成模型选择后进行 发布，发布后即可在右变边的聊天框中输入信息，进行对话。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B/">本地安装部署大模型</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">安装教程</category>
      
      
      <comments>https://jhcgnb.cn/posts/f8ffd5a4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>（linux系统环境下）ollama + fastgpt搭建本地私有大模型</title>
      <link>https://jhcgnb.cn/posts/4b0d6ffc/</link>
      <guid>https://jhcgnb.cn/posts/4b0d6ffc/</guid>
      <pubDate>Sat, 27 Jul 2024 15:54:16 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;一、安装VM虚拟机&quot;&gt;&lt;a href=&quot;#一、安装VM虚拟机&quot; class=&quot;headerlink&quot; title=&quot;一、安装VM虚拟机&quot;&gt;&lt;/a&gt;一、安装VM虚拟机&lt;/h3&gt;&lt;h6 id=&quot;1、安装VM&quot;&gt;&lt;a href=&quot;#1、安装VM&quot; class=&quot;head</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="一、安装VM虚拟机"><a href="#一、安装VM虚拟机" class="headerlink" title="一、安装VM虚拟机"></a>一、安装VM虚拟机</h3><h6 id="1、安装VM"><a href="#1、安装VM" class="headerlink" title="1、安装VM"></a>1、安装VM</h6><p>本文提供的15版本：以及CentOS7</p><p>链接: <a href="https://pan.baidu.com/s/15z4_8S1U21v_fQTSO1zZuw?pwd=9hrn">https://pan.baidu.com/s/15z4_8S1U21v_fQTSO1zZuw?pwd=9hrn</a> 提取码: 9hrn</p><p>可参照以下安装方式，不在赘述。</p><p>地址：<a href="https://blog.csdn.net/weixin_74195551/article/details/127288338">https://blog.csdn.net/weixin_74195551/article/details/127288338</a></p><p><img src="https://telegraph-image-a7r.pages.dev/file/fd8b5862b11f68f2d4f2c.png" alt=""></p><h3 id="二、安装ollama"><a href="#二、安装ollama" class="headerlink" title="二、安装ollama"></a>二、安装ollama</h3><h6 id="1、在ollama官网下载找到linux点击复制，然偶在命令行右键复制（注意如果只是虚拟机的话没法直接复制，建议安装一个远程控制终端）"><a href="#1、在ollama官网下载找到linux点击复制，然偶在命令行右键复制（注意如果只是虚拟机的话没法直接复制，建议安装一个远程控制终端）" class="headerlink" title="1、在ollama官网下载找到linux点击复制，然偶在命令行右键复制（注意如果只是虚拟机的话没法直接复制，建议安装一个远程控制终端）"></a>1、在ollama官网下载找到linux点击复制，然偶在命令行右键复制（注意如果只是虚拟机的话没法直接复制，建议安装一个远程控制终端）</h6><p><img src="https://telegraph-image-a7r.pages.dev/file/6ae8a1046c72aacb58f93.jpg" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/ac74837e7fcc5cbcb6459.jpg" alt=""></p><p>等待下载完成，建议早上或者晚上下载（因为本机已经下载所以不在下载）</p><h6 id="2、下载模型"><a href="#2、下载模型" class="headerlink" title="2、下载模型"></a>2、下载模型</h6><p>ollama官网顶部Models，进入模型列表界面。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/34030191822632ccec634.png" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/a4b93b765e4b9cd65d8a7.png" alt=""></p><p>复制完成后进入linux终端，并开始下载模型，将复制的模型 粘贴并回车。</p><p>等待就行</p><p><img src="https://telegraph-image-a7r.pages.dev/file/08ad8a52551e37ebbc123.png" alt=""></p><p>上图为拉取进度，完成后会自动进行编译。</p><p>经过以上步骤本地大模型llama3以安装完成，接下来我们通过docker进行搭建fastgpt。</p><h3 id="三、安装docker"><a href="#三、安装docker" class="headerlink" title="三、安装docker"></a>三、安装docker</h3><p>注：在安装docker之前如果没有安装git建议安装git。具体操作（可以百度，一大堆）：<a href="https://blog.csdn.net/m0_52985087/article/details/136205445">https://blog.csdn.net/m0_52985087/article/details/136205445</a></p><h6 id="1、具体安装："><a href="#1、具体安装：" class="headerlink" title="1、具体安装："></a>1、具体安装：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 Docker</span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br><span class="line">systemctl enable --now docker</span><br><span class="line"># 安装 docker-compose</span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"># 验证安装</span><br><span class="line">docker -v</span><br><span class="line">docker-compose -v</span><br><span class="line"># 如失效，自行百度</span><br></pre></td></tr></table></figure><h3 id="四、部署Fastgpt"><a href="#四、部署Fastgpt" class="headerlink" title="四、部署Fastgpt"></a>四、部署Fastgpt</h3><h6 id="1、开始部署"><a href="#1、开始部署" class="headerlink" title="1、开始部署"></a>1、开始部署</h6><p>Fastgpt开源项目地址：<a href="https://github.com/labring/FastGPT">https://github.com/labring/FastGPT</a></p><p>Fastgpt官方docker模式部署地址：<a href="https://doc.fastgpt.in/docs/development/docker/">https://doc.fastgpt.in/docs/development/docker/</a></p><p>方法如下：按下边步骤在虚拟机终端输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir fastgpt</span><br><span class="line">cd fastgpt</span><br><span class="line">curl -O https://raw.githubusercontent.com/labring/FastGPT/main/projects/app/data/config.json</span><br><span class="line"> </span><br><span class="line"># pgvector 版本(测试推荐，简单快捷)</span><br><span class="line">curl -o docker-compose.yml https://raw.githubusercontent.com/labring/FastGPT/main/files/docker/docker-compose-pgvector.yml</span><br><span class="line"># milvus 版本</span><br><span class="line"># curl -o docker-compose.yml https://raw.githubusercontent.com/labring/FastGPT/main/files/docker/docker-compose-milvus.yml</span><br><span class="line"># zilliz 版本</span><br><span class="line"># curl -o docker-compose.yml https://raw.githubusercontent.com/labring/FastGPT/main/files/docker/docker-compose-zilliz.yml</span><br></pre></td></tr></table></figure><p>最后通过ls查看下载是否成果：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/11fe9a6411d2baa026370.jpg" alt=""></p><h4 id="注意：执行前修改docker-compose-yml中的内容-取消阿里云的注释，将dockerc-hub的源注释。（“自从2023年5月中旬，著名Docker-容器平台：-http-hub-docker-com-“不知”-何种原因国内均无法正常访问了。”）"><a href="#注意：执行前修改docker-compose-yml中的内容-取消阿里云的注释，将dockerc-hub的源注释。（“自从2023年5月中旬，著名Docker-容器平台：-http-hub-docker-com-“不知”-何种原因国内均无法正常访问了。”）" class="headerlink" title="注意：执行前修改docker-compose.yml中的内容,取消阿里云的注释，将dockerc hub的源注释。（“自从2023年5月中旬，著名Docker 容器平台： http://hub.docker.com “不知” 何种原因国内均无法正常访问了。”）"></a><strong>注意</strong>：<strong><em>执行前修改docker-compose.yml中的内容,取消阿里云的注释，将dockerc hub的源注释。（“自从2023年5月中旬，著名Docker 容器平台： <a href="https://link.zhihu.com/?target=http%3A//hub.docker.com">http://hub.docker.com</a> “不知” 何种原因国内均无法正常访问了。”）</em></strong></h4><p>本人修改如下：可直接复制</p><h4 id="注意如果mysql端口冲突请修改端口"><a href="#注意如果mysql端口冲突请修改端口" class="headerlink" title="注意如果mysql端口冲突请修改端口"></a><strong>注意如果mysql端口冲突请修改端口</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据库的默认账号和密码仅首次运行时设置有效</span><br><span class="line"># 如果修改了账号密码，记得改数据库和项目连接参数，别只改一处~</span><br><span class="line"># 该配置文件只是给快速启动，测试使用。正式使用，记得务必修改账号密码，以及调整合适的知识库参数，共享内存等。</span><br><span class="line"># 如何无法访问 dockerhub 和 git，可以用阿里云（阿里云没有arm包）</span><br><span class="line"></span><br><span class="line">version: &#x27;3.3&#x27;</span><br><span class="line">services:</span><br><span class="line">  # db</span><br><span class="line">  pg:</span><br><span class="line">    # image: pgvector/pgvector:0.7.0-pg15 # docker hub</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/pgvector:v0.7.0 # 阿里云</span><br><span class="line">    container_name: pg</span><br><span class="line">    restart: always</span><br><span class="line">    ports: # 生产环境建议不要暴露</span><br><span class="line">      - 5432:5432</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    environment:</span><br><span class="line">      # 这里的配置只有首次运行生效。修改后，重启镜像是不会生效的。需要把持久化数据删除再重启，才有效果</span><br><span class="line">      - POSTGRES_USER=username</span><br><span class="line">      - POSTGRES_PASSWORD=password</span><br><span class="line">      - POSTGRES_DB=postgres</span><br><span class="line">    volumes:</span><br><span class="line">      - ./pg/data:/var/lib/postgresql/data</span><br><span class="line">  mongo:</span><br><span class="line">    # image: mongo:5.0.18 # dockerhub</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/mongo:5.0.18 # 阿里云</span><br><span class="line">    # image: mongo:4.4.29 # cpu不支持AVX时候使用</span><br><span class="line">    container_name: mongo</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 27017:27017</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    command: mongod --keyFile /data/mongodb.key --replSet rs0</span><br><span class="line">    environment:</span><br><span class="line">      - MONGO_INITDB_ROOT_USERNAME=myusername</span><br><span class="line">      - MONGO_INITDB_ROOT_PASSWORD=mypassword</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mongo/data:/data/db</span><br><span class="line">    entrypoint:</span><br><span class="line">      - bash</span><br><span class="line">      - -c</span><br><span class="line">      - |</span><br><span class="line">        openssl rand -base64 128 &gt; /data/mongodb.key</span><br><span class="line">        chmod 400 /data/mongodb.key</span><br><span class="line">        chown 999:999 /data/mongodb.key</span><br><span class="line">        echo &#x27;const isInited = rs.status().ok === 1</span><br><span class="line">        if(!isInited)&#123;</span><br><span class="line">          rs.initiate(&#123;</span><br><span class="line">              _id: &quot;rs0&quot;,</span><br><span class="line">              members: [</span><br><span class="line">                  &#123; _id: 0, host: &quot;mongo:27017&quot; &#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;&#x27; &gt; /data/initReplicaSet.js</span><br><span class="line">        # 启动MongoDB服务</span><br><span class="line">        exec docker-entrypoint.sh &quot;$$@&quot; &amp;</span><br><span class="line"></span><br><span class="line">        # 等待MongoDB服务启动</span><br><span class="line">        until mongo -u myusername -p mypassword --authenticationDatabase admin --eval &quot;print(&#x27;waited for connection&#x27;)&quot; &gt; /dev/null 2&gt;&amp;1; do</span><br><span class="line">          echo &quot;Waiting for MongoDB to start...&quot;</span><br><span class="line">          sleep 2</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        # 执行初始化副本集的脚本</span><br><span class="line">        mongo -u myusername -p mypassword --authenticationDatabase admin /data/initReplicaSet.js</span><br><span class="line"></span><br><span class="line">        # 等待docker-entrypoint.sh脚本执行的MongoDB服务进程</span><br><span class="line">        wait $$!</span><br><span class="line"></span><br><span class="line">  # fastgpt</span><br><span class="line">  sandbox:</span><br><span class="line">    container_name: sandbox</span><br><span class="line">    # image: ghcr.io/labring/fastgpt-sandbox:latest # git</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/fastgpt-sandbox:latest # 阿里云</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    restart: always</span><br><span class="line">  fastgpt:</span><br><span class="line">    container_name: fastgpt</span><br><span class="line">    # image: ghcr.io/labring/fastgpt:v4.8.7 # git</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/fastgpt:v4.8.7 # 阿里云</span><br><span class="line">    ports:</span><br><span class="line">      - 3000:3000</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    depends_on:</span><br><span class="line">      - mongo</span><br><span class="line">      - pg</span><br><span class="line">      - sandbox</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      # root 密码，用户名为: root。如果需要修改 root 密码，直接修改这个环境变量，并重启即可。</span><br><span class="line">      - DEFAULT_ROOT_PSW=1234</span><br><span class="line">      # AI模型的API地址哦。务必加 /v1。这里默认填写了OneApi的访问地址。</span><br><span class="line">      - OPENAI_BASE_URL=http://oneapi:3000/v1</span><br><span class="line">      # AI模型的API Key。（这里默认填写了OneAPI的快速默认key，测试通后，务必及时修改）</span><br><span class="line">      - CHAT_API_KEY=sk-fastgpt</span><br><span class="line">      # 数据库最大连接数</span><br><span class="line">      - DB_MAX_LINK=30</span><br><span class="line">      # 登录凭证密钥</span><br><span class="line">      - TOKEN_KEY=any</span><br><span class="line">      # root的密钥，常用于升级时候的初始化请求</span><br><span class="line">      - ROOT_KEY=root_key</span><br><span class="line">      # 文件阅读加密</span><br><span class="line">      - FILE_TOKEN_KEY=filetoken</span><br><span class="line">      # MongoDB 连接参数. 用户名myusername,密码mypassword。</span><br><span class="line">      - MONGODB_URI=mongodb://myusername:mypassword@mongo:27017/fastgpt?authSource=admin</span><br><span class="line">      # pg 连接参数</span><br><span class="line">      - PG_URL=postgresql://username:password@pg:5432/postgres</span><br><span class="line">      # sandbox 地址</span><br><span class="line">      - SANDBOX_URL=http://sandbox:3000</span><br><span class="line">      # 日志等级: debug, info, warn, error</span><br><span class="line">      - LOG_LEVEL=info</span><br><span class="line">      - STORE_LOG_LEVEL=warn</span><br><span class="line">    volumes:</span><br><span class="line">      - ./config.json:/app/data/config.json</span><br><span class="line"></span><br><span class="line">  # oneapi</span><br><span class="line">  mysql:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/mysql:8.0.36 # 阿里云</span><br><span class="line">    # image: mysql:8.0.36</span><br><span class="line">    container_name: mysql</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 3307:3307</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    command: --default-authentication-plugin=mysql_native_password</span><br><span class="line">    environment:</span><br><span class="line">      # 默认root密码，仅首次运行有效</span><br><span class="line">      MYSQL_ROOT_PASSWORD: oneapimmysql</span><br><span class="line">      MYSQL_DATABASE: oneapi</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mysql:/var/lib/mysql</span><br><span class="line">  oneapi:</span><br><span class="line">    container_name: oneapi</span><br><span class="line">    # image: ghcr.io/songquanpeng/one-api:0.6.7</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/fastgpt/one-api:v0.6.6 # 阿里云</span><br><span class="line">    ports:</span><br><span class="line">      - 3001:3000</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">    networks:</span><br><span class="line">      - fastgpt</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      # mysql 连接参数</span><br><span class="line">      - SQL_DSN=root:oneapimmysql@tcp(mysql:3307)/oneapi</span><br><span class="line">      # 登录凭证加密密钥</span><br><span class="line">      - SESSION_SECRET=oneapikey</span><br><span class="line">      # 内存缓存</span><br><span class="line">      - MEMORY_CACHE_ENABLED=true</span><br><span class="line">      # 启动聚合更新，减少数据交互频率</span><br><span class="line">      - BATCH_UPDATE_ENABLED=true</span><br><span class="line">      # 聚合更新时长</span><br><span class="line">      - BATCH_UPDATE_INTERVAL=10</span><br><span class="line">      # 初始化的 root 密钥（建议部署完后更改，否则容易泄露）</span><br><span class="line">      - INITIAL_ROOT_TOKEN=fastgpt</span><br><span class="line">    volumes:</span><br><span class="line">      - ./oneapi:/data</span><br><span class="line">networks:</span><br><span class="line">  fastgpt:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件创建好并拷贝出git上对应的两个文件内容，并终端进入当前文件夹执行代码：docker-compose up -d</p><p>然后等待安装完成（由于我电脑已经完成安装，就不演示了）。如图11</p><p>安装完成后</p><p><img src="https://telegraph-image-a7r.pages.dev/file/ba86196d20d089126da66.jpg" alt=""></p><h6 id="2、配置本地llama3大模型"><a href="#2、配置本地llama3大模型" class="headerlink" title="2、配置本地llama3大模型"></a>2、配置本地llama3大模型</h6><p>接下来配置Fastgpt并使用咱们导入的本地大模型llama3来进行创建chat 或者 agent了。</p><p><img src="https://telegraph-image-a7r.pages.dev/file/e8fc3eaf137d480ec167d.jpg" alt=""></p><p>如果没有终端工具可直接在虚拟机CentOS终端按如下操作：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/bf4c592d54a04357b223c.jpg" alt=""></p><p>回车进入后：删除所有内容复制本文提供的，或者挨个取消阿里云注释，然后将dokcer Hub源注释</p><p>（注，如果没有安装Vim需要安装Vim编辑器，百度）</p><p><img src="https://telegraph-image-a7r.pages.dev/file/01ab626cc234d8c1f41f7.jpg" alt=""></p><h6 id="3、配置fastgpt的模型"><a href="#3、配置fastgpt的模型" class="headerlink" title="3、配置fastgpt的模型"></a>3、配置fastgpt的模型</h6><p>进入最开始的fastgpt文件夹。找到config.json,配置llama3模型，位置和代码如下：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/1b04db794f4f6408851a5.jpg" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/c644551376e684c1f5322.jpg" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/9c9a916640758cee34dbd.jpg" alt=""></p><p>如果没有终端工具可直接在虚拟机CentOS终端按如下操作：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/2b2b4542d4ca394d51d79.jpg" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/cffa454291973fc8d4114.jpg" alt=""></p><h6 id="4、启动容器"><a href="#4、启动容器" class="headerlink" title="4、启动容器"></a>4、启动容器</h6><p>在 docker-compose.yml 同级目录下执行。请确保docker-compose版本最好在2.17以上，否则可能无法执行自动化命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动容器</span><br><span class="line">docker-compose up -d</span><br><span class="line"># 等待10s，OneAPI第一次总是要重启几次才能连上Mysql</span><br><span class="line">sleep 10</span><br><span class="line"># 重启一次oneapi(由于OneAPI的默认Key有点问题，不重启的话会提示找不到渠道，临时手动重启一次解决，等待作者修复)</span><br><span class="line">docker restart oneapi</span><br></pre></td></tr></table></figure><h6 id="5、访问fastgpt"><a href="#5、访问fastgpt" class="headerlink" title="5、访问fastgpt"></a>5、访问fastgpt</h6><p>在终端CentOS中输入ipconfig或者百度如何查询自己的ip地址</p><p>地址：ip：3000，默认用户名：root  密码：1234</p><p><img src="https://telegraph-image-a7r.pages.dev/file/a1f766c1e1a33cdcbb135.jpg" alt=""></p><p><img src="https://telegraph-image-a7r.pages.dev/file/ede806ff36b5627390923.png" alt=""></p><p>2、配置应用chat、agent等：</p><p><img src="https://telegraph-image-a7r.pages.dev/file/039d2ac9efeff6c2b54e3.jpg" alt=""></p><p>选择一个大模型，配置到你创建的应用中。</p><p>完成模型选择后进行 发布，发布后即可在右变边的聊天框中输入信息，进行对话。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%A4%A7%E6%A8%A1%E5%9E%8B/">本地安装部署大模型</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">安装教程</category>
      
      
      <comments>https://jhcgnb.cn/posts/4b0d6ffc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第八期）</title>
      <link>https://jhcgnb.cn/posts/3cf6ea2d/</link>
      <guid>https://jhcgnb.cn/posts/3cf6ea2d/</guid>
      <pubDate>Tue, 16 Jul 2024 15:50:39 GMT</pubDate>
      
      <description>&lt;p&gt;说在前面的一些话（碎碎念+吐槽）：&lt;/p&gt;
&lt;p&gt;目前这一段时间一直在忙自己的事情，以前以为自己精力旺盛，但是一上班，一开始朝九晚五，其实还不算是朝九晚五，早上八点半，晚上六点。发现每天回到家里以后是真的累，坐在沙发上休息会后洗漱收拾后一晃就九十点了。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>说在前面的一些话（碎碎念+吐槽）：</p><p>目前这一段时间一直在忙自己的事情，以前以为自己精力旺盛，但是一上班，一开始朝九晚五，其实还不算是朝九晚五，早上八点半，晚上六点。发现每天回到家里以后是真的累，坐在沙发上休息会后洗漱收拾后一晃就九十点了。</p><span id="more"></span><p>​哈哈 “钱难挣，屎难吃”，对我这个普通人太难了。如果目前还在学校的即将毕业的一定要考虑号自己想要的，及时早做准备，两手抓。</p><p>因为这些题目都是之前面试通过记忆面试结束后记录、部分通过录音。目前我还在整理，当然有一部分也是我在做项目中出现的问题，今天就先整理一点（偷懒），因为有些答案还需要实地操作才能得出。当然依旧是答案仅供参考。</p><h3 id="1、cesium里面polyline线段有几种表现"><a href="#1、cesium里面polyline线段有几种表现" class="headerlink" title="1、cesium里面polyline线段有几种表现?"></a>1、cesium里面polyline线段有几种表现?</h3><p>在Cesium中，Polyline（线段）可以有以下几种表现类型：</p><ol><li><p><strong>空间直线 (Space Line &#x2F; No Arc)</strong>: 这种类型的线段表现为两点之间的直接连线，无视地球曲率，适用于小范围或在平面上模拟直线效果。在Cesium中，可以通过设置 <code>Cesium.ArcType.NONE</code> 实现。</p></li><li><p><strong>球面线段 (Geodesic Line &#x2F; Great Circle Arc)</strong>: 考虑地球曲率，这种线段在球面上表现为大圆弧，是两点间地球上实际最短路径。使用 <code>Cesium.ArcType.GEODESIC</code> 可以得到这种表现形式。</p></li><li><p><strong>恒向线 (Rhumb Line &#x2F; Loxodrome)</strong>: 恒向线是一种在航行中保持固定方位角的航线，它在地图上表现为与纬线成一定角度的曲线。在Cesium中，通过指定 <code>Cesium.ArcType.RHUMB</code> 可以创建恒向线。</p></li></ol><h3 id="2、Cesium中3DTiles模型如何旋转"><a href="#2、Cesium中3DTiles模型如何旋转" class="headerlink" title="2、Cesium中3DTiles模型如何旋转"></a>2、Cesium中3DTiles模型如何旋转</h3><p>在Cesium中，对3D Tiles模型进行旋转可以通过修改模型的<code>modelMatrix</code>属性来实现。</p><p>首先加载一个3D Tiles模型，然后定义绕X轴旋转的角度，并将其转换为弧度。接着，使用<code>Cesium.Matrix3.fromRotationX</code>创建了一个表示X轴旋转的3x3矩阵，然后通过<code>Cesium.Matrix4.multiplyByMatrix3</code>将此旋转矩阵与模型的当前变换矩阵相乘，得到新的变换矩阵。最后，将这个包含旋转信息的新变换矩阵赋值给<code>tileset.modelMatrix</code>，从而实现了模型的旋转。</p><p>具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 导入Cesium库</span><br><span class="line">const Cesium = require(&#x27;cesium&#x27;);</span><br><span class="line"></span><br><span class="line">// 假设你已经有了一个Cesium Viewer实例</span><br><span class="line">const viewer = new Cesium.Viewer(&#x27;cesiumContainer&#x27;);</span><br><span class="line"></span><br><span class="line">// 加载3D Tiles数据</span><br><span class="line">const tileset = viewer.scene.primitives.add(new Cesium.Cesium3DTileset(&#123;</span><br><span class="line">    url: &#x27;./path/to/your/3d/tiles/tileset.json&#x27;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">// 定义旋转参数，例如围绕X轴旋转的角度（单位：度）</span><br><span class="line">const RotateX = 45; // 旋转45度为例</span><br><span class="line"></span><br><span class="line">// 将角度转换为弧度</span><br><span class="line">const rotationInRadians = Cesium.Math.toRadians(RotateX);</span><br><span class="line"></span><br><span class="line">// 创建一个旋转矩阵，这里以X轴旋转为例</span><br><span class="line">const rotationMatrix = Cesium.Matrix3.fromRotationX(rotationInRadians);</span><br><span class="line"></span><br><span class="line">// 将旋转矩阵转换为4x4的模型变换矩阵</span><br><span class="line">// 假设tileset的初始modelMatrix为单位矩阵或者你有特定的初始变换</span><br><span class="line">let modelMatrix = Cesium.Matrix4.IDENTITY;</span><br><span class="line"></span><br><span class="line">// 应用旋转到现有的modelMatrix</span><br><span class="line">Cesium.Matrix4.multiplyByMatrix3(modelMatrix, rotationMatrix, modelMatrix);</span><br><span class="line"></span><br><span class="line">// 将更新后的modelMatrix应用到tileset上</span><br><span class="line">tileset.modelMatrix = modelMatrix;</span><br></pre></td></tr></table></figure><h3 id="3、cesium提供了三种方式，可以对camera进行操作，这三种方式，有三个共同的参数，heading-pitch-roll-那么，这三个参数分别是什么呢"><a href="#3、cesium提供了三种方式，可以对camera进行操作，这三种方式，有三个共同的参数，heading-pitch-roll-那么，这三个参数分别是什么呢" class="headerlink" title="3、cesium提供了三种方式，可以对camera进行操作，这三种方式，有三个共同的参数，heading,pitch, roll,那么，这三个参数分别是什么呢?"></a>3、cesium提供了三种方式，可以对camera进行操作，这三种方式，有三个共同的参数，heading,pitch, roll,那么，这三个参数分别是什么呢?</h3><p><strong>简单：</strong>这三个参数组合起来可以精确控制camera的方向和视角，常用于设置camera的初始位置、动画过渡（如flyTo操作）或动态调整观察视角。在Cesium的API中，如<code>setView</code>、<code>flyTo</code>、或<code>lookAt</code>方法中，通过<code>orientation</code>对象传递这些参数，通常需要将角度从度转换为弧度使用<code>Cesium.Math.toRadians</code>函数。</p><p><strong>详细</strong>：</p><p>在Cesium中，对camera进行操作时涉及的三个共同参数——heading、pitch、roll，它们是用来描述camera方向的旋转角度，与航空和航海中常用的欧拉角类似。具体来说：</p><ol><li><strong>Heading（偏航角 &#x2F; Yaw）</strong>: Heading代表camera绕垂直方向（通常是指向地心的方向，也就是上方向）旋转的角度，影响camera左右看向的能力。在Cesium中，正值表示向右转，负值表示向左转。</li><li><strong>Pitch（俯仰角 &#x2F; Pitch）</strong>: Pitch代表camera绕横向（水平面的正面到背面）旋转的角度，决定了camera向上或向下看的程度。正值使camera抬头向上看，负值使camera低头向下看。当pitch达到90度时，camera朝向直接向下，达到-90度时则直接向上。</li><li><strong>Roll（翻滚角 &#x2F; Roll）</strong>: Roll描述camera绕其前进方向的轴线旋转，影响camera自身的侧翻。在大多数应用场景中，camera的roll通常被设置为0，以保持camera平台的水平，但在特殊视觉效果或模拟飞行中可能会用到非零的roll值。</li></ol><h3 id="4、看你做过很多项目，你能描述制作cesium-热力图的逻辑步骤过程嘛，就是你如何做一个热力图。"><a href="#4、看你做过很多项目，你能描述制作cesium-热力图的逻辑步骤过程嘛，就是你如何做一个热力图。" class="headerlink" title="4、看你做过很多项目，你能描述制作cesium 热力图的逻辑步骤过程嘛，就是你如何做一个热力图。"></a>4、看你做过很多项目，你能描述制作cesium 热力图的逻辑步骤过程嘛，就是你如何做一个热力图。</h3><p><strong>简单回答</strong>：直接引入开源的Heatmap</p><p><strong>详细</strong>：</p><ul><li><p><strong>使用heatmap.js</strong>：首先，利用<code>heatmap.js</code>生成热力图的canvas图像。你需要将地理位置数据和权重值传递给<code>heatmap.js</code>，生成对应的热力图可视化。</p></li><li><p><strong>转换为Cesium材质</strong>：将<code>heatmap.js</code>生成的canvas转换为Cesium的材质，然后应用于一个覆盖整个地图的Primitive或Entity上。</p></li><li><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 假设你有数据 points = [&#123;lat: ..., lng: ..., value: ...&#125;, ...]</span><br><span class="line">let heatmapInstance = h337.create(&#123;</span><br><span class="line">    container: document.getElementById(&#x27;heatmapContainer&#x27;), // 这里需要替换为实际的容器</span><br><span class="line">    radius: 25,</span><br><span class="line">&#125;);</span><br><span class="line">heatmapInstance.setData(points);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、Cesium中如何实现不同精度DEM合并"><a href="#5、Cesium中如何实现不同精度DEM合并" class="headerlink" title="5、Cesium中如何实现不同精度DEM合并"></a>5、Cesium中如何实现不同精度DEM合并</h3><p><strong>简单：</strong>使用CesiumLab工具可以实现，它提供了图形界面来导入多个DEM文件，自动进行镶嵌、重采样和切片生成。</p><p><strong>详细：</strong></p><p>在Cesium中实现不同精度的DEM（数字高程模型）合并，通常涉及以下几个关键步骤，尤其是在离线状态下处理不同分辨率的DEM数据以保证模型能够正确贴地显示：</p><ol><li><strong>数据准备</strong>：<ul><li>收集所有需要合并的DEM数据，确保它们覆盖相同的地理区域，但可能具有不同的分辨率（如30m、90m等）。</li><li>将DEM数据转换为兼容的格式，如GeoTIFF，这是许多GIS工具和Cesium支持的标准格式。</li></ul></li><li><strong>DEM镶嵌与重采样</strong>：<ul><li>使用GIS工具（如ArcGIS, QGIS, GDAL等）进行镶嵌处理，将多个DEM数据集合并成一个连续的DEM。在这个过程中，可能需要对低分辨率DEM进行重采样以匹配最高分辨率DEM的网格系统和分辨率。</li><li>通过栅格镶嵌（Mosaic）和栅格重采样（Resampling）操作，可以将不同分辨率的DEM统一到相同的空间参考系和分辨率下，确保数据的一致性。</li></ul></li><li><strong>创建切片</strong>：<ul><li>利用工具（CesiumLab等）或自定义脚本，将合并后的高分辨率DEM切割成Cesium所需的瓦片格式（如Terrain Tiles）。</li></ul></li><li><strong>配置Cesium地形服务</strong>：<ul><li>将生成的瓦片数据部署到Web服务器上，并在Cesium应用中配置自定义地形服务。这通常涉及到修改Cesium Viewer或Scene的<code>terrainProvider</code>属性，指向你的自定义地形服务URL。</li></ul></li></ol><h3 id="6、有没有做过cesium添加PBS发布的服务‘"><a href="#6、有没有做过cesium添加PBS发布的服务‘" class="headerlink" title="6、有没有做过cesium添加PBS发布的服务‘"></a>6、有没有做过cesium添加PBS发布的服务‘</h3><p><strong>本人回答</strong>：<strong>没有</strong></p><p><strong>后期查询</strong>：具体操作看该文章：(<a href="https://www.cnblogs.com/GIScore/p/6047736.html">https://www.cnblogs.com/GIScore/p/6047736.html</a>)</p><p>​确保你的PBS服务器正常运行，并且已经成功发布了所需的地图服务。这通常涉及到使用Terrabuilder或其他工具制作MPT（Mobile Package Tile）格式的数据包，并配置PBS以提供这些数据。确认PBS提供的服务接口类型，常见的有WMS、WMTS或自定义的Tile服务。你需要知道服务的URL、图层名称、坐标系等信息，以便在Cesium中正确引用。</p><p>以上一些仅供参考。</p><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://telegraph-image-a7r.pages.dev/file/d22f645eeb107b36a98d0.jpg" alt="qrcode_for_gh_e879ec750214_258"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/3cf6ea2d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第四期）</title>
      <link>https://jhcgnb.cn/posts/fda46c66/</link>
      <guid>https://jhcgnb.cn/posts/fda46c66/</guid>
      <pubDate>Sun, 14 Jul 2024 03:18:33 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WebGIS面试题（第四期）&quot;&gt;&lt;a href=&quot;#WebGIS面试题（第四期）&quot; class=&quot;headerlink&quot; title=&quot;WebGIS面试题（第四期）&quot;&gt;&lt;/a&gt;WebGIS面试题（第四期）&lt;/h2&gt;&lt;p&gt;以下题目为中煤地质下属公司面试题，题目仅为部</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WebGIS面试题（第四期）"><a href="#WebGIS面试题（第四期）" class="headerlink" title="WebGIS面试题（第四期）"></a>WebGIS面试题（第四期）</h2><p>以下题目为中煤地质下属公司面试题，题目仅为部分题目，全部题目在公众号{GISer世界}，答案仅供参考</p><h3 id="1、详细说一下栅格瓦片和矢量瓦片的区别"><a href="#1、详细说一下栅格瓦片和矢量瓦片的区别" class="headerlink" title="1、详细说一下栅格瓦片和矢量瓦片的区别"></a>1、详细说一下栅格瓦片和矢量瓦片的区别</h3><p>栅格瓦片和矢量瓦片是两种不同类型的地图瓦片，它们在数据存储、处理方式和应用方面有一些显著的区别。</p><ol><li><p><strong>栅格瓦片</strong>：</p><ul><li><strong>数据类型</strong>：栅格瓦片使用栅格或像素的方式来表示地图数据。每个瓦片都是一个图像，通常是PNG或JPEG格式，包含了地图上的各种特征和信息。</li><li><strong>数据处理</strong>：栅格瓦片在制作过程中需要预先渲染地图图层，并将地图数据转换为图像。这些图像可以包含地图的各种样式、标注和特定的视觉效果。</li><li><strong>数据大小</strong>：由于栅格瓦片是图像，它们可能会占用较大的存储空间，尤其是在高分辨率下或者需要包含大量细节的地图。</li></ul></li><li><p><strong>矢量瓦片</strong>：</p><ul><li><strong>数据类型</strong>：矢量瓦片使用矢量数据格式来表示地图信息。矢量数据以几何对象（点、线、面等）和属性数据（例如名称、类别）的形式存储。</li><li><strong>数据处理</strong>：与栅格瓦片不同，矢量瓦片在制作过程中不需要事先渲染图像。它们包含了原始地图数据，并通过矢量绘图引擎动态渲染地图图层。</li><li><strong>数据大小</strong>：相比于栅格瓦片，矢量瓦片通常会更小，因为它们只包含地图的几何数据和属性，而不是像素化的图像数据。</li></ul></li><li><p><strong>应用方面</strong>：</p><ul><li><strong>栅格瓦片</strong>通常用于静态地图展示，尤其是对于需要高度定制化或特定样式的地图来说。它们适合于在离线环境中使用，或者在移动设备上显示地图。</li><li><strong>矢量瓦片</strong>更适用于需要动态地图渲染的场景，例如交互式地图应用程序。由于矢量瓦片可以在客户端动态绘制，因此它们可以根据用户的操作实现更灵活的地图交互和样式更改。</li></ul></li></ol><p>总的来说，栅格瓦片适合静态地图展示和高度定制化的场景，而矢量瓦片则更适合交互式地图应用和动态地图渲染的需求。</p><h3 id="2、84坐标上有一堆点，如何将这些点的坐标转为2000坐标"><a href="#2、84坐标上有一堆点，如何将这些点的坐标转为2000坐标" class="headerlink" title="2、84坐标上有一堆点，如何将这些点的坐标转为2000坐标"></a>2、84坐标上有一堆点，如何将这些点的坐标转为2000坐标</h3><p>要将一组点从84坐标系（通常指WGS 84坐标系，一种地理坐标系统）转换为2000坐标系（可能是其他地理坐标系统，比如CGCS2000或WGS 2000），你可以使用一些地理信息系统（GIS）软件或在线工具来完成。以下是一种可能的步骤：</p><ol><li><p><strong>准备数据</strong>：将84坐标系下的所有点的经度和纬度坐标记录下来。</p></li><li><p><strong>选择转换工具</strong>：使用地理信息系统软件（如ArcGIS、QGIS）或在线坐标转换服务。这些工具通常支持从一种地理坐标系转换到另一种。</p></li><li><p><strong>进行转换</strong>：在所选的工具中，选择从WGS 84到目标2000坐标系的转换选项。输入每个点的经度和纬度，并执行转换。</p></li><li><p><strong>验证结果</strong>：转换完成后，验证转换是否正确。确保转换后的坐标与目标2000坐标系的期望值一致。</p></li><li><p><strong>应用转换后的坐标</strong>：将转换后的2000坐标应用到你的应用程序或项目中。</p></li></ol><p>请注意，准确的转换需要使用正确的参数和算法，以确保转换的精度和准确性。</p><p>（[经纬度WGS84地理坐标系转换成CGCS2000坐标系步骤，必备！ - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/411828029#:~:text=1%E3%80%81">https://zhuanlan.zhihu.com/p/411828029#:~:text=1、</a> 将图层从奥维中导出成shp文件， 2、 打开arcgis-arcmap,3、地理处理-arctoolbox-数据管理工具-投影和变换-要素-投影 4、WGS84坐标转换为地理坐标系-world-ITRF2000 5、打开ArcCatalog ，找到上一步中已经成ITRF2000坐标系的shp文件，单击右键-属性，将图层坐标重新定义成GCGS2000地理坐标系)）</p><h3 id="3、Cesium中，飞机漫游初始状态的朝向"><a href="#3、Cesium中，飞机漫游初始状态的朝向" class="headerlink" title="3、Cesium中，飞机漫游初始状态的朝向"></a>3、Cesium中，飞机漫游初始状态的朝向</h3><p>在Cesium中，飞机漫游的初始状态朝向通常由飞行的方向决定。这可以通过设置飞机的位置和方向来实现。Cesium提供了几种方式来定义飞机的初始状态朝向：</p><ol><li><strong>使用方向向量</strong>：可以指定一个方向向量，表示飞机的初始朝向。在Cesium中，这可以通过设置飞机的朝向（heading）、俯仰（pitch）和滚转（roll）来实现。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置飞机的位置</span></span><br><span class="line"><span class="keyword">var</span> position = <span class="title class_">Cesium</span>.<span class="property">Cartesian3</span>.<span class="title function_">fromDegrees</span>(longitude, latitude, altitude);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置飞机的朝向</span></span><br><span class="line"><span class="keyword">var</span> heading = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(headingDegrees); <span class="comment">// 将角度转换为弧度</span></span><br><span class="line"><span class="keyword">var</span> pitch = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(pitchDegrees);</span><br><span class="line"><span class="keyword">var</span> roll = <span class="title class_">Cesium</span>.<span class="property">Math</span>.<span class="title function_">toRadians</span>(rollDegrees);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orientation = <span class="title class_">Cesium</span>.<span class="property">Transforms</span>.<span class="title function_">headingPitchRollQuaternion</span>(position, <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">HeadingPitchRoll</span>(heading, pitch, roll));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建飞机实体</span></span><br><span class="line"><span class="keyword">var</span> airplaneEntity = viewer.<span class="property">entities</span>.<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="attr">position</span>: position,</span><br><span class="line">    <span class="attr">orientation</span>: orientation,</span><br><span class="line">    <span class="attr">model</span>: &#123;</span><br><span class="line">        <span class="attr">uri</span>: <span class="string">&#x27;path/to/airplane.glb&#x27;</span>, <span class="comment">// 飞机模型文件路径</span></span><br><span class="line">        <span class="attr">scale</span>: <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用航迹</strong>：如果已经有飞机的航迹数据，可以直接使用航迹数据中的方向信息来设置飞机的初始朝向。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用航迹数据设置飞机的位置和方向</span></span><br><span class="line"><span class="keyword">var</span> position = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">SampledPositionProperty</span>();</span><br><span class="line"><span class="keyword">var</span> orientation = <span class="keyword">new</span> <span class="title class_">Cesium</span>.<span class="title class_">SampledProperty</span>(<span class="title class_">Cesium</span>.<span class="property">Quaternion</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加航迹数据点</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建飞机实体</span></span><br><span class="line"><span class="keyword">var</span> airplaneEntity = viewer.<span class="property">entities</span>.<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="attr">position</span>: position,</span><br><span class="line">    <span class="attr">orientation</span>: orientation,</span><br><span class="line">    <span class="attr">model</span>: &#123;</span><br><span class="line">        <span class="attr">uri</span>: <span class="string">&#x27;path/to/airplane.glb&#x27;</span>, <span class="comment">// 飞机模型文件路径</span></span><br><span class="line">        <span class="attr">scale</span>: <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>无论选择哪种方式，都可以根据飞机的位置和方向来定义飞机漫游的初始状态朝向。</p><h3 id="4、V-if和v-show的区别"><a href="#4、V-if和v-show的区别" class="headerlink" title="4、V-if和v-show的区别"></a>4、V-if和v-show的区别</h3><p>在Vue.js中，<code>v-if</code>和<code>v-show</code>都是用于条件性地显示或隐藏DOM元素的指令，但它们有一些重要的区别：</p><ol><li><p><strong>渲染方式</strong>：</p><ul><li><code>v-if</code>：当表达式为真（true）时，条件块内的元素才会被创建并插入到DOM中，当表达式为假（false）时，条件块内的元素将被从DOM中移除。因此，<code>v-if</code>在切换时是“真正的”条件渲染，会在DOM中销毁和重新创建元素。</li><li><code>v-show</code>：无论表达式的值是真还是假，元素始终会被渲染到DOM中，只是通过CSS的<code>display</code>属性控制元素的显示与隐藏。因此，<code>v-show</code>不会销毁和重新创建元素，只是简单地在页面上切换元素的显示状态。</li></ul></li><li><p><strong>性能影响</strong>：</p><ul><li><code>v-if</code>：由于在条件不满足时会销毁和重新创建DOM元素，因此适合在需要频繁切换的场景中使用，但会有一定的性能开销。</li><li><code>v-show</code>：由于元素始终保持在DOM中，只是通过CSS进行显示和隐藏，因此在频繁切换时不会有额外的DOM操作，性能开销较小。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li><code>v-if</code>：适用于需要在条件满足时完全渲染新的DOM结构的场景，或者需要在条件不满足时销毁DOM结构以减少内存占用的场景。</li><li><code>v-show</code>：适用于需要频繁切换显示状态，但不需要频繁重新渲染DOM结构的场景。</li></ul></li></ol><p>因此，在选择使用<code>v-if</code>还是<code>v-show</code>时，需要根据具体的情况来考虑渲染性能和页面交互的需求。</p><h3 id="5、解释下深拷贝和浅拷贝"><a href="#5、解释下深拷贝和浅拷贝" class="headerlink" title="5、解释下深拷贝和浅拷贝"></a>5、解释下深拷贝和浅拷贝</h3><p>深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在编程中常见的两种拷贝数据的方法，它们的区别在于拷贝的深度和原始数据结构内部的拷贝方式。</p><h4 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h4><p>浅拷贝是指创建一个新的数据结构，其中包含了原始数据结构中的所有元素的引用（或者是简单的值拷贝）。换句话说，浅拷贝只是复制了原始数据结构的顶层结构，而没有递归地复制内部的元素。</p><p>示例（JavaScript）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> originalArray = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> shallowCopyArray = originalArray.<span class="title function_">slice</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始数组的第二层元素</span></span><br><span class="line">originalArray[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;modified&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalArray); <span class="comment">// 输出：[1, 2, [&#x27;modified&#x27;, 4]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(shallowCopyArray); <span class="comment">// 输出：[1, 2, [&#x27;modified&#x27;, 4]]</span></span><br></pre></td></tr></table></figure><p>在这个示例中，虽然修改了原始数组中的第二层元素，但由于浅拷贝只是复制了引用，因此修改会同时反映在浅拷贝的数组中。</p><h4 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h4><p>深拷贝是指创建一个新的数据结构，并且递归地复制原始数据结构中的所有元素，包括所有的嵌套层级。换句话说，深拷贝会创建一个完全独立于原始数据结构的新结构，修改新结构中的任何元素都不会影响原始数据结构。</p><p>示例（JavaScript，使用Lodash库）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> originalArray = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">let</span> deepCopyArray = _.<span class="title function_">cloneDeep</span>(originalArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原始数组的第二层元素</span></span><br><span class="line">originalArray[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;modified&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalArray); <span class="comment">// 输出：[1, 2, [&#x27;modified&#x27;, 4]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deepCopyArray); <span class="comment">// 输出：[1, 2, [3, 4]]</span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用了Lodash库提供的<code>cloneDeep</code>函数进行深拷贝，因此修改原始数组的第二层元素不会影响到深拷贝的数组。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>浅拷贝只复制了原始数据结构的顶层结构，内部元素仍然是引用，因此修改内部元素会影响到其他拷贝。</li><li>深拷贝递归地复制了原始数据结构的所有层级，创建了一个完全独立的新数据结构，因此修改新数据结构中的任何元素都不会影响到原始数据结构。</li></ul><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/fda46c66/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第三期）</title>
      <link>https://jhcgnb.cn/posts/6d679077/</link>
      <guid>https://jhcgnb.cn/posts/6d679077/</guid>
      <pubDate>Sun, 14 Jul 2024 03:18:21 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WebGIS面试题（第三期）（某公司）上机笔试题&quot;&gt;&lt;a href=&quot;#WebGIS面试题（第三期）（某公司）上机笔试题&quot; class=&quot;headerlink&quot; title=&quot;WebGIS面试题（第三期）（某公司）上机笔试题&quot;&gt;&lt;/a&gt;WebGIS面试题（第三期）</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WebGIS面试题（第三期）（某公司）上机笔试题"><a href="#WebGIS面试题（第三期）（某公司）上机笔试题" class="headerlink" title="WebGIS面试题（第三期）（某公司）上机笔试题"></a>WebGIS面试题（第三期）（某公司）上机笔试题</h2><p>以下题目为南京某公司上机笔试题，题目仅为部分题目，全部题目在公众号{GISer世界}，答案仅供参考，需要电子版在公众号{GISer世界}内回复“面试题3”获取PDF版本！！！</p><h3 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h3><h5 id="1、在java中，ByteMAXVALUE的二进制表示形式是"><a href="#1、在java中，ByteMAXVALUE的二进制表示形式是" class="headerlink" title="1、在java中，ByteMAXVALUE的二进制表示形式是"></a>1、在java中，ByteMAXVALUE的二进制表示形式是</h5><ul><li><p><input disabled="" type="checkbox"> A 11111111</p></li><li><p><input disabled="" type="checkbox"> B 1000000</p></li><li><p><input disabled="" type="checkbox"> C 以上都不对</p></li><li><p><input checked="" disabled="" type="checkbox"> D 01111111</p><p>在Java中，<code>Byte.MAX_VALUE</code> 表示一个 <code>byte</code> 数据类型的最大值，其值为 127。其二进制表示形式是 <code>01111111</code>，因此正确答案是：</p><p>D. 01111111</p></li></ul><h5 id="2、GeOJSON格式，支持的Geomnetry类型不包括以下哪种"><a href="#2、GeOJSON格式，支持的Geomnetry类型不包括以下哪种" class="headerlink" title="2、GeOJSON格式，支持的Geomnetry类型不包括以下哪种"></a>2、GeOJSON格式，支持的Geomnetry类型不包括以下哪种</h5><ul><li><p><input disabled="" type="checkbox"> A LineString</p></li><li><p><input disabled="" type="checkbox"> B Polygon</p></li><li><p><input checked="" disabled="" type="checkbox"> C Polyline</p></li><li><p><input disabled="" type="checkbox"> D Point</p><p>GeoJSON 格式支持的 Geometry 类型包括：</p><p>A. LineString<br>B. Polygon<br>D. Point</p><p>GeoJSON 不支持 “Polyline” 这个类型，因此正确答案是：</p><p>C. Polyline</p></li></ul><h5 id="3、以下代码片段的空白处，应该分别填入什么内容可使得代码片段通过编泽"><a href="#3、以下代码片段的空白处，应该分别填入什么内容可使得代码片段通过编泽" class="headerlink" title="3、以下代码片段的空白处，应该分别填入什么内容可使得代码片段通过编泽?"></a>3、以下代码片段的空白处，应该分别填入什么内容可使得代码片段通过编泽?</h5><p>public vold process()Exception {</p><p>Exception0);</p><p>}</p><ul><li><p><input disabled="" type="checkbox"> A throws    throws new</p></li><li><p><input checked="" disabled="" type="checkbox"> B throws    throw new</p></li><li><p><input disabled="" type="checkbox"> C throw      throws new</p></li><li><p><input disabled="" type="checkbox"> D throw      throw new</p><p>在给定的代码片段中，你需要填入异常处理代码以使其通过编译。正确的选项是 B：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>process</code> 方法声明了它可能抛出一个 <code>Exception</code> 异常，并在方法体中使用 <code>throw</code> 语句抛出了一个新的 <code>Exception</code> 异常。</p></li></ul><h5 id="4、使用SQL语句进行分组检索时，为了去掉不满足条件的分组，应该集么处理"><a href="#4、使用SQL语句进行分组检索时，为了去掉不满足条件的分组，应该集么处理" class="headerlink" title="4、使用SQL语句进行分组检索时，为了去掉不满足条件的分组，应该集么处理?"></a>4、使用SQL语句进行分组检索时，为了去掉不满足条件的分组，应该集么处理?</h5><ul><li><p><input checked="" disabled="" type="checkbox"> A 在GROUPBY后面使用HAVING子句</p></li><li><p><input disabled="" type="checkbox"> B 先使用WHERE子句，再使用HAVING子包</p></li><li><p><input disabled="" type="checkbox"> C 先使用HAVING字句，再使用WHERE子句</p></li><li><p><input disabled="" type="checkbox"> D 使用WHERE子句</p><p>为了去掉不满足条件的分组，你应该在 SQL 查询中使用 HAVING 子句。正确答案是：</p><p>A. 在 GROUP BY 后面使用 HAVING 子句</p><p>HAVING 子句用于筛选已经分组的数据，而 WHERE 子句用于筛选未分组的数据。因此，如果你想在分组后筛选分组，应该使用 HAVING 子句。</p></li></ul><h5 id="5、WMS服务提供的接口中，用于获取地瘤服务图层民张教据地是"><a href="#5、WMS服务提供的接口中，用于获取地瘤服务图层民张教据地是" class="headerlink" title="5、WMS服务提供的接口中，用于获取地瘤服务图层民张教据地是?"></a>5、WMS服务提供的接口中，用于获取地瘤服务图层民张教据地是?</h5><ul><li><p><input checked="" disabled="" type="checkbox"> A GetFeatureInfo</p></li><li><p><input disabled="" type="checkbox"> B GetCapabilities</p></li><li><p><input disabled="" type="checkbox"> C GetLegendGraphic</p></li><li><p><input disabled="" type="checkbox"> D GetMap</p><p>WMS（Web Map Service）服务提供了多个接口来满足不同的地图服务需求。用于获取地图图层的元数据信息的接口是 “GetCapabilities”，而用于获取地图图层上的特定位置信息的接口是 “GetFeatureInfo”。</p><p>所以，答案是：</p><p>A. GetFeatureInfo</p></li></ul><h5 id="6、以下的代码片段，违反了SOLID设计原则中的哪一条原则"><a href="#6、以下的代码片段，违反了SOLID设计原则中的哪一条原则" class="headerlink" title="6、以下的代码片段，违反了SOLID设计原则中的哪一条原则"></a>6、以下的代码片段，违反了SOLID设计原则中的哪一条原则</h5><p>package java sql；<br>public class Date extends java.util Date (@Override<br>public Instant tolnstant() {<br>throw new java.lang.UnsupportedOperationException();</p><p>}</p><p>}</p><ul><li><p><input disabled="" type="checkbox"> A 开放闭合原则</p></li><li><p><input checked="" disabled="" type="checkbox"> B 里氏替换原则</p></li><li><p><input disabled="" type="checkbox"> C 接口隔离原则</p></li><li><p><input disabled="" type="checkbox"> D 单一职责原则</p><p>给定的代码片段违反了里氏替换原则（Liskov Substitution Principle）。</p><p>里氏替换原则要求子类必须能够替换其基类而不改变程序的正确性。在这里，你的代码片段尝试继承 <code>java.util.Date</code> 类并覆盖了 <code>toInstant</code> 方法，但在方法体内抛出了 <code>java.lang.UnsupportedOperationException</code> 异常。这违反了里氏替换原则，因为它改变了基类的预期行为，而不是正确地实现了基类的方法。</p><p>所以，答案是：</p><p>B. 里氏替换原则</p></li></ul><h5 id="7、下列哪个选项是es6中用于声明变量的关键字"><a href="#7、下列哪个选项是es6中用于声明变量的关键字" class="headerlink" title="7、下列哪个选项是es6中用于声明变量的关键字?"></a>7、下列哪个选项是es6中用于声明变量的关键字?</h5><ul><li><p><input disabled="" type="checkbox"> A let</p></li><li><p><input disabled="" type="checkbox"> B const</p></li><li><p><input checked="" disabled="" type="checkbox"> C 以上都对</p></li><li><p><input disabled="" type="checkbox"> D var</p><p>在 ECMAScript 6（ES6）中，用于声明变量的关键字有：</p><p>A. let<br>B. const</p><p>所以正确答案是：</p><p>C. 以上都对</p><p>ES6 引入了 <code>let</code> 和 <code>const</code> 关键字，用于声明变量，相较于之前的 <code>var</code> 关键字，它们提供了更好的变量作用域控制和不可变性选项。</p></li></ul><h5 id="8、”A-cass-should-have-only-one-reason-to-change”。这话常用于SOUD设计原则中的那条原则？"><a href="#8、”A-cass-should-have-only-one-reason-to-change”。这话常用于SOUD设计原则中的那条原则？" class="headerlink" title="8、”A cass should have only one reason to change”。这话常用于SOUD设计原则中的那条原则？"></a>8、”A cass should have only one reason to change”。这话常用于SOUD设计原则中的那条原则？</h5><ul><li><p><input disabled="" type="checkbox"> A 开放闭合原则</p></li><li><p><input disabled="" type="checkbox"> B 依赖倒置原则</p></li><li><p><input disabled="" type="checkbox"> C 接口隔离原则</p></li><li><p><input checked="" disabled="" type="checkbox"> D 单一职责原则</p><p>“A class should have only one reason to change” 这句话通常用于单一职责原则（Single Responsibility Principle）中。因此，正确答案是：</p><p>D. 单一职责原则</p><p>单一职责原则要求一个类应该只有一个引起它变化的原因，即它应该具有单一的责任。</p></li></ul><h5 id="9、下列哪个方法可以将多个数组合并为一个数组"><a href="#9、下列哪个方法可以将多个数组合并为一个数组" class="headerlink" title="9、下列哪个方法可以将多个数组合并为一个数组?"></a>9、下列哪个方法可以将多个数组合并为一个数组?</h5><ul><li><input disabled="" type="checkbox"> A splice</li><li><input disabled="" type="checkbox"> B reverse</li><li><input disabled="" type="checkbox"> C shift</li><li><input checked="" disabled="" type="checkbox"> D concat</li></ul><h5 id="10、以下哪项，不是es6提供的新功能"><a href="#10、以下哪项，不是es6提供的新功能" class="headerlink" title="10、以下哪项，不是es6提供的新功能?"></a>10、以下哪项，不是es6提供的新功能?</h5><ul><li><p><input disabled="" type="checkbox"> A  类</p></li><li><p><input checked="" disabled="" type="checkbox"> B 函数表达式</p></li><li><p><input disabled="" type="checkbox"> C 箭头函数</p></li><li><p><input disabled="" type="checkbox"> D 模块</p><p>方法可以将多个数组合并为一个数组是：</p><p>D. concat</p><p><code>concat</code> 方法用于连接两个或多个数组，并返回一个新数组，其中包含了所有连接的数组元素。这允许你将多个数组合并成一个大数组。</p></li></ul><h5 id="11、关于es6的Class，以下说法错误的是？"><a href="#11、关于es6的Class，以下说法错误的是？" class="headerlink" title="11、关于es6的Class，以下说法错误的是？"></a>11、关于es6的Class，以下说法错误的是？</h5><ul><li><p><input disabled="" type="checkbox"> A 在Class中，通过类的名称来访问静态成员</p></li><li><p><input checked="" disabled="" type="checkbox"> B 在子类的构造方法中，可以在任意位置调用父类的构造函</p></li><li><p><input disabled="" type="checkbox"> C es6的class支持创建访问器属性</p></li><li><p><input disabled="" type="checkbox"> D 可在类中使用static关键字，定义静态成员</p><p>ES6（ECMAScript 2015）引入了许多新功能，但其中的一个选项不是新功能。这个选项是：</p><p>B. 函数表达式</p><p>函数表达式不是 ES6 新引入的功能，它在之前的 JavaScript 版本中就已经存在。ES6 引入了类（A）、箭头函数（C）和模块（D）等新功能，但函数表达式是 JavaScript 的基本功能，不属于 ES6 特定的新增内容。</p></li></ul><h5 id="12、数据库事务ACID特性，其中A表示"><a href="#12、数据库事务ACID特性，其中A表示" class="headerlink" title="12、数据库事务ACID特性，其中A表示?"></a>12、数据库事务ACID特性，其中A表示?</h5><ul><li><p><input disabled="" type="checkbox"> A 隔离性</p></li><li><p><input disabled="" type="checkbox"> B 一致性</p></li><li><p><input disabled="" type="checkbox"> C 持久性</p></li><li><p><input checked="" disabled="" type="checkbox"> D 原子性</p><p>以下说法是错误的：</p><p>B. 在子类的构造方法中，可以在任意位置调用父类的构造函数</p><p>在 ES6 的类中，如果子类的构造函数中希望调用父类的构造函数，应该在构造函数的开头使用 <code>super()</code> 调用父类的构造函数。在构造函数的其他位置调用 <code>super()</code> 会导致错误。</p></li></ul><h3 id="二、简答题："><a href="#二、简答题：" class="headerlink" title="二、简答题："></a>二、简答题：</h3><h5 id="17、有以下几张表学生表Student-sid-varchar-10-sname-varchar-10-，课程表Course-cid-varchar-10-cname-varchar-10-，成绩表SC-sid-varchar-10-cid-varchar-10-scoredecimal-18-1-。其中，sid为学号-sname为学生姓名、cid为课程号cname为课程名、score为考试成绩。请编写SQL语句，查询至少有两个学生考试成绩的课程的课程号和该课程的最高成绩。"><a href="#17、有以下几张表学生表Student-sid-varchar-10-sname-varchar-10-，课程表Course-cid-varchar-10-cname-varchar-10-，成绩表SC-sid-varchar-10-cid-varchar-10-scoredecimal-18-1-。其中，sid为学号-sname为学生姓名、cid为课程号cname为课程名、score为考试成绩。请编写SQL语句，查询至少有两个学生考试成绩的课程的课程号和该课程的最高成绩。" class="headerlink" title="17、有以下几张表学生表Student(sid varchar(10)sname varchar(10))，课程表Course(cid varchar(10),cname varchar(10)，成绩表SC(sid varchar(10)cid varchar(10)scoredecimal(18,1))。其中，sid为学号.sname为学生姓名、cid为课程号cname为课程名、score为考试成绩。请编写SQL语句，查询至少有两个学生考试成绩的课程的课程号和该课程的最高成绩。"></a>17、有以下几张表学生表Student(sid varchar(10)sname varchar(10))，课程表Course(cid varchar(10),cname varchar(10)，成绩表SC(sid varchar(10)cid varchar(10)scoredecimal(18,1))。其中，sid为学号.sname为学生姓名、cid为课程号cname为课程名、score为考试成绩。请编写SQL语句，查询至少有两个学生考试成绩的课程的课程号和该课程的最高成绩。</h5><p>答：</p><p>你可以使用 SQL 查询来找到至少有两个学生考试成绩的课程的课程号和该课程的最高成绩。以下是 SQL 查询的示例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.cid <span class="keyword">AS</span> 课程号, <span class="built_in">MAX</span>(sc.score) <span class="keyword">AS</span> 最高成绩</span><br><span class="line"><span class="keyword">FROM</span> Course c</span><br><span class="line"><span class="keyword">JOIN</span> SC sc <span class="keyword">ON</span> c.cid <span class="operator">=</span> sc.cid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c.cid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(sc.sid) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这个查询会联接课程表（Course）和成绩表（SC），然后按课程号（cid）分组。通过 HAVING 子句，筛选出至少有两个学生考试成绩的课程，并计算每个课程的最高成绩。</p><h5 id="18、Web-Mercator投影以赤道为标准结线以本初子午线为中央经线，两者交汇处为坐标原点。其覆盖的经度范围为-180-1801，已知赤道半径为6378137米，计算Web-Mercator投影x坐标的覆盖范围。"><a href="#18、Web-Mercator投影以赤道为标准结线以本初子午线为中央经线，两者交汇处为坐标原点。其覆盖的经度范围为-180-1801，已知赤道半径为6378137米，计算Web-Mercator投影x坐标的覆盖范围。" class="headerlink" title="18、Web Mercator投影以赤道为标准结线以本初子午线为中央经线，两者交汇处为坐标原点。其覆盖的经度范围为[-180.1801，已知赤道半径为6378137米，计算Web Mercator投影x坐标的覆盖范围。"></a>18、Web Mercator投影以赤道为标准结线以本初子午线为中央经线，两者交汇处为坐标原点。其覆盖的经度范围为[-180.1801，已知赤道半径为6378137米，计算Web Mercator投影x坐标的覆盖范围。</h5><p>Web Mercator 投影将地球表面的经度和纬度坐标映射到平面坐标系，通常使用经度范围从 -180 度到 180 度。在 Web Mercator 投影中，横坐标 (X) 的取值范围通常被规定为从 -20037508.34 米到 20037508.34 米。这个范围是由赤道半径和π（圆周率）以及一些调整因子计算得出的。</p><p>答：</p><p>Web Mercator 投影的 X 坐标范围是由以下公式计算得出：</p><p>X_min &#x3D; -R * π<br>X_max &#x3D; R * π</p><p>其中，R 为赤道半径，即 6378137 米。</p><p>计算 X 坐标范围：</p><p>X_min &#x3D; -6378137 * π ≈ -20037508.34 米<br>X_max &#x3D; 6378137 * π ≈ 20037508.34 米</p><p>所以 Web Mercator 投影的 X 坐标范围为大约 -20037508.34 米到 20037508.34 米。</p><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/6d679077/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第二期）</title>
      <link>https://jhcgnb.cn/posts/7d7ab8ad/</link>
      <guid>https://jhcgnb.cn/posts/7d7ab8ad/</guid>
      <pubDate>Sun, 14 Jul 2024 02:48:42 GMT</pubDate>
      
        
        
      <description>&lt;h4 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h4&gt;&lt;p&gt;近期看到好多小伙伴在寻找WebGIS方面的面试题，正好本人之前也因自己面试分享过一些面试题，秋招目前逐步也快结束了，所以我现</description>
        
      
      
      
      <content:encoded><![CDATA[<h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>近期看到好多小伙伴在寻找WebGIS方面的面试题，正好本人之前也因自己面试分享过一些面试题，秋招目前逐步也快结束了，所以我现在慢慢整理一些包括自己面试以及网上公开的一些我认为有用的面试题，仅供参考，大多面试主要会围绕你自己简历上的项目以及其他进行展开提问，所以说自己的简历才是最重要的。以下内容作为辅助。（本期为第二期分享。第一期分享：<a href="https://blog.csdn.net/weixin_44857463/article/details/133197256">WebGIS面试（中海达）</a>）</p><h4 id="二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）"><a href="#二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）" class="headerlink" title="二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）"></a>二、部分题（这里只是部分面试题，所有面试题请关注公众号：GISer世界）</h4><p>注意webgis面试不一定只问一些GIS相关的，还会提问众多技术相关问题；本人的答案也不一定正确，仅供参考！！！</p><h5 id="1、说一说路由生命周期（也叫导航守卫）"><a href="#1、说一说路由生命周期（也叫导航守卫）" class="headerlink" title="1、说一说路由生命周期（也叫导航守卫）"></a>1、说一说<strong>路由生命周期（也叫导航守卫）</strong></h5><p>路由生命周期，也叫导航守卫，是指在前端Web应用中，控制路由的跳转和导航过程中的一系列事件和钩子函数，用于实现路由的权限控制、数据加载、页面渲染等操作。这些生命周期事件和钩子函数可以根据需要在路由跳转前、跳转时、跳转后执行不同的操作，以确保应用的正确运行和用户体验。</p><p>在Vue.js和Vue Router中，通常有三种导航守卫：</p><ol><li><p><strong>全局前置守卫</strong>：这些守卫会在路由跳转之前触发，允许你执行一些全局的操作，比如权限检查、全局数据加载等。常见的全局前置守卫包括<code>beforeEach</code>。</p></li><li><p><strong>路由独享的守卫</strong>：这些守卫是路由配置中独立于全局守卫的守卫，它们会在特定路由跳转时触发。常见的路由独享守卫包括<code>beforeEnter</code>。</p></li><li><p><strong>全局后置守卫</strong>：这些守卫会在路由跳转完成后触发，允许你执行一些全局的操作，比如页面统计、日志记录等。常见的全局后置守卫包括<code>afterEach</code>。</p></li></ol><p>以下是这些守卫的主要用途和执行时机：</p><ul><li><p><strong>beforeEach</strong>：在路由跳转前执行，通常用于权限控制和全局数据加载。如果在<code>beforeEach</code>中返回<code>false</code>，则路由跳转将被中止。</p></li><li><p><strong>beforeEnter</strong>：在路由配置中独享的守卫，用于特定路由的权限控制和数据加载。</p></li><li><p><strong>afterEach</strong>：在路由跳转完成后执行，通常用于页面切换动画、页面统计等全局操作。</p></li></ul><p>此外，还有一些其他的路由守卫，比如：</p><ul><li><p><strong>beforeResolve</strong>：在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后触发。</p></li><li><p><strong>beforeRouteEnter</strong>：在路由进入前触发，但无法访问组件实例，通常用于异步路由组件。</p></li><li><p><strong>beforeRouteUpdate</strong>：在当前路由改变，但路由参数未改变时触发，用于复用组件。</p></li><li><p><strong>beforeRouteLeave</strong>：在路由离开前触发，通常用于确认离开或取消导航。</p></li></ul><p>这些守卫可以在Vue Router的路由配置中使用，以便更好地控制前端应用的路由导航和行为。根据具体需求，你可以选择使用不同的守卫来实现路由的各种功能，如权限控制、数据加载、页面切换动画等。</p><h5 id="2、关于你在简历中提到的项目-都使用了那些技术栈来进行开发"><a href="#2、关于你在简历中提到的项目-都使用了那些技术栈来进行开发" class="headerlink" title="2、关于你在简历中提到的项目,都使用了那些技术栈来进行开发?"></a>2、关于你在简历中提到的项目,都使用了那些技术栈来进行开发?</h5><p>这个需要结合自己擅长的技术栈以及以及自己的简历。</p><h5 id="3、说一下天地图这个服务是什么格式的类型-具体是怎样加载出来的"><a href="#3、说一下天地图这个服务是什么格式的类型-具体是怎样加载出来的" class="headerlink" title="3、说一下天地图这个服务是什么格式的类型,具体是怎样加载出来的?"></a>3、说一下天地图这个服务是什么格式的类型,具体是怎样加载出来的?</h5><p>“天地图”是中国国家测绘局（National Administration of Surveying, Mapping, and Geoinformation）推出的一套在线地图服务，提供了中国地图的相关数据。这些地图数据通常以标准的Web地图瓦片格式提供，常见的格式包括瓦片图层（Tile Layers）和矢量图层（Vector Layers）。</p><ol><li><p><strong>瓦片图层（Tile Layers）</strong>：这是最常见的地图数据加载方式，天地图提供了标准的瓦片图层，以瓦片（tiles）的形式分割地图，每个瓦片包含一小块地图数据，通常是图片格式，如PNG。你可以通过URL获取这些瓦片并将它们加载到地图上，以显示地图数据。通常，这些URL包括瓦片的x、y坐标和缩放级别，以确保你获取到正确的地图数据。</p></li><li><p><strong>矢量图层（Vector Layers）</strong>：除了瓦片地图，天地图还提供一些矢量地图数据，通常以矢量图层的形式提供。这些数据可以是GeoJSON、KML、WMS等格式。你可以使用前端地图库（如Leaflet、OpenLayers、Mapbox等）加载这些矢量数据，并在地图上绘制要素，如道路、河流、建筑物等。</p></li></ol><p>加载天地图服务通常需要以下步骤：</p><ol><li><p><strong>获取访问权限</strong>：首先，你需要获取访问天地图服务的权限，通常需要在天地图官方网站注册并获取API密钥或访问令牌。</p></li><li><p><strong>选择地图类型</strong>：天地图提供了多种地图类型，如卫星地图、道路地图、地形地图等。根据你的需求选择适合的地图类型。</p></li><li><p><strong>加载地图库</strong>：使用前端地图库，如Leaflet、OpenLayers等，加载地图。你需要在你的网页中引入相应的地图库文件，并创建一个地图容器。</p></li><li><p><strong>添加图层</strong>：根据你的选择，添加天地图的瓦片图层或矢量图层到地图上。如果是瓦片地图，你需要设置天地图瓦片服务的URL，包括x、y坐标和缩放级别。如果是矢量地图，你需要加载相应的矢量数据。</p></li><li><p><strong>设置地图视图</strong>：根据你的需求，设置地图的初始中心点和缩放级别，以及其他交互行为，如缩放、拖动等。</p></li><li><p><strong>处理用户交互</strong>：根据需要，添加交互控件，如放大缩小按钮、信息弹出框等，以增强用户体验。</p></li><li><p><strong>部署到网页</strong>：将配置好的地图应用嵌入到你的网页中，用户可以通过浏览器访问并与地图进行交互。</p></li></ol><p>天地图服务提供了中国地图数据，可以通过瓦片图层或矢量图层的形式加载到前端地图库中，以在网页中显示地图数据并提供交互功能。</p><h5 id="4、在-openLayers-中如何加载-WMTS-服务"><a href="#4、在-openLayers-中如何加载-WMTS-服务" class="headerlink" title="4、在 openLayers 中如何加载 WMTS 服务?"></a>4、在 openLayers 中如何加载 WMTS 服务?</h5><p>在 OpenLayers 中加载WMTS（Web Map Tile Service）服务涉及一系列步骤，包括设置图层、创建地图、配置WMTS图层和视图。<strong>面试可简单回答：</strong></p><ol><li><strong>创建地图容器</strong>：首先，需要在HTML中创建一个<code>&lt;div&gt;</code>容器，用于显示地图。</li><li><strong>初始化地图对象</strong>：使用OpenLayers，初始化一个地图对象，并指定地图的目标容器。</li><li><strong>配置WMTS图层</strong>：设置WMTS图层的参数，包括服务URL、图层名称、图像格式、投影、瓦片网格等。确保提供正确的URL和其他相关信息。</li><li><strong>创建WMTS图层</strong>：基于配置的WMTS源，创建一个WMTS图层。</li><li><strong>将图层添加到地图</strong>：将WMTS图层添加到地图对象中，以便在地图上显示相关地图数据。</li><li><strong>设置地图视图</strong>：配置地图的初始视图，包括中心点和缩放级别。确保投影和坐标系设置正确。</li><li><strong>加载地图</strong>：确保地图被成功加载到页面中，可以添加额外的交互控件，如缩放按钮。</li></ol><p>强调在步骤3中需要注意WMTS图层的配置，包括URL、图层名称、图像格式、投影、瓦片网格等，这些是加载WMTS服务的关键参数。</p><p><strong>以下是详细的介绍，</strong></p><ol><li><strong>引入 OpenLayers 库</strong>：首先，确保你在网页中引入了OpenLayers库的JavaScript文件。你可以从OpenLayers的官方网站下载最新版本的库文件并在HTML中引入。</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/ol@6.10.1/dist/ol.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建地图容器</strong>：在HTML中创建一个用于显示地图的<code>&lt;div&gt;</code>容器。</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;map&quot;</span> <span class="attr">class</span>=<span class="string">&quot;map&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>初始化地图对象</strong>：在JavaScript中，初始化OpenLayers地图对象，并指定地图的目标容器。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> ol.<span class="title class_">Map</span>(&#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="string">&#x27;map&#x27;</span>, <span class="comment">// 这里的&#x27;map&#x27;是你创建的地图容器的ID</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>配置WMTS图层</strong>：设置WMTS图层的相关参数，包括图层来源（source）、投影（projection）、瓦片网格（tile grid）等。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建WMTS源</span></span><br><span class="line"><span class="keyword">var</span> wmtsSource = <span class="keyword">new</span> ol.<span class="property">source</span>.<span class="title function_">WMTS</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://your-wmts-service-url.com&#x27;</span>, <span class="comment">// 替换为你的WMTS服务URL</span></span><br><span class="line">  <span class="attr">layer</span>: <span class="string">&#x27;your-wmts-layer&#x27;</span>, <span class="comment">// 替换为你的WMTS图层名</span></span><br><span class="line">  <span class="attr">format</span>: <span class="string">&#x27;image/png&#x27;</span>, <span class="comment">// 图像格式，根据服务配置</span></span><br><span class="line">  <span class="attr">matrixSet</span>: <span class="string">&#x27;your-matrix-set&#x27;</span>, <span class="comment">// 替换为你的矩阵集</span></span><br><span class="line">  <span class="attr">projection</span>: <span class="string">&#x27;EPSG:4326&#x27;</span>, <span class="comment">// 替换为你的投影</span></span><br><span class="line">  <span class="attr">tileGrid</span>: <span class="keyword">new</span> ol.<span class="property">tilegrid</span>.<span class="title function_">WMTS</span>(&#123;</span><br><span class="line">    <span class="attr">origin</span>: [-<span class="number">180</span>, <span class="number">90</span>], <span class="comment">// 瓦片网格的原点</span></span><br><span class="line">    <span class="attr">resolutions</span>: [<span class="number">0.703125</span>, <span class="number">0.3515625</span>, <span class="number">0.17578125</span>, ...], <span class="comment">// 分辨率数组，根据服务配置</span></span><br><span class="line">    <span class="attr">matrixIds</span>: [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, ...], <span class="comment">// 矩阵ID数组，根据服务配置</span></span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建WMTS图层</span></span><br><span class="line"><span class="keyword">var</span> wmtsLayer = <span class="keyword">new</span> ol.<span class="property">layer</span>.<span class="title class_">Tile</span>(&#123;</span><br><span class="line">  <span class="attr">source</span>: wmtsSource,</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>添加图层到地图</strong>：将创建的WMTS图层添加到地图对象中。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.<span class="title function_">addLayer</span>(wmtsLayer);</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>设置地图视图</strong>：配置地图的初始视图，包括中心点、缩放级别等。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> view = <span class="keyword">new</span> ol.<span class="title class_">View</span>(&#123;</span><br><span class="line">  <span class="attr">center</span>: [<span class="number">0</span>, <span class="number">0</span>], <span class="comment">// 中心点坐标</span></span><br><span class="line">  <span class="attr">zoom</span>: <span class="number">2</span>, <span class="comment">// 初始缩放级别</span></span><br><span class="line">  <span class="attr">projection</span>: <span class="string">&#x27;EPSG:4326&#x27;</span>, <span class="comment">// 投影</span></span><br><span class="line">&#125;);</span><br><span class="line">map.<span class="title function_">setView</span>(view);</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>加载地图</strong>：最后，确保地图被正确加载到页面中。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果有需要，可以添加其他交互控件，如缩放按钮、导航控件等</span></span><br><span class="line">map.<span class="title function_">addControl</span>(<span class="keyword">new</span> ol.<span class="property">control</span>.<span class="title class_">Zoom</span>());</span><br></pre></td></tr></table></figure><p>通过上述步骤，可以成功加载WMTS服务并显示在OpenLayers地图中。记得替换示例代码中的URL、图层名称、矩阵集、分辨率、矩阵ID等参数，以适应的具体WMTS服务。</p><h5 id="5、刚才有提到-WMS-可以具体说一下-WMS和-WMTS-两者的区别吗"><a href="#5、刚才有提到-WMS-可以具体说一下-WMS和-WMTS-两者的区别吗" class="headerlink" title="5、刚才有提到 WMS,可以具体说一下 WMS和 WMTS 两者的区别吗?"></a>5、刚才有提到 WMS,可以具体说一下 WMS和 WMTS 两者的区别吗?</h5><p>当涉及到地理信息系统（GIS）和地图服务时，WMS（Web Map Service）和WMTS（Web Map Tile Service）是两种不同的标准，它们有一些重要的区别：</p><ol><li><p><strong>数据传输方式</strong>：</p><ul><li><strong>WMS</strong>：WMS是基于请求-响应模式的。每次请求地图数据时，WMS服务器会动态生成地图图像，然后将整个地图图像作为响应传送给客户端。这意味着每次请求都生成新的地图图像，适用于动态数据和图层的情况，但可能会导致性能较差。</li><li><strong>WMTS</strong>：WMTS采用了瓦片式数据传输，地图被分成小块瓦片，每个瓦片都是一个预先生成的图像。这些瓦片在服务器端预先渲染，客户端通过直接请求这些瓦片来加载地图数据。这种方式通常更高效，尤其适用于静态地图数据，因为无需在每次请求时生成新的地图图像。</li></ul></li><li><p><strong>性能</strong>：</p><ul><li><strong>WMS</strong>：由于动态生成地图图像，WMS可能在性能上不如WMTS，尤其是在大规模地图和高并发请求的情况下。</li><li><strong>WMTS</strong>：WMTS的性能通常更好，因为瓦片数据是预先生成的，服务器只需提供瓦片即可，不需要在每次请求时进行渲染。</li></ul></li><li><p><strong>缓存</strong>：</p><ul><li><strong>WMS</strong>：WMS通常需要客户端自行管理图像的缓存，因为每次请求都会生成新的图像。这可能导致客户端性能问题，因为需要存储大量的图像数据。</li><li><strong>WMTS</strong>：WMTS的瓦片式数据天然适合缓存，因为瓦片是静态的，可以被有效地缓存。客户端可以从缓存中加载瓦片，减轻了服务器和客户端的负担。</li></ul></li><li><p><strong>灵活性</strong>：</p><ul><li><strong>WMS</strong>：WMS提供更多的灵活性，因为它可以在每次请求时动态生成地图图像，允许对地图进行实时操作和渲染。适用于需要动态数据的应用场景。</li><li><strong>WMTS</strong>：WMTS提供了稳定和可预测的地图显示，但通常不支持实时数据更新或动态渲染，因为瓦片是静态的。</li></ul></li></ol><p>总结来说，WMS和WMTS都是用于在Web上提供地图数据的标准，但它们的工作方式和适用场景有所不同。选择哪种标准取决于你的具体需求。如果需要实时渲染和动态数据，WMS可能更合适。如果需要更高的性能和稳定性，以及静态地图数据，WMTS可能是更好的选择。</p><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/7d7ab8ad/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WebGIS面试题（第七期）</title>
      <link>https://jhcgnb.cn/posts/c917cf39/</link>
      <guid>https://jhcgnb.cn/posts/c917cf39/</guid>
      <pubDate>Fri, 14 Jun 2024 03:22:42 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WebGIS面试题（第七期）&quot;&gt;&lt;a href=&quot;#WebGIS面试题（第七期）&quot; class=&quot;headerlink&quot; title=&quot;WebGIS面试题（第七期）&quot;&gt;&lt;/a&gt;WebGIS面试题（第七期）&lt;/h2&gt;&lt;p&gt;以下题目仅为部分题目，全部题目在公众号&lt;/p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WebGIS面试题（第七期）"><a href="#WebGIS面试题（第七期）" class="headerlink" title="WebGIS面试题（第七期）"></a>WebGIS面试题（第七期）</h2><p>以下题目仅为部分题目，全部题目在公众号</p><blockquote><p><strong>{GISer世界}</strong></p></blockquote><p>，答案仅供参考!!!<br>集中则整理了相关有难度的问题，因为我自己回答得一般，所以有些答案参来自网络，仅供参考！！！<br>@[toc]</p><h3 id="1、前端实现geoJson与wkt格式互转"><a href="#1、前端实现geoJson与wkt格式互转" class="headerlink" title="1、前端实现geoJson与wkt格式互转"></a>1、前端实现geoJson与wkt格式互转</h3><p>GeoJSON 和 WKT（Well-Known Text）都是用于表示地理空间数据的格式。GeoJSON 是一种基于 JSON 的格式，广泛用于 Web 映射库，而 WKT 是一种纯文本的地理空间数据表示，遵循 OpenGIS 标准。</p><p>在前端实现 GeoJSON 与 WKT 格式的互转，可以通过以下步骤：</p><h3 id="将-GeoJSON-转换为-WKT"><a href="#将-GeoJSON-转换为-WKT" class="headerlink" title="将 GeoJSON 转换为 WKT"></a>将 GeoJSON 转换为 WKT</h3><ol><li><p><strong>解析 GeoJSON 对象</strong>：首先，需要解析 GeoJSON 对象的结构，GeoJSON 对象通常具有 <code>type</code> 和 <code>coordinates</code> 属性。</p></li><li><p><strong>构建 WKT 字符串</strong>：根据 GeoJSON 对象的类型（如 Point, LineString, Polygon 等），构建对应的 WKT 字符串。WKT 字符串以地理要素类型开头，后跟坐标对。</p></li><li><p><strong>处理子要素</strong>：对于如 <code>MultiPoint</code>, <code>MultiLineString</code>, <code>MultiPolygon</code> 或 <code>GeometryCollection</code> 这类包含多个子要素的 GeoJSON 对象，需要迭代这些子要素并为每个子要素构建 WKT 字符串。</p></li><li><p><strong>示例代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">geojsonToWKT</span>(<span class="params">geojson</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> wkt = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据 GeoJSON 对象的类型构建 WKT</span></span><br><span class="line">  <span class="keyword">switch</span> (geojson.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Point&#x27;</span>:</span><br><span class="line">      wkt = <span class="string">`POINT(<span class="subst">$&#123;geojson.coordinates[<span class="number">0</span>]&#125;</span> <span class="subst">$&#123;geojson.coordinates[<span class="number">1</span>]&#125;</span>)`</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ... 处理其他类型的 case</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> wkt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="将-WKT-转换为-GeoJSON"><a href="#将-WKT-转换为-GeoJSON" class="headerlink" title="将 WKT 转换为 GeoJSON"></a>将 WKT 转换为 GeoJSON</h3><ol><li><p><strong>解析 WKT 字符串</strong>：解析 WKT 字符串以确定地理要素的类型和坐标。</p></li><li><p><strong>构建 GeoJSON 对象</strong>：根据解析出的类型和坐标构建 GeoJSON 对象。GeoJSON 对象需要 <code>type</code> 和 <code>coordinates</code> 属性。</p></li><li><p><strong>处理特殊情况</strong>：对于多要素类型的 WKT（如 <code>MULTIPOINT</code>, <code>MULTILINESTRING</code>, <code>MULTIPOLYGON</code> 等），需要将坐标数组分割成多个单独的要素。</p></li><li><p><strong>示例代码</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wktToGeojson</span>(<span class="params">wkt</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> geojson = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用正则表达式或字符串方法解析 WKT 字符串</span></span><br><span class="line">  <span class="comment">// 例如，提取 Point 的坐标</span></span><br><span class="line">  <span class="keyword">const</span> matches = wkt.<span class="title function_">match</span>(<span class="regexp">/POINT\(([^)]+)\)/</span>);</span><br><span class="line">  <span class="keyword">if</span> (matches) &#123;</span><br><span class="line">    <span class="keyword">const</span> coords = matches[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line">    geojson = &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;Point&#x27;</span>,</span><br><span class="line">      <span class="attr">coordinates</span>: [coords[<span class="number">0</span>], coords[<span class="number">1</span>]]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 处理其他类型的解析</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> geojson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2、有没有现成的-JavaScript-库可以方便地进行-GeoJSON-与-WKT-格式的转换？"><a href="#2、有没有现成的-JavaScript-库可以方便地进行-GeoJSON-与-WKT-格式的转换？" class="headerlink" title="2、有没有现成的 JavaScript 库可以方便地进行 GeoJSON 与 WKT 格式的转换？"></a>2、有没有现成的 JavaScript 库可以方便地进行 GeoJSON 与 WKT 格式的转换？</h3><p>是的，存在多个 JavaScript 库可以方便地在 GeoJSON 和 WKT 格式之间进行转换。以下是一些流行的库：</p><ol><li><p>**<code>geojson-to-wkt</code> 和 <code>wkt-to-geojson</code>**：</p><ul><li>这两个库分别用于将 GeoJSON 转换为 WKT 和将 WKT 转换为 GeoJSON。它们易于使用，并且可以在 Node.js 环境或浏览器中运行。</li></ul><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装 geojson-to-wkt</span></span><br><span class="line">npm install geojson-to-wkt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装 wkt-to-geojson</span></span><br><span class="line">npm install wkt-to-geojson</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geojsonToWkt = <span class="built_in">require</span>(<span class="string">&#x27;geojson-to-wkt&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> wktToGeojson = <span class="built_in">require</span>(<span class="string">&#x27;wkt-to-geojson&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geojson = &#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Point&quot;</span>,</span><br><span class="line">  <span class="string">&quot;coordinates&quot;</span>: [<span class="number">102.0</span>, <span class="number">0.5</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wkt = <span class="title function_">geojsonToWkt</span>(geojson); <span class="comment">// &quot;POINT (102 0.5)&quot;</span></span><br><span class="line"><span class="keyword">const</span> convertedGeojson = <span class="title function_">wktToGeojson</span>(wkt); <span class="comment">// GeoJSON object</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>terraformer</code> 和 <code>terraformer-wkt-parser</code>**：</p><ul><li><code>terraformer</code> 是一个用于处理 GeoJSON 的 JavaScript 库，而 <code>terraformer-wkt-parser</code> 插件提供了将 WKT 字符串转换为 GeoJSON 的功能。</li></ul><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装 terraformer 和 terraformer-wkt-parser</span></span><br><span class="line">npm install terraformer terraformer-wkt-parser</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Terraformer</span> = <span class="built_in">require</span>(<span class="string">&#x27;terraformer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">WKT</span> = <span class="built_in">require</span>(<span class="string">&#x27;terraformer-wkt-parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wkt = <span class="string">&#x27;POINT (102 0.5)&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> geojson = <span class="variable constant_">WKT</span>.<span class="title function_">parse</span>(wkt); <span class="comment">// Terraformer.Point object</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>@mapbox/geojson-rewind</code>**：</p><ul><li>虽然这个库主要用于处理 GeoJSON 的坐标顺序，但它也可以用于将 GeoJSON 转换为 WKT。</li></ul><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装 @mapbox/geojson-rewind</span></span><br><span class="line">npm install @mapbox/geojson-rewind</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geojsonRewire = <span class="built_in">require</span>(<span class="string">&#x27;@mapbox/geojson-rewind&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geojson = &#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Point&quot;</span>,</span><br><span class="line">  <span class="string">&quot;coordinates&quot;</span>: [<span class="number">102.0</span>, <span class="number">0.5</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wkt = geojsonRewire.<span class="title function_">wkt</span>(geojson); <span class="comment">// &quot;POINT (102 0.5)&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>togeojson</code>**：</p><ul><li>这个库可以将多种地理空间数据格式转换为 GeoJSON，包括 WKT。</li></ul><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装 togeojson</span></span><br><span class="line">npm install togeojson</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toGeoJSON = <span class="built_in">require</span>(<span class="string">&#x27;togeojson&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wkt = <span class="string">&#x27;POINT (102 0.5)&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> geojson = toGeoJSON.<span class="title function_">wkt</span>(wkt); <span class="comment">// GeoJSON object</span></span><br></pre></td></tr></table></figure></li></ol><p>使用这些库，你可以在前端应用程序中轻松实现 GeoJSON 和 WKT 格式的转换，而无需从头开始编写转换逻辑。在使用任何库之前，请确保查看其文档以了解如何正确地集成和使用。</p><h3 id="2、你能谈谈OGR-OGC标准，和WMS-WFS在GeoTools中的作用吗？"><a href="#2、你能谈谈OGR-OGC标准，和WMS-WFS在GeoTools中的作用吗？" class="headerlink" title="2、你能谈谈OGR, OGC标准，和WMS&#x2F;WFS在GeoTools中的作用吗？"></a>2、你能谈谈OGR, OGC标准，和WMS&#x2F;WFS在GeoTools中的作用吗？</h3><p>OGR增强了GeoTools处理多种数据格式的能力，而遵循OGC标准，特别是WMS和WFS，使得GeoTools能够在分布式、网络化的环境中无缝地与其他GIS系统和服务协同工作，无论是作为数据提供者还是消费者，都极大地提升了其在地理信息处理和共享方面的灵活性和兼容性。</p><h3 id="3、解释数据投影和坐标参考系统（CRS）在GeoTools中的处理方式。"><a href="#3、解释数据投影和坐标参考系统（CRS）在GeoTools中的处理方式。" class="headerlink" title="3、解释数据投影和坐标参考系统（CRS）在GeoTools中的处理方式。"></a>3、解释数据投影和坐标参考系统（CRS）在GeoTools中的处理方式。</h3><p>在GeoTools中，数据投影和坐标参考系统（CRS）的处理是基于Open Geospatial Consortium (OGC) 和 International Organization for Standardization (ISO) 的标准，这些标准确保了地理空间数据的准确表达和互操作性。</p><p><strong>详细：</strong></p><p><strong>坐标参考系统（CRS）</strong>：<br>坐标参考系统定义了如何在地球表面或三维空间中测量位置。它包括地理坐标系（如WGS84，基于经纬度）和投影坐标系（如UTM，用于将地球曲面转换为平面）。在GeoTools中，CRS的处理主要通过<code>org.geotools.referencing</code>包中的类来完成，特别是<code>CoordinateReferenceSystem</code>接口及其实现类。GeoTools支持通过EPSG代码、WKT（Well-Known Text）字符串或者PRJ文件等方式来定义和解析CRS。</p><p>要获取或设置一个要素（Feature）或图层（Layer）的CRS，可以使用如下操作：</p><ul><li>获取CRS：通过要素的特征类型（FeatureType）或数据存储（DataStore）的元数据。</li><li>设置CRS：在创建或修改数据时指定CRS。</li></ul><p><strong>数据投影</strong>：<br>数据投影是指将地球表面的三维曲面数据转换到二维平面上的过程，以便于可视化、分析和存储。在GeoTools中，数据投影的转换通常利用<code>MathTransform</code>对象来完成，这个对象定义了从一个CRS到另一个CRS的数学变换关系。</p><p>进行投影转换时，可以按照以下步骤操作：</p><ol><li><strong>获取源CRS和目标CRS</strong>：使用<code>CRS.decode(&quot;EPSG:...&quot;)</code>或类似方法获取CRS实例。</li><li><strong>创建变换</strong>：通过<code>CoordinateOperationFactory</code>创建一个从源CRS到目标CRS的变换。</li><li><strong>转换几何体</strong>：使用变换对几何体进行投影转换，例如通过<code>JTS.transform()</code>方法。</li></ol><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载Shapefile并获取其CRS</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path/to/shapefile.shp&quot;</span>);</span><br><span class="line">Map&lt;String, Object&gt; params = Collections.singletonMap(<span class="string">&quot;url&quot;</span>, file.toURI().toURL());</span><br><span class="line"><span class="type">ShapefileDataStore</span> <span class="variable">dataStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapefileDataStore</span>(params);</span><br><span class="line"><span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> dataStore.getTypeNames()[<span class="number">0</span>];</span><br><span class="line"><span class="type">SimpleFeatureSource</span> <span class="variable">featureSource</span> <span class="operator">=</span> dataStore.getFeatureSource(typeName);</span><br><span class="line"><span class="type">CoordinateReferenceSystem</span> <span class="variable">crs</span> <span class="operator">=</span> featureSource.getSchema().getCoordinateReferenceSystem();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个新的投影（例如，从WGS84转换到UTM Zone 32N）</span></span><br><span class="line"><span class="type">CoordinateReferenceSystem</span> <span class="variable">targetCRS</span> <span class="operator">=</span> CRS.decode(<span class="string">&quot;EPSG:32632&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建变换</span></span><br><span class="line"><span class="type">MathTransform</span> <span class="variable">transform</span> <span class="operator">=</span> CRS.findMathTransform(crs, targetCRS, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们有一个要素集合，这里简化为单个要素处理</span></span><br><span class="line">FeatureCollection&lt;SimpleFeatureType, SimpleFeature&gt; features = featureSource.getFeatures();</span><br><span class="line"><span class="type">SimpleFeature</span> <span class="variable">feature</span> <span class="operator">=</span> features.features().next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对要素的几何体进行投影转换</span></span><br><span class="line"><span class="type">Geometry</span> <span class="variable">geometry</span> <span class="operator">=</span> (Geometry) feature.getDefaultGeometry();</span><br><span class="line"><span class="type">Geometry</span> <span class="variable">transformedGeometry</span> <span class="operator">=</span> JTS.transform(geometry, transform);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出或进一步处理transformedGeometry</span></span><br></pre></td></tr></table></figure><p>总之，GeoTools提供了强大的工具集来处理CRS和数据投影，使得开发者能够轻松地读取、转换和显示具有不同坐标系统的地理空间数据。</p><h3 id="4、在一个项目中，你是如何解决GeoTools与其他库或系统（如PostGIS）集成时遇到的问题的？"><a href="#4、在一个项目中，你是如何解决GeoTools与其他库或系统（如PostGIS）集成时遇到的问题的？" class="headerlink" title="4、在一个项目中，你是如何解决GeoTools与其他库或系统（如PostGIS）集成时遇到的问题的？"></a>4、在一个项目中，你是如何解决GeoTools与其他库或系统（如PostGIS）集成时遇到的问题的？</h3><p>在项目中集成GeoTools与其他库或系统，如PostGIS，可能会遇到诸如数据格式不匹配、版本兼容性问题、性能瓶颈或配置错误等挑战。以下是解决这类问题的一些策略：</p><ol><li><strong>确保版本兼容性</strong>：<ul><li>在开始集成之前，检查GeoTools、PostGIS以及任何其他依赖库的版本兼容性。使用官方文档或社区论坛确认推荐的组合，避免因版本不匹配导致的错误。</li></ul></li><li><strong>数据格式和投影一致性</strong>：<ul><li>确保GeoTools读取或写入PostGIS的数据时，CRS（坐标参考系统）是一致的。如果不一致，使用正确的投影转换逻辑，比如通过<code>MathTransform</code>进行转换。</li><li>检查数据表结构是否符合预期，特别是在字段类型、长度和约束方面。</li></ul></li><li><strong>配置连接参数</strong>：<ul><li>正确配置GeoTools连接到PostGIS的数据源参数，包括数据库URL、用户名、密码等。使用<code>DataStoreFinder</code>时，确保参数正确无误。</li></ul></li><li><strong>使用事务管理提高性能</strong>：<ul><li>在执行大量插入或更新操作时，利用事务管理来提升效率。GeoTools支持通过<code>DataStore</code>的事务特性来批量处理操作，减少数据库交互次数。</li></ul></li><li><strong>日志和错误追踪</strong>：<ul><li>开启详细日志记录，尤其是调试级别日志，可以帮助快速定位问题。分析日志中的错误消息或警告，根据提示进行排查。</li></ul></li><li><strong>利用社区资源</strong>：<ul><li>当遇到问题时，首先查阅GeoTools和PostGIS的官方文档、API参考和教程。</li><li>参与GeoTools和PostGIS的社区论坛或邮件列表，如Stack Overflow、GIS Stack Exchange或项目GitHub页面，提问或搜索已有的解决方案。</li></ul></li><li><strong>编写测试用例</strong>：<ul><li>为关键的集成部分编写单元测试或集成测试，确保各组件协同工作正常。这有助于早期发现问题并验证修复方案的有效性。</li></ul></li><li><strong>性能调优</strong>：<ul><li>监控应用性能，识别瓶颈。可能需要调整GeoTools的缓冲区大小、并发策略或查询优化等。同时，考虑PostGIS侧的索引优化、查询优化策略。</li></ul></li><li><strong>备份与恢复计划</strong>：<ul><li>在进行大规模数据操作前，确保有数据备份计划，以防不测。了解如何从错误中恢复，比如使用事务回滚或数据恢复脚本。</li></ul></li></ol><h3 id="5、使用PostGIS处理空间数据的优缺点是什么？"><a href="#5、使用PostGIS处理空间数据的优缺点是什么？" class="headerlink" title="5、使用PostGIS处理空间数据的优缺点是什么？"></a>5、使用PostGIS处理空间数据的优缺点是什么？</h3><p>PostGIS是一个功能强大的空间数据库扩展，适用于需要进行复杂空间分析和处理大量空间数据的应用场景。</p><p><strong>详细：</strong></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li><strong>功能丰富</strong>：PostGIS提供了广泛的空间数据类型、函数和操作符，支持复杂的空间查询和分析。</li><li><strong>开放标准</strong>：PostGIS遵循OGC（开放地理空间联盟）标准，确保了与其他GIS软件的兼容性。</li><li><strong>开源</strong>：作为一个开源项目，PostGIS允许免费使用和修改，有助于降低成本和促进社区创新。</li><li><strong>SQL集成</strong>：PostGIS与SQL紧密集成，可以使用SQL查询和操作空间数据，便于开发者使用熟悉的数据库技能。</li><li><strong>性能</strong>：通过使用空间索引（如GIST）和高效的查询优化，PostGIS能够处理大型空间数据集。</li><li><strong>扩展性</strong>：PostGIS作为PostgreSQL的扩展，可以利用PostgreSQL的稳定性和强大的事务处理能力。</li><li><strong>社区支持</strong>：拥有活跃的开发社区和用户群体，提供广泛的文档、教程和工具。</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li><strong>学习曲线</strong>：对于新手来说，PostGIS的复杂性和SQL的空间函数可能需要一段时间来学习和掌握。</li><li><strong>性能考量</strong>：虽然PostGIS性能良好，但在处理未优化或未索引的大型数据集时，性能可能会成为瓶颈。</li><li><strong>资源消耗</strong>：空间数据类型和操作可能比传统的关系数据库操作更消耗资源。</li><li><strong>安装配置</strong>：对于不熟悉PostgreSQL的用户，安装和配置PostGIS可能需要额外的时间和精力。</li><li><strong>版本兼容性</strong>：PostGIS与PostgreSQL的特定版本紧密相关，升级可能需要考虑兼容性问题。</li><li><strong>数据完整性</strong>：在多用户编辑环境中，需要额外的机制来维护数据的完整性和一致性。</li><li><strong>地理数据的复杂性</strong>：处理复杂的地理数据（如拓扑关系）可能需要更高级的知识和经验。</li><li><strong>系统维护</strong>：为了保持PostGIS的性能和稳定性，需要定期进行数据库维护，如VACUUM和ANALYZE操作。<br>以上一些仅供参考。</li></ol><h2 id="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"><a href="#此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】-欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。" class="headerlink" title="此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。"></a><strong>此处只展示了部分面试题，剩余面试题请移步公众号【GISer世界】 欢迎您关注我的原创公众号【GISer世界】，不定期分享资源以及GIS面试题，本期分享到这里就结束了。</strong></h2><p><img src="https://img-blog.csdnimg.cn/c13ea291a25044f5a89652703203da48.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1f36650f114348159a24e66823eb8fe7.jpeg" alt="请添加图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</category>
      
      
      <category domain="https://jhcgnb.cn/tags/WebGIS%E9%9D%A2%E8%AF%95%E9%A2%98/">WebGIS面试题</category>
      
      
      <comments>https://jhcgnb.cn/posts/c917cf39/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
