<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>纸飞机的旅行</title>
    <link>https://jhcgnb.cn/</link>
    
    <atom:link href="https://jhcgnb.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>选择有时候比努力更重要</description>
    <pubDate>Mon, 14 Aug 2023 12:42:54 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>11.性能优化</title>
      <link>https://jhcgnb.cn/posts/5a9e107b/</link>
      <guid>https://jhcgnb.cn/posts/5a9e107b/</guid>
      <pubDate>Wed, 18 Oct 2023 13:51:52 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;雅虎14条Web性能优化规则&quot;&gt;&lt;a href=&quot;#雅虎14条Web性能优化规则&quot; class=&quot;headerlink&quot; title=&quot;雅虎14条Web性能优化规则&quot;&gt;&lt;/a&gt;雅虎14条Web性能优化规则&lt;/h1&gt;&lt;h2 id=&quot;法则-1-减少-HTTP-请求次数</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="雅虎14条Web性能优化规则"><a href="#雅虎14条Web性能优化规则" class="headerlink" title="雅虎14条Web性能优化规则"></a>雅虎14条Web性能优化规则</h1><h2 id="法则-1-减少-HTTP-请求次数"><a href="#法则-1-减少-HTTP-请求次数" class="headerlink" title="法则 1. 减少 HTTP 请求次数"></a>法则 1. 减少 HTTP 请求次数</h2><p>80%的最终用户响应时间花在前端程序上，而其大部分时间则花在各种页面元素， 如图像、 样式表、 脚本和 Flash 等，的下载上。 减少页面元素将会减少 HTTP 请求 次数。这是快速显示页面的关键所在。 一种减少页面元素个数的方法是简化页面设计。 但是否存在其他方式，能做到既有丰富内容，又能获得快速响应时间呢？以下是这样一些技术：<br>Image maps 组合多个图片到一张图片中。总文件大小变化不大，但减少了 HTTP 请求次数从而加快了页面显示速度。该方式只适合图片连续的情况；同时坐标的定义是烦人又容易出错的工作。<br>CSS Sprites 是更好的方法。它可以组合页面中的图片到单个文件中，并使用 CSS 的 background-image 和 background-position 属性来实现所需的部分图片。 Inline images 使用 data: URL scheme 来在页面中内嵌图片。这将增大 HTML 文件的大小。组合 inline images 到你的（缓存）样式表是既能较少 HTTP 请求， 又能避免加大 HTML 文件大小的方法。<br>Combined files 通过组合多个脚本文件到单一文件来减少 HTTP 请求次数。样式 表也可采用类似方法处理。 这个方法虽然简单，但没有得到大规模的使用。  10大 美国网站每页平均有 7 个脚本文件和 2 个样式表。当页面之间脚本和样式表变化 很大时，该方式将遇到很大的挑战，但如果做到的话，将能加快响应时间。<br>小结：减少 HTTP 请求次数是性能优化的起点。这最提高首次访问的效率起到很重要的 作用。 Tenni Theurer 的文章 Browser Cache Usage – Exposed!描述，40-60% 据 的日常访问是首次访问，因此为首次访问者加快页面访问速度是用户体验的关 键。</p><h2 id="法则-2-使用-CDN-Content-Delivery-Network-内容分发网络"><a href="#法则-2-使用-CDN-Content-Delivery-Network-内容分发网络" class="headerlink" title="法则 2. 使用 CDN(Content Delivery Network, 内容分发网络 )"></a>法则 2. 使用 CDN(Content Delivery Network, 内容分发网络 )</h2><p>用户离 web server 的远近对响应时间也有很大影响。从用户角度看，把内容部 署到多个地理位置分散的服务器上将有效提高页面装载速度。 但是该从哪里开始 呢？<br>作为实现内容地理分布的第一步，不要试图重构 web 应用以适应分布架构。 改变 架构将导致多个周期性任务，如同步 session 状态，在多个 server 之间复制数 据库交易。 这样缩短用户与内容距离的尝试可能被应用架构改版所延迟，或阻止。 我们还记得 80-90%的最终用户响应时间花在下载页面中的各种元素上，如图像 文件、 样式表、 脚本和 Flash 等。 与其花在重构系统这个困难的任务上，还不如先 分布静态内容。 这不仅能大大减少响应时间，而且由于 CDN 的存在，分布静态内 容非常容易实现。 CDN 是地理上分布的 web server 的集合，用于更高效地发布内容。 通常基于网络 远近来选择给具体用户服务的 web server。 一些大型网站拥有自己的 CDN，但是使用如 Akamai Technologies, Mirror Image Internet, 或 Limelight Networks 等 CDN 服务提供商的服务将是划算的。 在 Yahoo!把静态内容分布到 CDN 减少了用户影响时间 20%或更多。切换到 CDN 的 代码修改工作是很容易的，但能达到提高网站的速度。</p><h2 id="法则-3-增加-Expires-Header"><a href="#法则-3-增加-Expires-Header" class="headerlink" title="法则 3. 增加 Expires Header"></a>法则 3. 增加 Expires Header</h2><p>网页内容正变得越来越丰富，这意味着更多的脚本文件、样式表、图像文件和 Flash。 首次访问者将不得不面临多次 HTTP 请求，但通过使用 Expires header， 您可以在客户端缓存这些元素。这在后续访问中避免了不必要的 HTTP 请求。 Expires header 最常用于图像文件，但是它也应该用于脚本文件、样式表和 Flash。 浏览器（和代理）使用缓存来减少 HTTP 请求的次数和大小，使得网页加速装载。 Web server 通过 Expires header 告诉客户端一个元素可以缓存的时间长度。 如果服务器是 Apache 的话，您可以使用 ExpiresDefault 基于当期日期来设置 过期日期，如： ExpiresDefault “access plus 10 years” 设置过期时间为从请求时间开始 计算的 10 年。 请记住，如果使用超长的过期时间，则当内容改变时，您必须修改文件名称。 在 Yahoo!我们经常把改名作为 release 的一个步骤：版本号内嵌在文件名中，如 yahoo_2.0.6.js。</p><h2 id="法则-4-压缩页面元素"><a href="#法则-4-压缩页面元素" class="headerlink" title="法则 4. 压缩页面元素"></a>法则 4. 压缩页面元素</h2><p>通过压缩 HTTP 响应内容可减少页面响应时间。从 HTTP&#x2F;1.1 开始，web 客户端在 HTTP 请求中通过 Accept-Encoding 头来表明支持的压缩类型，如：<br>Accept-Encoding: gzip, deflate. 如果 Web server 检查到 Accept-Encoding 头，它会使用客户端支持的方法来压 缩 HTTP 响应，会设置 Content-Encoding 头，如：Content-Encoding: gzip。 Gzip 是目前最流行及有效的压缩方法。 其他的方式如 deflate，但它效果较差， 也不够流行。通过 Gzip，内容一般可减少 70%。如果是 Apache，在 1.3 版本下需 使用 mod_gzip 模块，而在 2.x 版本下，则需使用 mod_deflate。 Web server 根据文件类型来决定是否压缩。 大部分网站对 HTML 文件进行压缩。 但 对脚本文件和样式表进行压缩也是值得的。实际上，对包括 XML 和 JSON 在内的 任务文本信息进行压缩都是值得的。 图像文件和 PDF 文件不应该被压缩，因为它 们本来就是压缩格式保存的。对它们进行压缩，不但浪费 CPU，而且还可能增加 文件的大小。 因此，对尽量多的文件类型进行压缩是一种减少页面大小和提高用户体验的简 便方法。</p><h2 id="法则-5-把样式表放在头上"><a href="#法则-5-把样式表放在头上" class="headerlink" title="法则 5. 把样式表放在头上"></a>法则 5. 把样式表放在头上</h2><p>我们发现把样式表移到 HEAD 部分可以提高界面加载速度，因此这使得页面元素 可以顺序显示。 在很多浏览器下，如 IE，把样式表放在 document 的底部的问题在于它禁止了网 页内容的顺序显示。 浏览器阻止显示以免重画页面元素，那用户只能看到空白页 了。Firefox 不会阻止显示，但这意味着当样式表下载后，有些页面元素可能需 要重画，这导致闪烁问题。 HTML 规范明确要求样式表被定义在 HEAD 中，因此，为避免空白屏幕或闪烁问题， 最好的办法是遵循 HTML 规范，把样式表放在 HEAD 中。</p><h2 id="法则-6-把脚本文件放在底部"><a href="#法则-6-把脚本文件放在底部" class="headerlink" title="法则 6. 把脚本文件放在底部"></a>法则 6. 把脚本文件放在底部</h2><p>与样式文件一样，我们需要注意脚本文件的位置。 我们需尽量把它们放在页面的 底部，这样一方面能顺序显示，另方面可达到最大的并行下载。 浏览器会阻塞显示直到样式表下载完毕，因此我们需要把样式表放在 HEAD 部分。 而对于脚本来说，脚本后面内容的顺序显示将被阻塞，因此把脚本尽量放在底 部意味着更多内容能被快速显示。 脚本引起的第二个问题是它阻塞并行下载数量。HTTP&#x2F;1.1 规范建议浏览器每个 主机的并行下载数不超过 2 个。 因此如果您把图像文件分布到多台机器的话，您可以达到超过 2 个的并行下载。 但是当脚本文件下载时，浏览器不会启动其他的 并行下载，甚至其他主机的下载也不启动。 在某些情况下，不是很容易就能把脚本移到底部的。如，脚本使用 document.write 方法来插入页面内容。 同时可能还存在域的问题。 不过在很多情 况下，还是有一些方法的。 一个备选方法是使用延迟脚本（deferred script）。DEFER 属性表明脚本未包 含 document.write，指示浏览器刻继续显示。不幸的是，Firefox 不支持 DEFER 属性。 IE 中，脚本可能被延迟执行，但不一定得到需要的长时间延迟。 在 不过从 另外角度来说，如果脚本能被延迟执行，那它就可以被放在底部了。</p><h2 id="法则-7-避免-CSS-表达式"><a href="#法则-7-避免-CSS-表达式" class="headerlink" title="法则 7. 避免 CSS 表达式"></a>法则 7. 避免 CSS 表达式</h2><p>CSS 表达式是功能强大的(同时也是危险的)用于动态设置 CSS 属性的方式。IE， 从版本 5 开始支持 CSS 表达式，如 backgourd-color: expression((new Date()).getHours()%2?”#B8D4FF”:”#F08A00”)，即背景色每个小时切换一 次。 CSS 表达式的问题是其执行次数超过大部分人的期望。 不仅页面显示和 resize 时 计算表达式，而且当页面滚屏，甚至当鼠标在页面上移动时都会重新计算表达 式。 一种减少 CSS 表达式执行次数的方法是一次性表达式，即当第一次执行时就以 明确的数值代替表达式。如果必须动态设置的话，可使用事件处理函数代替。如 果您必须使用 CSS 表达式的话，请记住它们可能被执行上千次，从而影响页面 性能。</p><h2 id="法则-8-把-JavaScript-和-CSS-放到外部文件中"><a href="#法则-8-把-JavaScript-和-CSS-放到外部文件中" class="headerlink" title="法则 8. 把 JavaScript 和 CSS 放到外部文件中"></a>法则 8. 把 JavaScript 和 CSS 放到外部文件中</h2><p>上述很多性能优化法则都基于外部文件进行优化。 现在，我们必须问一个问题： JavaScript 和 CSS 应该包括在外部文件，还是在页面文件中？ 在现实世界中，使用外部文件会加快页面显示速度，因为外部文件会被浏览器 缓存。如果内置 JavaScript 和 CSS 在页面中虽然会减少 HTTP 请求次数，但增大 了页面的大小。 另外一方面，使用外部文件，会被浏览器缓存，则页面大小会减 小，同时又不增加 HTTP 请求次数。 因此，一般来说，外部文件是更可行的方式。 唯一的例外是内嵌方式对主页更有 效，如 Yahoo!和 My Yahoo!都使用内嵌方式。一般来说，在一个 session 中，主 页访问此时较少，因此内嵌方式可以取得更快的用户响应时间。</p><h2 id="法则-9-减少-DNS-查询次数"><a href="#法则-9-减少-DNS-查询次数" class="headerlink" title="法则 9. 减少 DNS 查询次数"></a>法则 9. 减少 DNS 查询次数</h2><p>DNS 用于映射主机名和 IP 地址，一般一次解析需要 20～120 毫秒。 为达到更高的 性能，DNS 解析通常被多级别地缓存，如由 ISP 或局域网维护的 caching server，本地机器操作系统的缓存（如 windows 上的 DNS Client Service）， 浏览器。 的缺省 DNS 缓存时间为 30 分钟，Firefox 的缺省缓冲时间是 1 分钟。 IE 减少主机名可减少 DNS 查询的次数，但可能造成并行下载数的减少。避免 DNS 查 询可减少响应时间，而减少并行下载数可能增加响应时间。 一个可行的折中是把 内容分布到至少 2 个，最多 4 个不同的主机名上。</p><h2 id="法则-10-最小化-JavaScript代码"><a href="#法则-10-最小化-JavaScript代码" class="headerlink" title="法则 10. 最小化 JavaScript代码"></a>法则 10. 最小化 JavaScript代码</h2><p>最小化 JavaScript 代码指在 JS 代码中删除不必要的字符，从而降低下载时间。 两个流行的工具是 JSMin 和 YUI Compressor。 混淆是最小化于源码的备选方式。 象最小化一样，它通过删除注释和空格来减少 源码大小，同时它还可以对代码进行混淆处理。 作为混淆的一部分，函数名和变 量名被替换成短的字符串，这使得代码更紧凑，同时也更难读，使得难于被反 向工程。Dojo Compressor (ShrinkSafe)是最常见的混淆工具。 最小化是安全的、直白的过程，而混淆则更复杂，而且容易产生问题。从对美国 10 大网站的调查来看，通过最小化，文件可减少 21%，而混淆则可减少 25%。 除了最小化外部脚本文件外，内嵌的脚本代码也应该被最小化。 即使脚本根据法 则 4 被压缩后传输，最小化脚本刻减少文件大小 5%或更高。</p><h2 id="法则-11-避免重定向"><a href="#法则-11-避免重定向" class="headerlink" title="法则 11. 避免重定向"></a>法则 11. 避免重定向</h2><p>重定向功能是通过 301 和 302 这两个 HTTP 状态码完成的，如： HTTP&#x2F;1.1 301 Moved Permanently Location: <a href="http://example.com/newuri">http://example.com/newuri</a> Content-Type: text&#x2F;html 浏览器自动重定向请求到 Location 指定的 URL 上，重定向的主要问题是降低了 用户体验。 一种最耗费资源、经常发生而很容易被忽视的重定向是 URL 的最后缺少&#x2F;，如访 问 <a href="http://astrology.yahoo.com/astrology">http://astrology.yahoo.com/astrology</a> 将被重定向到 <a href="http://astrology.yahoo.com/astrology/%E3%80%82%E5%9C%A8">http://astrology.yahoo.com/astrology/。在</a> Apache 下，可以通过 Alias，mod_rewrite 或 DirectorySlash 等方式来解决该问题。</p><h2 id="法则-12-删除重复的脚本文件"><a href="#法则-12-删除重复的脚本文件" class="headerlink" title="法则 12. 删除重复的脚本文件"></a>法则 12. 删除重复的脚本文件</h2><p>在一个页面中包含重复的 JS 脚本文件会影响性能，即它会建立不必要的 HTTP 请求和额外的 JS 执行。 不必要的 HTTP 请求发生在 IE 下，而 Firefox 不会产生多余的 HTTP 请求。 额外的 JS 执行，不管在 IE 下，还是在 Firefox 下，都会发生。 一个避免重复的脚本文件的方式是使用模板系统来建立脚本管理模块。 除了防止 重复的脚本文件外，该模块还可以实现依赖性检查和增加版本号到脚本文件名 中，从而实现超长的过期时间。</p><h2 id="法则-13-配置-ETags"><a href="#法则-13-配置-ETags" class="headerlink" title="法则 13. 配置 ETags"></a>法则 13. 配置 ETags</h2><p>ETags 是用于确定浏览器缓存中元素是否与 Web server 中的元素相匹配的机制， 它是比 last-modified date 更灵活的元素验证机制。ETag 是用于唯一表示元素 版本的字符串，它需被包括在引号中。Web server 首先在 response 中指定 ETag： HTTP&#x2F;1.1 200 OK &lt; 03:03:59 2006 Dec 12&gt; 10c24bc-4ab-457e1c1f” Content-Length: 12195 后来，如果浏览器需要验证某元素，它使用 If-None-Match 头回传 ETag 给 Web server，如果 ETag 匹配，则服务器返回 304 代码，从而节省了下载时间</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/5a9e107b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JS面试题</title>
      <link>https://jhcgnb.cn/posts/b94f3717/</link>
      <guid>https://jhcgnb.cn/posts/b94f3717/</guid>
      <pubDate>Fri, 11 Aug 2023 09:15:55 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;在 Vue 3 中，&lt;code&gt;v-if&lt;/code&gt; 和 &lt;code&gt;v-show&lt;/code&gt; 都是用于控制元素显示和隐藏的指令，但它们之间有一些重要的区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;编译时条件：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;c</description>
        
      
      
      
      <content:encoded><![CDATA[<p>在 Vue 3 中，<code>v-if</code> 和 <code>v-show</code> 都是用于控制元素显示和隐藏的指令，但它们之间有一些重要的区别。</p><ol><li><p><strong>编译时条件：</strong></p><ul><li><code>v-if</code>：当条件为 <code>false</code> 时，元素及其内容不会被渲染到DOM中。只有在条件为 <code>true</code> 时，元素才会被编译并添加到DOM。</li><li><code>v-show</code>：无论条件是 <code>true</code> 还是 <code>false</code>，元素都会被编译到DOM中，但是在条件为 <code>false</code> 时，元素会被设置为 <code>display: none</code>，从而隐藏它。</li></ul></li><li><p><strong>性能：</strong></p><ul><li><code>v-if</code>：当条件频繁切换时，会有一定的性能开销，因为每次切换条件时都会重新创建和销毁元素及其组件。</li><li><code>v-show</code>：适用于频繁切换的情况，因为元素一直在DOM中，只是样式属性变化，没有重新创建和销毁的开销。</li></ul></li><li><p><strong>初始化渲染时间：</strong></p><ul><li><code>v-if</code>：如果初始条件为 <code>false</code>，则在初始渲染时不会渲染元素。</li><li><code>v-show</code>：无论初始条件是 <code>true</code> 还是 <code>false</code>，元素都会被渲染，只是在 <code>false</code> 时不会显示。</li></ul></li><li><p><strong>DOM 结构：</strong></p><ul><li><code>v-if</code>：条件为 <code>false</code> 时，元素及其内容不会在DOM中存在，DOM结构会根据条件的变化而改变。</li><li><code>v-show</code>：无论条件如何，元素始终存在于DOM中，只是样式属性变化。</li></ul></li><li><p><strong>适用场景：</strong></p><ul><li><code>v-if</code>：适用于条件很少改变的情况，或者在初始渲染时元素可能是隐藏的情况。</li><li><code>v-show</code>：适用于需要频繁切换显示和隐藏状态的情况，例如制作可展开折叠的内容块。</li></ul></li></ol><p>综上所述，选择 <code>v-if</code> 还是 <code>v-show</code> 取决于您的具体需求和项目的性能要求。如果条件很少改变，或者初始渲染时元素可能是隐藏的，可以考虑使用 <code>v-if</code>。如果需要频繁切换显示和隐藏状态，并且性能开销比较重要，可以考虑使用 <code>v-show</code>。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/b94f3717/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>流形与非流行</title>
      <link>https://jhcgnb.cn/posts/467cee4/</link>
      <guid>https://jhcgnb.cn/posts/467cee4/</guid>
      <pubDate>Sat, 08 Jul 2023 13:45:31 GMT</pubDate>
      
        
        
      <description>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;流形三角形网格（Manifold-Triangle-Mesh）和非流形网格（Non-Manifold-Mesh）&quot;&gt;&lt;a href=&quot;#流形三角形网格（Manifold-</description>
        
      
      
      
      <content:encoded><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="流形三角形网格（Manifold-Triangle-Mesh）和非流形网格（Non-Manifold-Mesh）"><a href="#流形三角形网格（Manifold-Triangle-Mesh）和非流形网格（Non-Manifold-Mesh）" class="headerlink" title="流形三角形网格（Manifold Triangle Mesh）和非流形网格（Non-Manifold Mesh）"></a>流形三角形网格（Manifold Triangle Mesh）和非流形网格（Non-Manifold Mesh）</h3><p>流形三角形网格（Manifold Triangle Mesh）和非流形网格（Non-Manifold Mesh）是在计算机图形学和几何处理中常见的两种网格类型。它们具有不同的特征和限制，对于不同的应用领域和算法，选择合适的网格类型是非常重要的。</p><ol><li><p>流形三角形网格：<br>流形三角形网格是一种拓扑上具有连续性和封闭性的网格。它的特征包括：</p><ul><li>每个顶点最多与两个边和两个面相连。</li><li>每个边最多与两个面相连。</li><li>每个面最多与三条边和三个顶点相连。</li><li>网格中不存在孤立的顶点、边或面。</li></ul><p>流形三角形网格常用于表示光滑曲面和可变形物体，它具有良好的几何性质和拓扑特征，适用于各种几何处理算法，如渲染、形状分析和物理模拟等。</p></li><li><p>非流形网格：<br>非流形网格是一种拓扑上不具备连续性和封闭性的网格。它的特征包括：</p><ul><li>顶点、边或面可以具有任意数量的相邻元素。</li><li>存在孤立的顶点、边或面。</li><li>边和面之间的连接关系可以是多对多的。</li></ul><p>非流形网格常用于表示复杂的几何结构，如曲面上的孔洞、尖锐的边缘或非连续的形状。然而，由于其拓扑特性的复杂性，非流形网格在某些算法和应用中可能会导致问题，例如光滑、纹理映射和体积建模等。</p></li></ol><p>对于流形三角形网格和非流形网格，需要根据具体的应用场景和算法需求选择合适的网格类型。流形三角形网格适用于大多数常规几何处理任务，而非流形网格则更适用于具有复杂拓扑结构的特殊情况。在处理非流形网格时，需要特别注意处理拓扑上的不连续性和边界条件。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E5%AD%A6%E6%9C%AF/">学术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <comments>https://jhcgnb.cn/posts/467cee4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>详解@RequestParam</title>
      <link>https://jhcgnb.cn/posts/f43726f7/</link>
      <guid>https://jhcgnb.cn/posts/f43726f7/</guid>
      <pubDate>Tue, 04 Jul 2023 02:07:55 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;RequestParam&quot;&gt;&lt;a href=&quot;#RequestParam&quot; class=&quot;headerlink&quot; title=&quot;@RequestParam&quot;&gt;&lt;/a&gt;@RequestParam&lt;/h3&gt;&lt;p&gt;在Java中，&lt;code&gt;@RequestParam&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>在Java中，<code>@RequestParam</code> 是一个注解，用于从HTTP请求中获取参数值。它通常用于Spring MVC框架中的控制器方法中，以指定方法参数应该绑定到HTTP请求中的特定参数。</p><p><code>@RequestParam</code> 可以用于处理HTTP请求的查询参数、表单参数或路径参数。它可以应用于方法的参数或方法的参数上的注解。</p><p>下面是一些示例：</p><ol><li>使用默认参数名称：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将尝试从HTTP请求中获取名为 “param” 的查询参数，并将其绑定到方法参数 <code>param</code>。</p><ol start="2"><li>使用自定义参数名称：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam(&quot;customParam&quot;)</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，<code>@RequestParam</code> 注解指定了参数的自定义名称 “customParam”，它将从HTTP请求中获取该参数，并将其绑定到方法参数 <code>param</code>。</p><ol start="3"><li>设置默认值：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam(value = &quot;param&quot;, defaultValue = &quot;default&quot;)</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，如果请求中没有名为 “param” 的参数，或者参数的值为空，那么方法参数 <code>param</code> 将被设置为默认值 “default”。</p><ol start="4"><li>必需的参数：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exampleMethod</span><span class="params">(<span class="meta">@RequestParam(required = true)</span> String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>@RequestParam</code> 注解的 <code>required</code> 属性被设置为 <code>true</code>，表示参数是必需的。如果请求中没有提供该参数，将会返回错误。</p><p>总结一下，<code>@RequestParam</code> 注解用于从HTTP请求中获取参数值，并将其绑定到Java方法的参数。它提供了许多选项，可以根据需要配置参数的名称、默认值和是否必需。这样，开发者可以方便地处理HTTP请求中的参数。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/Java/">Java</category>
      
      
      <comments>https://jhcgnb.cn/posts/f43726f7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Cesium面试题</title>
      <link>https://jhcgnb.cn/posts/a98e3ede/</link>
      <guid>https://jhcgnb.cn/posts/a98e3ede/</guid>
      <pubDate>Mon, 03 Jul 2023 06:07:01 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e0239a75f96830e577eef736ebcad965.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;heade</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/e0239a75f96830e577eef736ebcad965.png" alt="img"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="Cesium开发面试题"><a href="#Cesium开发面试题" class="headerlink" title="Cesium开发面试题"></a>Cesium开发面试题</h1><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="1、请简要介绍一下Cesium的基本功能。"><a href="#1、请简要介绍一下Cesium的基本功能。" class="headerlink" title="1、请简要介绍一下Cesium的基本功能。"></a>1、请简要介绍一下Cesium的基本功能。</h2><p>答：Cesium是一款3D地球可视化引擎，可以在Web浏览器中显示高度真实感的3D地球场景，包括地形、地表纹理、3D建筑、水域等。它提供多种漫游和导航方式，支持多种地形和影像数据格式，以及3D Tiles、CZML等技术，可以用于实时位置追踪、天文数据显示、地下和空中场景等应用场景。</p><h2 id="2、请解释一下Cesium中的3D-Tiles技术是什么，以及它的作用是什么。"><a href="#2、请解释一下Cesium中的3D-Tiles技术是什么，以及它的作用是什么。" class="headerlink" title="2、请解释一下Cesium中的3D Tiles技术是什么，以及它的作用是什么。"></a>2、请解释一下Cesium中的3D Tiles技术是什么，以及它的作用是什么。</h2><p>  答：3D Tiles是一种用于高效地加载和显示大规模的3D地球数据的技术，可以将复杂的3D数据分层并进行高度优化。Cesium中的3D Tiles技术可以支持大规模的3D地球数据，包括城市、建筑、地形等，提高了数据的加载速度和显示效率。</p><h2 id="3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？"><a href="#3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？" class="headerlink" title="3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？"></a>3、CZML是Cesium中的一个数据格式，它是什么，以及它用于描述什么样的场景？</h2><p>  答：CZML（Cesium Language）是一种描述和显示动态的地球场景的数据格式，它可以用于描述航班轨迹、气象数据、卫星运行轨迹等。CZML中可以包含实体的位置、速度、方向等信息，以及可视化效果的设置。</p><h2 id="4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。"><a href="#4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。" class="headerlink" title="4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。"></a>4、请解释一下Cesium中的ImageryProvider是什么，以及它的作用是什么。</h2><p>  答：ImageryProvider是Cesium中的一个数据提供器，用于提供地图和影像数据。它可以从多种来源获取数据，比如Web Map Service（WMS）、Web Map Tile Service（WMTS）等，并在地球表面上显示出来。通过使用ImageryProvider，开发者可以轻松地获取并显示各种地图和影像数据。</p><h2 id="5、如何加载飞线"><a href="#5、如何加载飞线" class="headerlink" title="5、如何加载飞线"></a>5、如何加载飞线</h2><p>  答：1、创建polyLine实体</p><p>   2、计算带有弧度效果的点集数组作为polyline的positions属性参数</p><h2 id="6、如何设置飞线动效材质"><a href="#6、如何设置飞线动效材质" class="headerlink" title="6、如何设置飞线动效材质"></a>6、如何设置飞线动效材质</h2><p>答：1、创建cesium自定义材质类</p><p>2、创建shader，原理是通过贴图UV移动来实现流光效果</p><h2 id="7、如何在cesium地球上添加柱状图"><a href="#7、如何在cesium地球上添加柱状图" class="headerlink" title="7、如何在cesium地球上添加柱状图"></a>7、如何在cesium地球上添加柱状图</h2><p>答：1、创建entity实体，使用box属性；</p><p>2、dimensions设置长宽；</p><p>3、position设置中心点位置；</p><p>4、heightReference属性设置贴地属性；</p><h2 id="8、如何让柱状图跟随数据变化"><a href="#8、如何让柱状图跟随数据变化" class="headerlink" title="8、如何让柱状图跟随数据变化"></a>8、如何让柱状图跟随数据变化</h2><p>答：1、创建SampledPositionProperty对象</p><p>2、在不同的时间点绑定对应的值</p><p>  将填充好的SampledPositionProperty赋值给dimensions，实现位置随时间的偏移</p><h2 id="9、如何加载天气图的效果"><a href="#9、如何加载天气图的效果" class="headerlink" title="9、如何加载天气图的效果"></a>9、如何加载天气图的效果</h2><p>答：1、使用Wind3D类实现</p><p>实现原理是将nc格式的数据解析之后运用primitive绘制</p><p>​    2、Cesium官网有github的分享案例，需要修改鼠标事件影响该类绘制时的显示隐藏</p><h2 id="10、如何给cesium地球替换表面图层"><a href="#10、如何给cesium地球替换表面图层" class="headerlink" title="10、如何给cesium地球替换表面图层"></a>10、如何给cesium地球替换表面图层</h2><p>答：1、主要是在viewer的imageryLayers地图层级内对单独的layer图层的显示隐藏或者添加与移除，imageryLayers有add与remove方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、viewer.imageryLayers.addImageryProvider(layer, num);</span><br><span class="line">viewer.imageryLayers.remove(viewer.imageryLayers.get(num), true);</span><br></pre></td></tr></table></figure><p>主要是这两个API<br>    3、注意不同的地图图层加载会有对应的投影方式，比如web墨卡托投影和wgs84</p><h2 id="11、cesium如何进行坐标转换"><a href="#11、cesium如何进行坐标转换" class="headerlink" title="11、cesium如何进行坐标转换"></a>11、cesium如何进行坐标转换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">答：1、//经纬度转屏幕坐标</span><br><span class="line"></span><br><span class="line">LngLatToSceenCoordinates(lng, lat) &#123;</span><br><span class="line"></span><br><span class="line">let cartesian3 = Cesium.Cartesian3.fromDegrees(lng, lat);</span><br><span class="line"></span><br><span class="line">let cartesian2 = Cesium.SceneTransforms.wgs84ToWindowCoordinates(</span><br><span class="line"></span><br><span class="line">viewer.scene,</span><br><span class="line"></span><br><span class="line">cartesian3</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">return cartesian2;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">2、 //笛卡尔坐标转经纬度坐标</span><br><span class="line"></span><br><span class="line">Cartesian3ToLngLat(cartesian) &#123;</span><br><span class="line"></span><br><span class="line">let cartographic =</span><br><span class="line"></span><br><span class="line">viewer.scene.globe.ellipsoid.cartesianToCartographic(cartesian);</span><br><span class="line"></span><br><span class="line">let c_height = viewer.camera.positionCartographic.height;</span><br><span class="line"></span><br><span class="line">//将地图坐标（弧度）转为十进制的度数</span><br><span class="line"></span><br><span class="line">let lat_String = Cesium.Math.toDegrees(cartographic.latitude).toFixed(6);</span><br><span class="line"></span><br><span class="line">let log_String = Cesium.Math.toDegrees(cartographic.longitude).toFixed(6);</span><br><span class="line"></span><br><span class="line">return [</span><br><span class="line"></span><br><span class="line">parseFloat(log_String),</span><br><span class="line"></span><br><span class="line">parseFloat(lat_String),</span><br><span class="line"></span><br><span class="line">parseFloat(c_height),</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="12、cesium如何实现标记的添加"><a href="#12、cesium如何实现标记的添加" class="headerlink" title="12、cesium如何实现标记的添加"></a>12、cesium如何实现标记的添加</h2><p>  答：1、创建entity实体对象使用billboard对象场景图标挥着使用billboard collection使用primitive创建</p><h2 id="13、cesium如何实现鼠标拾取弹窗功能"><a href="#13、cesium如何实现鼠标拾取弹窗功能" class="headerlink" title="13、cesium如何实现鼠标拾取弹窗功能"></a>13、cesium如何实现鼠标拾取弹窗功能</h2><p>   答：1、创建new Cesium.ScreenSpaceEventHandler(canvas)对象</p><p> 2、注册鼠标点击事件<br>   3、使用let pick &#x3D; viewer.scene.pick(movement.position); 选取当前的entity</p><h2 id="14、如何设置cesium中的抗锯齿方法"><a href="#14、如何设置cesium中的抗锯齿方法" class="headerlink" title="14、如何设置cesium中的抗锯齿方法"></a>14、如何设置cesium中的抗锯齿方法</h2><p>  答：1、使用fxaa方法，效果较差</p><p>  2、使用msaa方法，但需要浏览器支持webGL2的api方法</p><p><img src="https://bcn.135editor.com/files/images/editor_styles/2b4dad3b5ce0324eb63cde4380e4cdfb.gif" alt="img"></p><p><img src="https://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9wbmcvdm5UNGhiYUxvWDZIWkQxZXFvRmljVXdwR3RPSklNamNzaWNNVVVZWDRvNHNNMGhQQ2RQRUtTV0pIYkdQb2MyVWJQaWNGVlNTM2ljU3hZRDdoOTdNUHYwSW9BLzA/d3hfZm10PXBuZw==" alt="img"></p><p><img src="https://bcn.135editor.com/files/images/editor_styles/8a370d08cb8dee16148088fd86f39e16.png" alt="img"></p><p><img src="https://bexp.135editor.com/files/users/498/4980660/202302/k5PHuh8T_I5qb.jpg?auth_key=1677427199-0-0-d90c72020ea7995dbf533d91bb976f8c" alt="qrcode_for_gh_e879ec750214_258.jpg"></p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/Cesium/">Cesium</category>
      
      
      <comments>https://jhcgnb.cn/posts/a98e3ede/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JS是如何实现继承的</title>
      <link>https://jhcgnb.cn/posts/undefined/</link>
      <guid>https://jhcgnb.cn/posts/undefined/</guid>
      <pubDate>Wed, 14 Jun 2023 12:37:56 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;JS是如何实现继承的&quot;&gt;&lt;a href=&quot;#JS是如何实现继承的&quot; class=&quot;headerlink&quot; title=&quot;JS是如何实现继承的&quot;&gt;&lt;/a&gt;JS是如何实现继承的&lt;/h3&gt;&lt;p&gt;在 JavaScript 中，继承是通过原型链来实现的。每个对象都有一个原型</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="JS是如何实现继承的"><a href="#JS是如何实现继承的" class="headerlink" title="JS是如何实现继承的"></a>JS是如何实现继承的</h3><p>在 JavaScript 中，继承是通过原型链来实现的。每个对象都有一个原型（prototype）属性，它指向另一个对象，这个对象即作为当前对象的原型。继承就是通过让一个对象继承另一个对象的属性和方法，使得子对象可以共享父对象的功能。</p><p>下面介绍几种常见的继承方式：</p><ol><li><strong>原型链继承</strong>：</li></ol><p>原型链继承是最基本的继承方式，它利用原型链将父对象的属性和方法传递给子对象。子对象的原型链上依次连接着父对象的原型，从而实现继承。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello from <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: &quot;Hello from Child&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>构造函数继承</strong>：</li></ol><p>构造函数继承通过在子对象的构造函数中调用父对象的构造函数来实现继承。这样可以实现父对象属性的继承，但无法继承父对象原型上的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>); <span class="comment">// 输出: &quot;Child&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>组合继承</strong>：</li></ol><p>组合继承是将原型链继承和构造函数继承结合起来的一种方式，它既继承了父对象的属性和方法，又通过调用父对象的构造函数来实现属性的初始化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello from <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 构造函数继承</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 原型链继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: &quot;Hello from Child&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>ES6 Class 继承</strong>：</li></ol><p>ES6 引入了类（class）的概念，使得继承更加清晰和语法更加友好。通过 <code>extends</code> 关键字，可以轻松地实现一个类继承另一个类的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello from <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: &quot;Hello from Child&quot;</span></span><br></pre></td></tr></table></figure><p>无论使用哪种继承方式，都应该注意可能存在的问题，例如原型链继承可能导致属性共享问题，构造函数继承可能无法继承原型上的方法等。选择合适的继承方式要根据具体的需求来决定。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/undefined/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux项目部署详细步骤</title>
      <link>https://jhcgnb.cn/posts/d594835b/</link>
      <guid>https://jhcgnb.cn/posts/d594835b/</guid>
      <pubDate>Tue, 09 May 2023 11:08:33 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;安装部署&quot;&gt;&lt;a href=&quot;#安装部署&quot; class=&quot;headerlink&quot; title=&quot;安装部署&quot;&gt;&lt;/a&gt;安装部署&lt;/h1&gt;&lt;h2 id=&quot;一、环境准备&quot;&gt;&lt;a href=&quot;#一、环境准备&quot; class=&quot;headerlink&quot; title=&quot;一、环境准</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><p>说明：如果已经安装过相关工具就忽略</p><h3 id="1安装JAVA-运行环境"><a href="#1安装JAVA-运行环境" class="headerlink" title="1安装JAVA 运行环境"></a>1安装JAVA 运行环境</h3><p>第一步：上传或下载安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /usr/local</span><br></pre></td></tr></table></figure><p>jdk-8u152-linux-x64.tar.gz</p><p>第二步：解压安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u152-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>第三步：建立软连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/jdk1.8.0_152/  /usr/local/jdk </span><br></pre></td></tr></table></figure><p>第四步：修改环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/jdk</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过命令source /etc/profile让profile文件立即生效</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>第五步、测试是否安装成功</p><p>使用java -version，出现版本为java version “1.8.0_152”</p><h3 id="2安装maven"><a href="#2安装maven" class="headerlink" title="2安装maven"></a>2安装maven</h3><p>第一步：上传或下载安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /usr/local</span><br></pre></td></tr></table></figure><p>apache-maven-3.6.1-bin.tar.gz</p><p>第二步：解压安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar  -zxvf  apache-maven-3.6.1-bin.tar.gz</span><br></pre></td></tr></table></figure><p>第三步：建立软连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln  -s  /usr/local/apache-maven-3.6.1/  /usr/local/maven</span><br></pre></td></tr></table></figure><p>第四步：修改环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export MAVEN_HOME=/usr/local/maven</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过命令source /etc/profile让profile文件立即生效</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>第五步、测试是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn –v</span><br></pre></td></tr></table></figure><h3 id="3安装docker"><a href="#3安装docker" class="headerlink" title="3安装docker"></a>3安装docker</h3><p>环境安装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p>第一步：安装必要的一些系统工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2 </span><br></pre></td></tr></table></figure><p>第二步：添加软件源信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>第三步：更新并安装Docker-CE</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><p>第四步：开启Docker服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>第五步：测试是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -v </span><br></pre></td></tr></table></figure><p>第六步：配置镜像加速器</p><p>您可以通过修改daemon配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json来使用加速器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> &quot;registry-mirrors&quot;: [&quot;https://ldu6wrsf.mirror.aliyuncs.com&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="4安装mysql"><a href="#4安装mysql" class="headerlink" title="4安装mysql"></a>4安装mysql</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name mysql --restart=always -v /home/ljaer/mysql:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 </span><br></pre></td></tr></table></figure><p>第三步：测试mysql</p><p>进入容器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p>登录mysql：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>如果顺利进入，安装成功</p><h3 id="5安装rabbitmq"><a href="#5安装rabbitmq" class="headerlink" title="5安装rabbitmq"></a>5安装rabbitmq</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5672:5672 -p 15672:15672 --restart=always --name rabbitmq rabbitmq:management</span><br></pre></td></tr></table></figure><p>第三步：安装延迟队列插件</p><ol><li><p>首先下载rabbitmq_delayed_message_exchange-3.9.0.ez文件上传到RabbitMQ所在服务器，下载地址：<a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p></li><li><p>切换到插件所在目录，执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp rabbitmq_delayed_message_exchange-3.9.0.ez rabbitmq:/plugins </span><br></pre></td></tr></table></figure><p>命令，将刚插件拷贝到容器内plugins目录下</p></li><li><p>执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it rabbitmq /bin/bash </span><br></pre></td></tr></table></figure><p>命令进入到容器内部，并 cd plugins 进入plugins目录</p></li><li><p>执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l|grep delay</span><br></pre></td></tr></table></figure><p>  命令查看插件是否copy成功</p></li><li><p>在容器内plugins目录下，执行 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>  命令启用插件</p></li><li><p>exit命令退出RabbitMQ容器内部，然后执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart rabbitmq </span><br></pre></td></tr></table></figure><p>命令重启RabbitMQ容器</p></li></ol><h3 id="6安装redis"><a href="#6安装redis" class="headerlink" title="6安装redis"></a>6安装redis</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 6379:6379  --restart=always redis:latest redis-server</span><br></pre></td></tr></table></figure><h3 id="7安装nacos"><a href="#7安装nacos" class="headerlink" title="7安装nacos"></a>7安装nacos</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nacos/nacos-server:1.4.1</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --env MODE=standalone --name nacos --restart=always -d -p 8848:8848 -e JVM_XMS=512m -e JVM_XMX=512m nacos/nacos-server:1.4.1</span><br></pre></td></tr></table></figure><h3 id="8安装sentinel"><a href="#8安装sentinel" class="headerlink" title="8安装sentinel"></a>8安装sentinel</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull bladex/sentinel-dashboard</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name sentinel-dashboard --restart=always -p 8858:8858 -d bladex/sentinel-dashboard:latest  </span><br></pre></td></tr></table></figure><h3 id="9安装elasticsearch"><a href="#9安装elasticsearch" class="headerlink" title="9安装elasticsearch"></a>9安装elasticsearch</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:7.8.0</span><br></pre></td></tr></table></figure><p>第二步：启动</p><p>需要建立：两个文件夹</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /mydata/elasticsearch/plugins</span><br><span class="line"></span><br><span class="line">mkdir -p /mydata/elasticsearch/data</span><br></pre></td></tr></table></figure><p>授予权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /mydata/elasticsearch/data</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 --name elasticsearch --restart=always \-e &quot;discovery.type=single-node&quot; \-e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; \-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \-d elasticsearch:7.8.0</span><br></pre></td></tr></table></figure><p>第三步：安装中文分词器</p><ol><li><p>下载elasticsearch-analysis-ik-7.8.0.zip</p></li><li><p>上传解压：unzip elasticsearch-analysis-ik-7.8.0.zip -d ik-analyzer</p></li><li><p>上传到es容器：docker cp .&#x2F;ik-analyzer a24eb9941759:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</p></li><li><p>重启es：docker restart a24eb9941759</p></li></ol><p>a24eb9941759：表示容器ID 运行时，需要改成自己的容器ID</p><h3 id="10-安装kibana"><a href="#10-安装kibana" class="headerlink" title="10 安装kibana"></a>10 安装kibana</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull kibana:7.8.0</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name kibana --restart=always -e ELASTICSEARCH_URL=http://192.168.112.165:9200 -p 5601:5601 -d kibana:7.8.0</span><br></pre></td></tr></table></figure><p>进入容器修改：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 1e12f8dd3efd /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd config</span><br><span class="line"></span><br><span class="line">vi kibana.yml</span><br><span class="line"></span><br><span class="line">elasticsearch.hosts: [ &quot;http://192.168.200.129:9200&quot; ]</span><br><span class="line"></span><br><span class="line">docker restart 1dc0f78d78ad 重启kibana ！</span><br></pre></td></tr></table></figure><p>测试：安装分词词库是否可以使用！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /.kibana/_analyze</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> &quot;text&quot;: &quot;我是中国人&quot;,</span><br><span class="line"></span><br><span class="line"> &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11安装zipkin"><a href="#11安装zipkin" class="headerlink" title="11安装zipkin"></a>11安装zipkin</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull openzipkin/zipkin</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name zipkin --restart=always -d -p 9411:9411 openzipkin/zipkin </span><br></pre></td></tr></table></figure><h3 id="12安装minio"><a href="#12安装minio" class="headerlink" title="12安装minio"></a>12安装minio</h3><p>已安装或能访问忽略</p><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run \ -p 9000:9000 \ -p 9001:9001 \ --name minio \ -d --restart=always \ -e &quot;MINIO_ROOT_USER=admin&quot; \ -e &quot;MINIO_ROOT_PASSWORD=admin123456&quot; \ -v /home/data:/data \ -v /home/config:/root/.minio \ minio/minio server /data --console-address &quot;:9001&quot;</span><br></pre></td></tr></table></figure><p>浏览器访问：<a href="http://ip:9000/minio/login%EF%BC%8C">http://IP:9000/minio/login，</a></p><h3 id="13-安装logstash"><a href="#13-安装logstash" class="headerlink" title="13 安装logstash"></a>13 安装logstash</h3><p>第一步：拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull logstash:7.8.0</span><br></pre></td></tr></table></figure><p>第二步：启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name logstash -p 5044:5044 --restart=always --link elasticsearch:es -v /mydata/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf -d logstash:7.8.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--net root_default \</span><br></pre></td></tr></table></figure><table><thead><tr><th># 需要提前在linux服务器上环境 &#x2F;mydata&#x2F;logstash&#x2F;logstash.conflogstash.confinput { tcp {mode &#x3D;&gt; “server”host &#x3D;&gt; “0.0.0.0”port &#x3D;&gt; 5044codec &#x3D;&gt; json_lines }}filter{ }output { elasticsearch {hosts &#x3D;&gt; “192.168.112.165:9200”index &#x3D;&gt; “gmall-%{+YYYY.MM.dd}” }}</th></tr></thead><tbody><tr><td></td></tr></tbody></table><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>停止所有的容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有的容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>#删除所有的镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p>问题：</p><p>Docker容器做端口映射报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint lamp3 (46b7917c940f7358948e55ec2df69a4dec2c6c7071b002bd374e8dbf0d40022c): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 86 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name.</span><br></pre></td></tr></table></figure><p>解决方法</p><p>docker服务启动时定义的自定义链DOCKER被清除</p><p>重启即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/Java/">Java</category>
      
      
      <comments>https://jhcgnb.cn/posts/d594835b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>多边形</title>
      <link>https://jhcgnb.cn/posts/undefined/</link>
      <guid>https://jhcgnb.cn/posts/undefined/</guid>
      <pubDate>Mon, 08 May 2023 13:28:12 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Voronoi-多边形&quot;&gt;&lt;a href=&quot;#Voronoi-多边形&quot; class=&quot;headerlink&quot; title=&quot;Voronoi 多边形&quot;&gt;&lt;/a&gt;Voronoi 多边形&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://rx6zk4j2b.hn-bkt.</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Voronoi-多边形"><a href="#Voronoi-多边形" class="headerlink" title="Voronoi 多边形"></a>Voronoi 多边形</h3><p><img src="http://rx6zk4j2b.hn-bkt.clouddn.com/blogs/image-20230708212920053.png" alt="image-20230708212920053"></p><p>Voronoi 多边形，也称为 Voronoi 图或 Voronoi 分割，是一种空间分析和几何计算方法，用于将平面或空间划分为不同区域，每个区域都与给定一组点最近邻。这些区域被称为 Voronoi 多边形或 Voronoi 区域，每个多边形由与其对应的点作为最近邻点。</p><p>Voronoi 多边形的生成过程基于以下原则：给定一组点，每个点的 Voronoi 区域包含所有离该点最近的点，并且这些点之间的边界形成多边形。Voronoi 多边形的边界由平分相邻点之间的直线或曲线段组成，这些直线或曲线段是两个点之间的等距离线，也称为 Voronoi 边。因此，Voronoi 多边形的边界是相邻点之间的中垂线。</p><p>Voronoi 多边形在各种领域中有广泛应用，包括计算机图形学、计算机视觉、地理信息系统（GIS）、模式识别等。以下是一些应用 Voronoi 多边形的示例：</p><ol><li><p>空间分析：Voronoi 多边形可用于将地理空间划分为不同的区域，每个区域都由最近邻点决定。这在地理学、城市规划和环境分析中具有重要作用，可以用于确定服务设施的服务范围、确定地理区域的边界等。</p></li><li><p>面积计算：通过计算 Voronoi 多边形的面积，可以了解每个点的影响范围或区域的大小。这在生态学、资源管理和人口统计学中很有用。</p></li><li><p>最近邻搜索：Voronoi 多边形可用于确定给定点的最近邻点。这在图像处理、模式识别和计算机视觉中经常使用，例如图像中的特征匹配、对象识别等。</p></li><li><p>网格生成：Voronoi 多边形可以用作生成网格的方法之一。通过将点集表示为 Voronoi 图，可以生成规则且适应性良好的网格，这在数值计算和有限元分析中很有用。</p></li></ol><p>总之，Voronoi 多边形是一种强大的几何计算工具，可用于空间分析、最近邻搜索、面积计算和网格生成等应用领域。它提供了一种有效的方法来划分空间并了解点之间的关系，为许多问题的解决提供了有力支持。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E5%AD%A6%E6%9C%AF/">学术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <comments>https://jhcgnb.cn/posts/undefined/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2.JS基础</title>
      <link>https://jhcgnb.cn/posts/fec612ee/</link>
      <guid>https://jhcgnb.cn/posts/fec612ee/</guid>
      <pubDate>Wed, 26 Apr 2023 13:36:48 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;JS基础知识&quot;&gt;&lt;a href=&quot;#JS基础知识&quot; class=&quot;headerlink&quot; title=&quot;JS基础知识&quot;&gt;&lt;/a&gt;JS基础知识&lt;/h1&gt;&lt;h2 id=&quot;1-javascript的typeof返回哪些数据类型&quot;&gt;&lt;a href=&quot;#1-javascri</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="JS基础知识"><a href="#JS基础知识" class="headerlink" title="JS基础知识"></a>JS基础知识</h1><h2 id="1-javascript的typeof返回哪些数据类型"><a href="#1-javascript的typeof返回哪些数据类型" class="headerlink" title="1.javascript的typeof返回哪些数据类型"></a>1.javascript的typeof返回哪些数据类型</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="title function_">alert</span>(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">//object</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="string">&#x27;leipeng&#x27;</span>); <span class="comment">//string</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="literal">true</span>; </span><br><span class="line">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> i); <span class="comment">//boolean</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="number">1</span>); <span class="comment">//number</span></span><br><span class="line">    <span class="keyword">var</span> a; </span><br><span class="line">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> a); <span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;;&#125;;</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> a) <span class="comment">//function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">isNaN</span>  <span class="keyword">function</span></span><br><span class="line">检测数组的几种方式：</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr);   es5</span><br><span class="line"><span class="title class_">Object</span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) === ‘object <span class="title class_">Array</span>’</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br><span class="line">arr.<span class="property">constructor</span> === <span class="title class_">Array</span></span><br></pre></td></tr></table></figure><h2 id="2-例举3种强制类型转换和2种隐式类型转换"><a href="#2-例举3种强制类型转换和2种隐式类型转换" class="headerlink" title="2.例举3种强制类型转换和2种隐式类型转换?"></a>2.例举3种强制类型转换和2种隐式类型转换?</h2><p>强制（parseInt(),parseFloat(),Number()）<br>隐式（&#x3D;&#x3D; ,!!）</p><h2 id="3-split-、join-的区别"><a href="#3-split-、join-的区别" class="headerlink" title="3.split() 、join() 的区别"></a>3.split() 、join() 的区别</h2><p>前者是切割成数组的形式，后者是将数组转换成字符串</p><h2 id="4-数组方法pop-push-unshift-shift"><a href="#4-数组方法pop-push-unshift-shift" class="headerlink" title="4.数组方法pop() push() unshift() shift()"></a>4.数组方法pop() push() unshift() shift()</h2><p>Push()尾部添加 pop()尾部删除<br>Unshift()头部添加 shift()头部删除</p><h2 id="5-事件绑定和普通事件有什么区别"><a href="#5-事件绑定和普通事件有什么区别" class="headerlink" title="5.事件绑定和普通事件有什么区别"></a>5.事件绑定和普通事件有什么区别</h2><p>普通添加事件的方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">执行上面的代码只会alert <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">事件绑定方式添加事件：</span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">执行上面的代码会先alert <span class="number">1</span> 再 alert <span class="number">2</span></span><br><span class="line"><span class="number">1.</span>普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，而事件绑定（addEventListener）方式添加事件可以添加多个。</span><br><span class="line"><span class="number">2.</span>普通事件绑定不支持<span class="variable constant_">DOM</span>事件流，事件捕获-目标元素-事件冒泡（可以把事件绑定在不同的阶段去执行）</span><br><span class="line"><span class="number">3.</span>addEventListener不兼容低版本<span class="variable constant_">IE</span>，第三个参数默认为<span class="literal">false</span>，表示在事件冒泡阶段执行</span><br><span class="line">普通事件无法取消；第三个参数为<span class="literal">true</span>的时候表示在事件捕获的阶段执行；不需要on前缀；</span><br><span class="line">addEventLisntener还支持事件冒泡+事件捕获；</span><br><span class="line"><span class="number">4.</span>addEventLisntener同一个元素绑定完全相同的事件并不会覆盖掉前面的事件</span><br><span class="line"><span class="number">5.</span>attachEvent只支持事件冒泡，不支持事件捕获。</span><br></pre></td></tr></table></figure><h2 id="6-IE和DOM事件流的区别"><a href="#6-IE和DOM事件流的区别" class="headerlink" title="6.IE和DOM事件流的区别"></a>6.IE和DOM事件流的区别</h2><p>1.执行顺序不一样、<br>2.参数不一样<br>3.事件加不加on<br>4.this指向问题</p><h2 id="7-IE和标准下有哪些兼容性的写法"><a href="#7-IE和标准下有哪些兼容性的写法" class="headerlink" title="7.IE和标准下有哪些兼容性的写法"></a>7.IE和标准下有哪些兼容性的写法</h2><p>Var ev &#x3D; ev || window.event；   &#x2F;&#x2F; 获取触发事件对象<br>Var target &#x3D; ev.srcElement||ev.target  &#x2F;&#x2F; 获取触发事件的源对象<br>document.documentElement.clientWidth || document.body.clientWidth</p><h2 id="8-call和apply的区别"><a href="#8-call和apply的区别" class="headerlink" title="8.call和apply的区别"></a>8.call和apply的区别</h2><p>call方法:<br>语法：call(thisObj，Object1,Object2…)<br>定义：调用一个对象的一个方法，以另一个对象替换当前对象。<br>说明：<br>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。<br>如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</p><p>apply方法：<br>语法：apply(thisObj，[argArray])<br>定义：应用某一对象的一个方法，用另一个对象替换当前对象。<br>说明：<br>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p><h2 id="9-b继承a的方法"><a href="#9-b继承a的方法" class="headerlink" title="9.b继承a的方法"></a>9.b继承a的方法</h2><p>原型链继承<br>借用构造函数继承<br>原型+构造函数组合继承<br>寄生式继承</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"> age, name </span>)&#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;父级方法&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params">age,name,job</span>)&#123; </span><br><span class="line">  A.<span class="title function_">apply</span>( <span class="variable language_">this</span>, <span class="variable language_">arguments</span> ); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">A</span>(<span class="number">14</span>,<span class="string">&#x27;侠客行&#x27;</span>); </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">B</span>(<span class="number">15</span>,<span class="string">&#x27;狼侠&#x27;</span>,<span class="string">&#x27;侠客&#x27;</span>); </span><br></pre></td></tr></table></figure><h2 id="10-如何阻止事件冒泡和默认事件"><a href="#10-如何阻止事件冒泡和默认事件" class="headerlink" title="10.如何阻止事件冒泡和默认事件"></a>10.如何阻止事件冒泡和默认事件</h2><p>canceBubble()只支持IE,return false,stopPropagation()</p><h2 id="11-JS创建对象的几种方式？"><a href="#11-JS创建对象的几种方式？" class="headerlink" title="11.JS创建对象的几种方式？"></a>11.JS创建对象的几种方式？</h2><p>对象字面量 &#x2F; Object构造函数<br>构造函数<br>纯构造函数<br>空构造函数 + 原型<br>混合构造函数 + 原型<br>动态原型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态原型的使用</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, work</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JS中通过if条件动态给一个对象添加属性或者方法的过程就是动态原型</span></span><br><span class="line">        <span class="keyword">if</span> (work) &#123;</span><br><span class="line">            <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">working</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我的工作是：&#x27;</span>, work);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">寄生构造函数</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>()</span><br></pre></td></tr></table></figure><h2 id="12-this指针，闭包，作用域"><a href="#12-this指针，闭包，作用域" class="headerlink" title="12.this指针，闭包，作用域"></a>12.this指针，闭包，作用域</h2><p>闭包： 收敛权限，避免变量全局污染；可以实现模块化（jQuery）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立即执行函数</span></span><br><span class="line">    <span class="keyword">var</span> common = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&#x27;common module&#x27;</span>;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">initPage</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向外暴露一个对象</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            initpage : initPage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    common.<span class="title function_">initpage</span>();</span><br><span class="line"><span class="comment">// 使用闭包函数实现点击弹出真实索引</span></span><br><span class="line">    <span class="keyword">var</span> lis = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">            lis[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(i);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="13-添加-删除-替换-插入到某个接点的方法"><a href="#13-添加-删除-替换-插入到某个接点的方法" class="headerlink" title="13.添加 删除 替换 插入到某个接点的方法"></a>13.添加 删除 替换 插入到某个接点的方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.<span class="title function_">appendChid</span>()</span><br><span class="line">obj.<span class="title function_">insertBefore</span>()</span><br><span class="line">obj.<span class="title function_">replaceChild</span>()</span><br><span class="line">obj.<span class="title function_">removeChild</span>()</span><br></pre></td></tr></table></figure><h2 id="14-javascript的本地对象，内置对象和宿主对象"><a href="#14-javascript的本地对象，内置对象和宿主对象" class="headerlink" title="14.javascript的本地对象，内置对象和宿主对象"></a>14.javascript的本地对象，内置对象和宿主对象</h2><p>本地对象为array obj regexp等可以new实例化<br>内置对象为gload Math 等不可以实例化的<br>宿主对象为浏览器自带的document,window 等</p><h2 id="15-window-onload-和document-ready的区别"><a href="#15-window-onload-和document-ready的区别" class="headerlink" title="15.window.onload 和document ready的区别"></a>15.window.onload 和document ready的区别</h2><p>window.onload 是在dom文档树加载完和所有文件加载完之后执行一个函数Document.ready原生种没有这个方法，jquery中有 $().ready(function),在dom文档树加载完之后执行一个函数（注意，这里面的文档树加载完不代表全部文件加载完）。<br>$(document).ready要比window.onload先执行<br>window.onload只能出来一次，$(document).ready可以出现多次</p><h2 id="16-”-”和“-”的不同"><a href="#16-”-”和“-”的不同" class="headerlink" title="16.”&#x3D;&#x3D;”和“&#x3D;&#x3D;&#x3D;”的不同"></a>16.”&#x3D;&#x3D;”和“&#x3D;&#x3D;&#x3D;”的不同</h2><p>前者会自动转换类型<br>后者不会</p><h2 id="17-javascript的同源策略"><a href="#17-javascript的同源策略" class="headerlink" title="17.javascript的同源策略"></a>17.javascript的同源策略</h2><p>一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、议和端口号的组合。<br>Ajax跨域的实现，JSONP的底层实现原理，如何解决跨域请求</p><h2 id="18-JavaScript是一门什么样的语言，它有哪些特点？"><a href="#18-JavaScript是一门什么样的语言，它有哪些特点？" class="headerlink" title="18.JavaScript是一门什么样的语言，它有哪些特点？"></a>18.JavaScript是一门什么样的语言，它有哪些特点？</h2><p>没有标准答案。<br>javaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。JavaScript兼容于ECMA标准，因此也称为ECMAScript。<br>基本特点<br>1．是一种解释性脚本语言（代码不进行预编译）。<br>2．主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。<br>3．可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。<br>4．跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行（如Windows、Linux、Mac、Android、iOS等）。</p><h2 id="19-JavaScript的数据类型都有什么？"><a href="#19-JavaScript的数据类型都有什么？" class="headerlink" title="19.JavaScript的数据类型都有什么？"></a>19.JavaScript的数据类型都有什么？</h2><p>基本数据类型：String,boolean,Number,Undefined, Null<br>引用数据类型：Object(Array,Date,RegExp,Function)<br>那么问题来了，如何判断某变量是否为数组数据类型？<br>方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效<br>方法二.obj instanceof Array 在某些IE版本中不正确<br>方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="title class_">Array</span>.<span class="property">isArray</span>===<span class="string">&quot;undefined&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="property">isArray</span> = <span class="keyword">function</span>(<span class="params">arg</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arg)===<span class="string">&quot;[object Array]&quot;</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？-不使用第三方框架"><a href="#20-已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？-不使用第三方框架" class="headerlink" title="20.已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)"></a>20.已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)</h2><pre><code>document.getElementById(“ID”).value</code></pre><h2 id="21-希望获取到页面中所有的checkbox怎么做？-不使用第三方框架"><a href="#21-希望获取到页面中所有的checkbox怎么做？-不使用第三方框架" class="headerlink" title="21.希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)"></a>21.希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> domList = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(‘input’)</span><br><span class="line"><span class="keyword">var</span> checkBoxList = [];</span><br><span class="line"><span class="keyword">var</span> len = domList.<span class="property">length</span>;　　<span class="comment">//缓存到局部变量</span></span><br><span class="line"><span class="keyword">while</span> (len--) &#123;　　<span class="comment">//使用while的效率会比for循环更高</span></span><br><span class="line">　　<span class="keyword">if</span> (domList[len].<span class="property">type</span> == ‘checkbox’) &#123;</span><br><span class="line">    　　checkBoxList.<span class="title function_">push</span>(domList[len]);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色-不使用第三方框架"><a href="#22-设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色-不使用第三方框架" class="headerlink" title="22.设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)"></a>22.设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(“<span class="variable constant_">ID</span>”);</span><br><span class="line">dom.<span class="property">innerHTML</span> = “xxxx”</span><br><span class="line">dom.<span class="property">style</span>.<span class="property">color</span> = “#<span class="number">000</span>”</span><br></pre></td></tr></table></figure><h2 id="23-当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？"><a href="#23-当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？" class="headerlink" title="23.当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？"></a>23.当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？</h2><p>直接在DOM里绑定事件：<div onclick="test()"></div><br>在JS里通过onclick绑定：xxx.onclick &#x3D; test<br>通过事件添加进行绑定：addEventListener(xxx, ‘click’, test)<br>那么问题来了，Javascript的事件流模型都有什么？<br>“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播<br>“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的<br>“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡</p><h2 id="24-看下列代码输出为何？解释原因。"><a href="#24-看下列代码输出为何？解释原因。" class="headerlink" title="24.看下列代码输出为何？解释原因。"></a>24.看下列代码输出为何？解释原因。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> a); <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">alert</span>(b); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>解释：Undefined是一个只有一个值的数据类型，这个值就是“undefined”，在使用var声明变量但并未对其赋值进行初始化时，这个变量的值就是undefined。而b由于未声明将报错。注意未申明的变量和声明了未赋值的是不一样的。</p><h2 id="25-看下列代码-输出什么？解释原因。"><a href="#25-看下列代码-输出什么？解释原因。" class="headerlink" title="25.看下列代码,输出什么？解释原因。"></a>25.看下列代码,输出什么？解释原因。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> a); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><p>解释：null是一个只有一个值的数据类型，这个值就是null。表示一个空指针对象，所以用typeof检测会返回”object”。</p><h2 id="26-看下列代码-输出什么？解释原因。"><a href="#26-看下列代码-输出什么？解释原因。" class="headerlink" title="26.看下列代码,输出什么？解释原因。"></a>26.看下列代码,输出什么？解释原因。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>;   <span class="comment">// true</span></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>;  <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span>;     <span class="comment">// true</span></span><br><span class="line"><span class="title class_">NaN</span> == <span class="title class_">NaN</span>;  <span class="comment">// false</span></span><br><span class="line">[] == <span class="literal">false</span>; <span class="comment">// true</span></span><br><span class="line">[] == ![];   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>•undefined与null相等，但不恒等（&#x3D;&#x3D;&#x3D;）<br>一个是number一个是string时，会尝试将string转换为number<br>尝试将boolean转换为number，0或1<br>尝试将Object转换成number或string，取决于另外一个对比量的类型<br>所以，对于0、空字符串的判断，建议使用 “&#x3D;&#x3D;&#x3D;” 。“&#x3D;&#x3D;&#x3D;”会先判断两边的值类型，类型不匹配时为false。<br>那么问题来了，看下面的代码，输出什么，foo的值为什么？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;11&quot;</span>+<span class="number">2</span>-<span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo);   <span class="comment">// number</span></span><br></pre></td></tr></table></figure><p>执行完后foo的值为111，foo的类型为number。</p><h2 id="27-看代码给答案。"><a href="#27-看代码给答案。" class="headerlink" title="27.看代码给答案。"></a>27.看代码给答案。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">a.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line">b = a;</span><br><span class="line">b.<span class="property">value</span> = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">alert</span>(a.<span class="property">value</span>);</span><br></pre></td></tr></table></figure><p>答案：2（考察引用数据类型细节）</p><h2 id="28-已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”。"><a href="#28-已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”。" class="headerlink" title="28. 已知数组var stringArray &#x3D; [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”。"></a>28. 已知数组var stringArray &#x3D; [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”。</h2><p>答案：alert(stringArray.join(“ ”))&#x2F;&#x2F; 注意中间的空格</p><h2 id="29-已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”。"><a href="#29-已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”。" class="headerlink" title="29.已知有字符串foo&#x3D;”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。"></a>29.已知有字符串foo&#x3D;”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">combo</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> arr=msg.<span class="title function_">split</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        arr[i]=arr[i].<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>()+arr[i].<span class="title function_">substr</span>(<span class="number">1</span>,arr[i].<span class="property">length</span>-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg=arr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-var-numberArray-3-6-2-4-1-5-（考察基础API）"><a href="#30-var-numberArray-3-6-2-4-1-5-（考察基础API）" class="headerlink" title="30.var numberArray &#x3D; [3,6,2,4,1,5]; （考察基础API）"></a>30.var numberArray &#x3D; [3,6,2,4,1,5]; （考察基础API）</h2><ol><li>实现对该数组的倒排，输出[5,1,4,2,6,3]<br>numberArray.reverse()</li><li>实现对该数组的降序排列，输出[6,5,4,3,2,1]<br>numberArray.sort(function(a,b){return b-a})</li></ol><h2 id="31-输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26"><a href="#31-输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26" class="headerlink" title="31.输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26"></a>31.输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 获取年，getFullYear()返回4位的数字</span></span><br><span class="line"><span class="keyword">var</span> year = d.<span class="title function_">getFullYear</span>();</span><br><span class="line"><span class="comment">// 获取月，月份比较特殊，0是1月，11是12月</span></span><br><span class="line"><span class="keyword">var</span> month = d.<span class="title function_">getMonth</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 变成两位</span></span><br><span class="line">month = month &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + month : month;</span><br><span class="line"><span class="comment">// 获取日</span></span><br><span class="line"><span class="keyword">var</span> day = d.<span class="title function_">getDate</span>();</span><br><span class="line">day = day &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + day : day;</span><br><span class="line"><span class="title function_">alert</span>(year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + day);</span><br></pre></td></tr></table></figure><h2 id="32-将字符串”-id-name-”中的-id-替换成10，-name-替换成Tony-（使用正则表达式）"><a href="#32-将字符串”-id-name-”中的-id-替换成10，-name-替换成Tony-（使用正则表达式）" class="headerlink" title="32.将字符串”{$id}{$name}”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）"></a>32.将字符串”<tr><td>{$id}</td><td>{$name}</td></tr>”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）</h2><p>答案：”<tr><td>{$id}</td><td>{$id}_{$name}</td></tr>“.replace(&#x2F;{$id}&#x2F;g, ‘10’).replace(&#x2F;{$name}&#x2F;g, ‘Tony’);</p><h2 id="33-为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将-“进行转义"><a href="#33-为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将-“进行转义" class="headerlink" title="33.为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义"></a>33.为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">escapeHtml</span>(<span class="params">str</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/[&lt;&gt;”&amp;]/g</span>, <span class="keyword">function</span>(<span class="params">match</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">                   <span class="keyword">case</span> “&lt;”:</span><br><span class="line">                      <span class="keyword">return</span> “&amp;lt;”;</span><br><span class="line">                   <span class="keyword">case</span> “&gt;”:</span><br><span class="line">                      <span class="keyword">return</span> “&amp;gt;”;</span><br><span class="line">                   <span class="keyword">case</span> “&amp;”:</span><br><span class="line">                      <span class="keyword">return</span> “&amp;amp;”;</span><br><span class="line">                   <span class="keyword">case</span> “\””:</span><br><span class="line">                      <span class="keyword">return</span> “&amp;quot;”;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="34-foo-foo-bar-，这行代码是什么意思？为什么要这样写？"><a href="#34-foo-foo-bar-，这行代码是什么意思？为什么要这样写？" class="headerlink" title="34.foo &#x3D; foo||bar ，这行代码是什么意思？为什么要这样写？"></a>34.foo &#x3D; foo||bar ，这行代码是什么意思？为什么要这样写？</h2><p>答案：if(!foo) foo &#x3D; bar; &#x2F;&#x2F;如果foo存在，值不变，否则把bar的值赋给foo。<br>短路表达式：作为”&amp;&amp;”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。</p><h2 id="35-看下列代码，将会输出什么-变量声明提升"><a href="#35-看下列代码，将会输出什么-变量声明提升" class="headerlink" title="35.看下列代码，将会输出什么?(变量声明提升)"></a>35.看下列代码，将会输出什么?(变量声明提升)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>答案：输出undefined 和 2。上面代码相当于：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">//undefined</span></span><br><span class="line">    foo = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 2;   </span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>函数声明与变量声明会被JavaScript引擎隐式地提升到当前作用域的顶部，但是只提升名称不会提升赋值部分。</p><h2 id="36-用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。"><a href="#36-用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。" class="headerlink" title="36.用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。"></a>36.用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randomNub</span>(<span class="params">aArray, len, min, max</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (len &gt;= (max - min)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">&#x27;超过&#x27;</span> + min + <span class="string">&#x27;-&#x27;</span> + max + <span class="string">&#x27;之间的个数范围&#x27;</span> + (max - min - <span class="number">1</span>) + <span class="string">&#x27;个的总数&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (aArray.<span class="property">length</span> &gt;= len) &#123;</span><br><span class="line">                   aArray.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span> a - b</span><br><span class="line">                   &#125;);</span><br><span class="line">                   <span class="keyword">return</span> aArray;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">var</span> nowNub = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min - <span class="number">1</span>)) + (min + <span class="number">1</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; aArray.<span class="property">length</span>; j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (nowNub == aArray[j]) &#123;</span><br><span class="line">                       <span class="title function_">randomNub</span>(aArray, len, min, max);</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               aArray.<span class="title function_">push</span>(nowNub);</span><br><span class="line">               <span class="title function_">randomNub</span>(aArray, len, min, max);</span><br><span class="line">               <span class="keyword">return</span> aArray;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="keyword">var</span> arr=[];</span><br><span class="line"><span class="title function_">randomNub</span>(arr,<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="37-把两个数组合并，并删除第二个元素。"><a href="#37-把两个数组合并，并删除第二个元素。" class="headerlink" title="37.把两个数组合并，并删除第二个元素。"></a>37.把两个数组合并，并删除第二个元素。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> bArray = [<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> cArray = array1.<span class="title function_">concat</span>(bArray);</span><br><span class="line">cArray.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="38-怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）"><a href="#38-怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）" class="headerlink" title="38.怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）"></a>38.怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）</h2><p>1）创建新节点<br>createDocumentFragment()    &#x2F;&#x2F;创建一个DOM片段<br>createElement()   &#x2F;&#x2F;创建一个具体的元素<br>createTextNode()   &#x2F;&#x2F;创建一个文本节点<br>2）添加、移除、替换、插入<br>appendChild()      &#x2F;&#x2F;添加<br>removeChild()      &#x2F;&#x2F;移除<br>replaceChild()      &#x2F;&#x2F;替换<br>insertBefore()      &#x2F;&#x2F;插入<br>3）查找<br>getElementsByTagName()    &#x2F;&#x2F;通过标签名称<br>getElementsByName()     &#x2F;&#x2F;通过元素的Name属性的值<br>getElementById()        &#x2F;&#x2F;通过元素Id，唯一性</p><h2 id="39-有这样一个URL：http-item-taobao-com-item-htm-a-1-b-2-c-d-xxx-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-a-’1′-b-’2′-c-”-d-’xxx’-e-undefined-。"><a href="#39-有这样一个URL：http-item-taobao-com-item-htm-a-1-b-2-c-d-xxx-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-a-’1′-b-’2′-c-”-d-’xxx’-e-undefined-。" class="headerlink" title="39.有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}。"></a>39.有这样一个URL：<a href="http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e%EF%BC%8C%E8%AF%B7%E5%86%99%E4%B8%80%E6%AE%B5JS%E7%A8%8B%E5%BA%8F%E6%8F%90%E5%8F%96URL%E4%B8%AD%E7%9A%84%E5%90%84%E4%B8%AAGET%E5%8F%82%E6%95%B0(%E5%8F%82%E6%95%B0%E5%90%8D%E5%92%8C%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8D%E7%A1%AE%E5%AE%9A)%EF%BC%8C%E5%B0%86%E5%85%B6%E6%8C%89key-value%E5%BD%A2%E5%BC%8F%E8%BF%94%E5%9B%9E%E5%88%B0%E4%B8%80%E4%B8%AAjson%E7%BB%93%E6%9E%84%E4%B8%AD%EF%BC%8C%E5%A6%82%7Ba:%E2%80%991%E2%80%B2">http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′</a>, b:’2′, c:”, d:’xxx’, e:undefined}。</h2><p>答案：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">serilizeUrl</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> urlObject = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\?/</span>.<span class="title function_">test</span>(url)) &#123;</span><br><span class="line">        <span class="keyword">var</span> urlString = url.<span class="title function_">substring</span>(url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> urlArray = urlString.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = urlArray.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> urlItem = urlArray[i];</span><br><span class="line">            <span class="keyword">var</span> item = urlItem.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">            urlObject[item[<span class="number">0</span>]] = item[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> urlObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40-正则表达式构造函数var-reg-new-RegExp-“xxx”-与正则表达字面量var-reg-有什么不同？匹配邮箱的正则表达式？"><a href="#40-正则表达式构造函数var-reg-new-RegExp-“xxx”-与正则表达字面量var-reg-有什么不同？匹配邮箱的正则表达式？" class="headerlink" title="40.正则表达式构造函数var reg&#x3D;new RegExp(“xxx”)与正则表达字面量var reg&#x3D;&#x2F;&#x2F;有什么不同？匹配邮箱的正则表达式？"></a>40.正则表达式构造函数var reg&#x3D;new RegExp(“xxx”)与正则表达字面量var reg&#x3D;&#x2F;&#x2F;有什么不同？匹配邮箱的正则表达式？</h2><p>答案：当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。<br>邮箱的正则匹配：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regMail = <span class="regexp">/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/</span>;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E6%8A%80%E6%9C%AF/">技术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <comments>https://jhcgnb.cn/posts/fec612ee/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>convex</title>
      <link>https://jhcgnb.cn/posts/e911cef5/</link>
      <guid>https://jhcgnb.cn/posts/e911cef5/</guid>
      <pubDate>Sat, 08 Apr 2023 13:26:15 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;http://rx6zk4j2b.hn-bkt.clouddn.com/blogs/image-20230708212656757.png&quot; alt=&quot;image-20230708212656757&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;平面地图综合中的conve</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="http://rx6zk4j2b.hn-bkt.clouddn.com/blogs/image-20230708212656757.png" alt="image-20230708212656757"></p><h3 id="平面地图综合中的convex-hull-差分组合"><a href="#平面地图综合中的convex-hull-差分组合" class="headerlink" title="平面地图综合中的convex hull+差分组合"></a>平面地图综合中的convex hull+差分组合</h3><p>平面地图综合中的 “convex hull + 差分组合” 是一种常用的地理信息处理方法，用于合并多个重叠的平面地图数据集，以生成一个较大范围的一致地图。</p><p>首先，让我们解释一下 “convex hull” 和 “差分组合” 的含义：</p><ol><li><p>Convex Hull（凸包）：凸包是一个几何概念，用于描述一个点集的最小凸多边形。对于给定的点集，凸包是包围这些点的最小凸形状，即没有凹陷的形状。在地图综合中，凸包可以用于找到每个地图数据集的边界。</p></li><li><p>差分组合：差分组合是指将两个或多个数据集进行差分操作，以便将它们合并成一个单一的数据集。在地图综合中，差分组合用于合并多个地图数据集，消除重叠和冗余部分。</p></li></ol><p>现在我们来详细介绍 “convex hull + 差分组合” 的过程：</p><ol><li><p>Convex Hull（凸包）：对于每个地图数据集，首先计算该数据集中所有点的凸包。这可以使用凸包算法，例如Graham扫描算法或Jarvis步进算法。凸包的边界定义了该数据集的外围形状。</p></li><li><p>差分操作：通过对每个地图数据集的凸包进行差分操作，可以消除重叠和冗余的部分。差分操作可以通过将边界相交的部分进行裁剪来实现，从而确保每个数据集的边界只包含在该数据集内的部分。</p></li><li><p>组合数据集：将经过差分操作后的每个数据集的边界进行组合，以生成一个新的、一致的地图数据集。这可以通过将每个数据集的边界多边形进行合并或拼接来实现。最终的合并结果将是一个不重叠且连续的边界，代表了整个地图范围。</p></li></ol><p>这种 “convex hull + 差分组合” 的方法在平面地图综合中很有用，因为它能够合并多个重叠的地图数据集，同时消除重叠和冗余的部分。通过计算凸包和执行差分操作，可以获得一个一致且完整的地图，而不会丢失任何细节或引入不一致的边界。</p><p>需要注意的是，实际的实现可能会涉及更复杂的步骤和算法，具体取决于地图数据的类型和处理需求。此外，该方法还可能需要处理边界相交的情况，以确保生成的地图数据集</p><p>是连续且完整的。因此，在实际应用中，可能需要考虑处理重叠、边界修复和边界连接等问题，以获得高质量的地图综合结果。</p>]]></content:encoded>
      
      
      <category domain="https://jhcgnb.cn/categories/%E5%AD%A6%E6%9C%AF/">学术</category>
      
      
      <category domain="https://jhcgnb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</category>
      
      
      <comments>https://jhcgnb.cn/posts/e911cef5/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
